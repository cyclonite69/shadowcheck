# ShadowCheck PostgreSQL Configuration - Optimized for Ryzen 5 + 16GB RAM
# Performance tuned for SIGINT/spatial workload on bare metal Parrot OS

# Connection and Authentication
listen_addresses = 'localhost'
port = 5432
max_connections = 200  # Increased for concurrent wardriving sessions

# Authentication
password_encryption = scram-sha-256
ssl = off  # Disabled since we're localhost only

# Security and Logging
log_connections = on
log_disconnections = on
log_statement = 'ddl'
log_line_prefix = '%t [%p-%l] %q%u@%d '
log_min_duration_statement = 1000  # Log slow queries (>1s)
log_checkpoints = on

# Memory Configuration - Optimized for 16GB RAM
shared_buffers = 4GB              # 25% of RAM for spatial data caching
work_mem = 128MB                  # Per-operation memory for spatial queries
maintenance_work_mem = 1GB        # For VACUUM, CREATE INDEX, etc.
effective_cache_size = 12GB       # 75% of RAM (OS + PG cache)
temp_buffers = 64MB               # Temporary table operations

# Ryzen 5 CPU Optimization (6 cores / 12 threads typical)
max_worker_processes = 12         # Match thread count
max_parallel_workers_per_gather = 4   # Parallel query workers
max_parallel_workers = 8          # Total parallel workers
max_parallel_maintenance_workers = 4  # For VACUUM, CREATE INDEX

# Storage Optimization (SSD assumed)
random_page_cost = 1.1            # SSD random access cost
seq_page_cost = 1.0               # Sequential access baseline
effective_io_concurrency = 300    # High for NVMe SSD
maintenance_io_concurrency = 300  # Maintenance operations

# WAL Configuration
wal_level = replica
wal_buffers = 64MB                # Large WAL buffer for bulk inserts
checkpoint_completion_target = 0.8 # Spread checkpoint I/O
max_wal_size = 8GB                # Large WAL for wardriving imports
min_wal_size = 2GB
wal_compression = lz4             # Fast compression
checkpoint_timeout = 15min

# Query Planning
default_statistics_target = 500   # Better statistics for spatial queries
from_collapse_limit = 12          # More aggressive join planning
join_collapse_limit = 12

# Background Writer (for high-volume inserts)
bgwriter_delay = 50ms             # More frequent background writes
bgwriter_lru_maxpages = 500       # More pages per round
bgwriter_lru_multiplier = 4.0     # Aggressive background writing

# Autovacuum - Critical for spatial data
autovacuum = on
autovacuum_max_workers = 6        # More workers for large tables
autovacuum_naptime = 15s          # More frequent vacuum checks
autovacuum_vacuum_threshold = 1000
autovacuum_vacuum_scale_factor = 0.1  # Vacuum when 10% of table changes
autovacuum_analyze_threshold = 500
autovacuum_analyze_scale_factor = 0.05  # Analyze when 5% changes
autovacuum_vacuum_cost_delay = 10ms   # Faster vacuum
autovacuum_vacuum_cost_limit = 1000   # Higher cost limit

# PostGIS Specific Optimizations
enable_partitionwise_join = on     # Better performance for partitioned spatial data
enable_partitionwise_aggregate = on
jit = on                          # Enable JIT compilation for complex queries
jit_above_cost = 500000           # JIT for expensive spatial operations

# Lock Management
max_locks_per_transaction = 128    # Higher for complex spatial operations
max_pred_locks_per_transaction = 128

# Logging for Performance Monitoring
log_temp_files = 100MB            # Log large temp file usage
log_lock_waits = on               # Log lock waits
deadlock_timeout = 2s             # Faster deadlock detection
statement_timeout = 0             # No global timeout (set per role)

# Memory Protection
shared_preload_libraries = 'pg_stat_statements'  # Query statistics
track_activity_query_size = 4096  # Larger query text storage

# Connection Pooling Preparation
tcp_keepalives_idle = 300         # Keep connections alive
tcp_keepalives_interval = 30
tcp_keepalives_count = 3