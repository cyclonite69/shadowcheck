var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  Animation: () => Animation,
  AnimationManager: () => AnimationManager,
  CameraKeyframes: () => CameraKeyFrames,
  DeckAdapter: () => DeckAdapter,
  DeckAnimation: () => DeckAnimation,
  DeckLayerKeyframes: () => DeckLayerKeyframes,
  FrameEncoder: () => FrameEncoder,
  GifEncoder: () => GifEncoder,
  JPEGEncoder: () => jpeg_encoder_default,
  JPEGSequenceEncoder: () => jpeg_sequence_encoder_default,
  KeplerAnimation: () => KeplerAnimation,
  KeplerFilterKeyframes: () => kepler_filter_keyframes_default,
  KeplerLayerKeyframes: () => kepler_layer_keyframes_default,
  KeplerTripKeyframes: () => kepler_trip_keyframes_default,
  Keyframes: () => keyframes_default,
  PNGEncoder: () => png_encoder_default,
  PNGSequenceEncoder: () => png_sequence_encoder_default,
  PreviewEncoder: () => PreviewEncoder,
  VERSION: () => VERSION,
  WebMEncoder: () => webm_encoder_default,
  hold: () => hold,
  linear: () => linear
});
module.exports = __toCommonJS(dist_exports);

// dist/utils/log.js
var import_log = require("@probe.gl/log");
var defaultLogger = new import_log.Log({ id: "hubble" });
var log_default = defaultLogger;

// dist/lib/init.js
function checkVersion() {
  const version = true ? "1.4.0" : globalThis.HUBBLE_VERSION || "untranspiled source";
  const existingVersion = globalThis.hubble && globalThis.hubble.VERSION;
  if (existingVersion && existingVersion !== version) {
    throw new Error(`hubble.gl - multiple versions detected: ${existingVersion} vs ${version}`);
  }
  if (!existingVersion) {
    log_default.log(1, `hubble.gl ${version}`)();
    globalThis.hubble = {
      ...globalThis.hubble,
      VERSION: version,
      version,
      log: log_default
    };
  }
  return version;
}
var VERSION = checkVersion();

// dist/encoders/frame-encoder.js
var FrameEncoder = class {
  constructor(settings = {}) {
    this.extension = "";
    this.mimeType = "";
    this.framerate = settings.framerate || 30;
  }
  start() {
    throw new Error("Encoder: Implement a start function");
  }
  async add(canvas) {
    throw new Error("Encoder: Implement an add function");
  }
  async save() {
    throw new Error("Encoder: Implement a save function");
  }
};

// dist/encoders/tar/utils.js
function clean(length) {
  let i;
  const buffer = new Uint8Array(length);
  for (i = 0; i < length; i += 1) {
    buffer[i] = 0;
  }
  return buffer;
}
function pad(num, bytes, base = 8) {
  const numStr = num.toString(base);
  return "000000000000".substr(numStr.length + 12 - bytes) + num;
}
function stringToUint8(input, out, offset = 0) {
  let i;
  let length;
  out = out || clean(input.length);
  for (i = 0, length = input.length; i < length; i += 1) {
    out[offset] = input.charCodeAt(i);
    offset += 1;
  }
  return out;
}

// dist/encoders/tar/header.js
var structure = [
  {
    field: "fileName",
    length: 100
  },
  {
    field: "fileMode",
    length: 8
  },
  {
    field: "uid",
    length: 8
  },
  {
    field: "gid",
    length: 8
  },
  {
    field: "fileSize",
    length: 12
  },
  {
    field: "mtime",
    length: 12
  },
  {
    field: "checksum",
    length: 8
  },
  {
    field: "type",
    length: 1
  },
  {
    field: "linkName",
    length: 100
  },
  {
    field: "ustar",
    length: 8
  },
  {
    field: "owner",
    length: 32
  },
  {
    field: "group",
    length: 32
  },
  {
    field: "majorNumber",
    length: 8
  },
  {
    field: "minorNumber",
    length: 8
  },
  {
    field: "filenamePrefix",
    length: 155
  },
  {
    field: "padding",
    length: 12
  }
];
function format(data, cb) {
  const buffer = clean(512);
  let offset = 0;
  structure.forEach((value) => {
    const str = data[value.field] || "";
    let i;
    let length;
    for (i = 0, length = str.length; i < length; i += 1) {
      buffer[offset] = str.charCodeAt(i);
      offset += 1;
    }
    offset += value.length - i;
  });
  if (typeof cb === "function") {
    return cb(buffer, offset);
  }
  return buffer;
}

// dist/encoders/tar/tar.js
var blockSize;
var recordSize = 512;
var Tar = class {
  constructor(recordsPerBlock) {
    this.written = 0;
    blockSize = (recordsPerBlock || 20) * recordSize;
    this.out = clean(blockSize);
    this.blocks = [];
    this.length = 0;
    this.save = this.save.bind(this);
    this.clear = this.clear.bind(this);
    this.append = this.append.bind(this);
  }
  append(filepath, input, opts = {}) {
    var _a;
    let checksum;
    if (typeof input === "string") {
      input = stringToUint8(input);
    } else if ((input == null ? void 0 : input.constructor) && input.constructor !== Uint8Array.prototype.constructor) {
      const errorInput = (_a = input.constructor.toString().match(/function\s*([$A-Za-z_][0-9A-Za-z_]*)\s*\(/)) == null ? void 0 : _a.at(1);
      const errorMessage = `Invalid input type. You gave me: ${errorInput}`;
      throw errorMessage;
    }
    const mode = opts.mode || parseInt("777", 8) & 4095;
    const mtime = opts.mtime || Math.floor(Number(new Date()) / 1e3);
    const uid = opts.uid || 0;
    const gid = opts.gid || 0;
    const data = {
      fileName: filepath,
      fileMode: pad(mode, 7),
      uid: pad(uid, 7),
      gid: pad(gid, 7),
      fileSize: pad(input.length, 11),
      mtime: pad(mtime, 11),
      checksum: "        ",
      // 0 = just a file
      type: "0",
      ustar: "ustar  ",
      owner: opts.owner || "",
      group: opts.group || ""
    };
    checksum = 0;
    Object.keys(data).forEach((key) => {
      let i;
      const value = data[key];
      let length;
      for (i = 0, length = value.length; i < length; i += 1) {
        checksum += value.charCodeAt(i);
      }
    });
    data.checksum = `${pad(checksum, 6)}\0 `;
    const headerArr = format(data);
    const headerLength = Math.ceil(headerArr.length / recordSize) * recordSize;
    const inputLength = Math.ceil(input.length / recordSize) * recordSize;
    this.blocks.push({
      header: headerArr,
      input,
      headerLength,
      inputLength
    });
  }
  save() {
    const buffers = [];
    const chunks = [];
    let length = 0;
    const max = Math.pow(2, 20);
    let chunk = [];
    this.blocks.forEach((b) => {
      if (length + b.headerLength + b.inputLength > max) {
        chunks.push({ blocks: chunk, length });
        chunk = [];
        length = 0;
      }
      chunk.push(b);
      length += b.headerLength + b.inputLength;
    });
    chunks.push({ blocks: chunk, length });
    chunks.forEach((c) => {
      const buffer = new Uint8Array(c.length);
      let written = 0;
      c.blocks.forEach((b) => {
        buffer.set(b.header, written);
        written += b.headerLength;
        buffer.set(b.input, written);
        written += b.inputLength;
      });
      buffers.push(buffer);
    });
    buffers.push(new Uint8Array(2 * recordSize));
    return new Blob(buffers, { type: "octet/stream" });
  }
  clear() {
    this.written = 0;
    this.out = clean(blockSize);
  }
};
var tar_default = Tar;

// dist/encoders/tar/tar-builder.js
var TAR_BUILDER_OPTIONS = {
  recordsPerBlock: 20
};
var TARBuilder = class {
  static get properties() {
    return {
      id: "tar",
      name: "TAR",
      extensions: ["tar"],
      mimeType: "application/x-tar",
      builder: TARBuilder,
      options: TAR_BUILDER_OPTIONS
    };
  }
  constructor(options) {
    this.options = { ...TAR_BUILDER_OPTIONS, ...options };
    this.tape = new tar_default(this.options.recordsPerBlock);
    this.count = 0;
  }
  addFile(buffer, filename) {
    this.tape.append(filename, new Uint8Array(buffer));
    this.count++;
  }
  async build() {
    return new Response(this.tape.save()).arrayBuffer();
  }
};

// dist/encoders/utils/index.js
function pad2(n) {
  return String(`0000000${n}`).slice(-7);
}
async function canvasToArrayBuffer(canvas, type, quality) {
  const base64 = canvas.toDataURL(type, quality);
  const response = await fetch(base64);
  return await response.arrayBuffer();
}

// dist/encoders/video/png-sequence-encoder.js
var import_core = require("@loaders.gl/core");
var import_zip = require("@loaders.gl/zip");
var TAR = "tar";
var ZIP = "zip";
var PNGSequenceEncoder = class extends FrameEncoder {
  constructor(settings) {
    var _a, _b;
    super(settings);
    this.tarBuilder = null;
    this.filemap = {};
    this.options = { archive: TAR };
    if (settings.png) {
      this.options = { ...settings.png };
    }
    this.options.archive = this.options.archive || TAR;
    switch (this.options.archive) {
      case TAR: {
        this.mimeType = TARBuilder.properties.mimeType;
        this.extension = `.${TARBuilder.properties.extensions[0]}`;
        break;
      }
      case ZIP: {
        this.mimeType = ((_a = import_zip.ZipWriter.mimeTypes) == null ? void 0 : _a[0]) || "";
        this.extension = `.${(_b = import_zip.ZipWriter.extensions) == null ? void 0 : _b[0]}`;
        break;
      }
      default: {
        throw new Error(`Unsupported archive type [zip, tar]: ${this.options.archive}`);
      }
    }
  }
  start() {
    this.tarBuilder = new TARBuilder({});
    this.filemap = {};
  }
  async add(canvas) {
    const mimeType = "image/png";
    const extension = ".png";
    const buffer = await canvasToArrayBuffer(canvas, mimeType);
    switch (this.options.archive) {
      case TAR: {
        if (!this.tarBuilder) {
          break;
        }
        const filename = pad2(this.tarBuilder.count) + extension;
        this.tarBuilder.addFile(buffer, filename);
        break;
      }
      case ZIP: {
        const filename = pad2(Object.keys(this.filemap).length) + extension;
        this.filemap[filename] = buffer;
        break;
      }
      default: {
        throw new Error(`Unsupported archive type [zip, tar]: ${this.options.archive}`);
      }
    }
  }
  /**
   * @return {Promise<Blob>}
   */
  async save() {
    var _a;
    switch (this.options.archive) {
      case TAR: {
        if (!this.tarBuilder) {
          break;
        }
        const arrayBuffer = await this.tarBuilder.build();
        return new Blob([arrayBuffer], { type: TARBuilder.properties.mimeType });
      }
      case ZIP: {
        const arrayBuffer = await (0, import_core.encode)(this.filemap, import_zip.ZipWriter);
        return new Blob([arrayBuffer], { type: (_a = import_zip.ZipWriter.mimeTypes) == null ? void 0 : _a[0] });
      }
      default: {
        throw new Error(`Unsupported archive type [zip, tar]: ${this.options.archive}`);
      }
    }
    return null;
  }
};
var png_sequence_encoder_default = PNGSequenceEncoder;

// dist/encoders/video/jpeg-sequence-encoder.js
var import_core2 = require("@loaders.gl/core");
var import_zip2 = require("@loaders.gl/zip");
var TAR2 = "tar";
var ZIP2 = "zip";
var JPEGSequenceEncoder = class extends FrameEncoder {
  constructor(settings) {
    var _a, _b;
    super(settings);
    this.tarBuilder = null;
    this.filemap = {};
    this.options = { quality: 1, archive: TAR2 };
    if (settings.jpeg) {
      this.options = { ...settings.jpeg };
    }
    this.options.quality = this.options.quality || 1;
    this.options.archive = this.options.archive || TAR2;
    switch (this.options.archive) {
      case TAR2: {
        this.mimeType = TARBuilder.properties.mimeType;
        this.extension = `.${TARBuilder.properties.extensions[0]}`;
        break;
      }
      case ZIP2: {
        this.mimeType = ((_a = import_zip2.ZipWriter.mimeTypes) == null ? void 0 : _a[0]) || "";
        this.extension = `.${(_b = import_zip2.ZipWriter.extensions) == null ? void 0 : _b[0]}`;
        break;
      }
      default: {
        throw new Error(`Unsupported archive type [zip, tar]: ${this.options.archive}`);
      }
    }
  }
  start() {
    this.tarBuilder = new TARBuilder({});
    this.filemap = {};
  }
  async add(canvas) {
    const mimeType = "image/jpeg";
    const extension = ".jpg";
    const buffer = await canvasToArrayBuffer(canvas, mimeType, this.options.quality);
    switch (this.options.archive) {
      case TAR2: {
        if (!this.tarBuilder) {
          break;
        }
        const filename = pad2(this.tarBuilder.count) + extension;
        this.tarBuilder.addFile(buffer, filename);
        break;
      }
      case ZIP2: {
        const filename = pad2(Object.keys(this.filemap).length) + extension;
        this.filemap[filename] = buffer;
        break;
      }
      default: {
        throw new Error(`Unsupported archive type [zip, tar]: ${this.options.archive}`);
      }
    }
  }
  async save() {
    var _a;
    switch (this.options.archive) {
      case TAR2: {
        if (!this.tarBuilder) {
          break;
        }
        const arrayBuffer = await this.tarBuilder.build();
        return new Blob([arrayBuffer], { type: TARBuilder.properties.mimeType });
      }
      case ZIP2: {
        const arrayBuffer = await (0, import_core2.encode)(this.filemap, import_zip2.ZipWriter);
        return new Blob([arrayBuffer], { type: (_a = import_zip2.ZipWriter.mimeTypes) == null ? void 0 : _a[0] });
      }
      default: {
        throw new Error(`Unsupported archive type [zip, tar]: ${this.options.archive}`);
      }
    }
    return null;
  }
};
var jpeg_sequence_encoder_default = JPEGSequenceEncoder;

// dist/encoders/photo/photo-encoder.js
var PhotoEncoder = class extends FrameEncoder {
  constructor(settings) {
    super(settings);
    this.blob = null;
    this.add = this.add.bind(this);
  }
  async add(canvas) {
    const buffer = await canvasToArrayBuffer(canvas, this.mimeType, this.quality);
    this.blob = new Blob([buffer], { type: this.mimeType });
    return Promise.resolve();
  }
  async save() {
    return Promise.resolve(this.blob);
  }
};
var photo_encoder_default = PhotoEncoder;

// dist/encoders/photo/jpeg-encoder.js
var JPEGEncoder = class extends photo_encoder_default {
  constructor(settings) {
    super(settings);
    this.mimeType = "image/jpeg";
    this.extension = ".jpg";
  }
};
var jpeg_encoder_default = JPEGEncoder;

// dist/encoders/photo/png-encoder.js
var JPEGEncoder2 = class extends photo_encoder_default {
  constructor(settings) {
    super(settings);
    this.mimeType = "image/png";
    this.extension = ".png";
  }
};
var png_encoder_default = JPEGEncoder2;

// dist/encoders/video/webm-encoder.js
var import_webm_writer = __toESM(require("webm-writer"), 1);
var WebMEncoder = class extends FrameEncoder {
  constructor(settings) {
    super(settings);
    this.quality = 0.8;
    if (settings.webm && settings.webm.quality) {
      this.quality = settings.webm.quality;
    }
    const canvas = document.createElement("canvas");
    if (canvas.toDataURL("image/webp").substr(5, 10) !== "image/webp") {
      console.error("WebP not supported - try another export format");
    }
    this.extension = ".webm";
    this.mimeType = "video/webm";
    this.videoWriter = null;
    this.start = this.start.bind(this);
    this.add = this.add.bind(this);
    this.save = this.save.bind(this);
  }
  start() {
    this.videoWriter = new import_webm_writer.default({
      quality: this.quality,
      fileWriter: null,
      fd: null,
      frameRate: this.framerate
    });
  }
  async add(canvas) {
    this.videoWriter.addFrame(canvas);
    await Promise.resolve();
  }
  async save() {
    return this.videoWriter.complete();
  }
};
var webm_encoder_default = WebMEncoder;

// dist/encoders/utils/preview-encoder.js
var PreviewEncoder = class extends FrameEncoder {
  start() {
    if (this.af) {
      cancelAnimationFrame(this.af);
    }
  }
  async add(canvas) {
    const animationFrame = new Promise((resolve) => {
      if (this.af) {
        cancelAnimationFrame(this.af);
      }
      this.af = requestAnimationFrame(() => resolve());
    });
    return animationFrame;
  }
  async save() {
    if (this.af) {
      cancelAnimationFrame(this.af);
    }
    return await Promise.resolve(null);
  }
};

// dist/encoders/video/gif-encoder.js
var import_video = require("@loaders.gl/video");
var GifEncoder = class extends FrameEncoder {
  constructor(settings) {
    super(settings);
    this.gifBuilder = null;
    this.source = "images";
    this.mimeType = "image/gif";
    this.extension = ".gif";
    let options = {
      width: 720,
      height: 480,
      numWorkers: 4,
      sampleInterval: 10,
      jpegQuality: 1
    };
    if (settings.gif) {
      options = { ...options, ...settings.gif };
    }
    this.options = options;
    this.start = this.start.bind(this);
    this.add = this.add.bind(this);
    this.save = this.save.bind(this);
  }
  start() {
    this.gifBuilder = new import_video.GIFBuilder({
      source: this.source,
      ...this.options,
      interval: 1 / this.framerate
    });
  }
  async add(canvas) {
    if (this.source === "images") {
      const dataUrl = canvas.toDataURL("image/jpeg", this.options.jpegQuality);
      await this.gifBuilder.add(dataUrl);
    }
  }
  async save() {
    return fetch(await this.gifBuilder.build()).then((res) => res.blob());
  }
};

// dist/animations/animation.js
var Animation = class {
  constructor({ id }) {
    this.unattachedKeyframes = [];
    this.id = id;
    this.unattachedKeyframes = [];
  }
  attachKeyframes(timeline) {
    for (const keyframes of this.unattachedKeyframes) {
      if (keyframes.animationHandle) {
        timeline.detachAnimation(keyframes.animationHandle);
      }
      keyframes.animationHandle = timeline.attachAnimation(keyframes, void 0);
    }
    this.unattachedKeyframes = [];
  }
  getKeyframes() {
    throw new Error("not implemented");
  }
  setKeyframes(props) {
    throw new Error("not implemented");
  }
  animator(animation) {
    throw new Error("not implemented");
  }
  draw() {
    return this.animator(this);
  }
};

// dist/keyframes/keyframes.js
var import_engine = require("@luma.gl/engine");

// dist/keyframes/easings.js
var hold = (p) => p === 1 ? 1 : 0;
var linear = (p) => p;

// dist/keyframes/utils.js
var import_popmotion = require("popmotion");
function sanitizeInterpolators(keyframes, interpolators) {
  if (typeof interpolators === "string") {
    const _interpolators = [];
    for (let idx = 0; idx < keyframes.length - 1; idx++) {
      _interpolators.push(interpolators);
    }
    return _interpolators;
  }
  if (keyframes.length - 1 !== interpolators.length) {
    throw new Error("There must be one fewer interpolator than keyframes");
  }
  return interpolators;
}
function sanitizeEasings(keyframes, easings) {
  if (typeof easings === "function") {
    const _easings = [];
    for (let idx = 0; idx < keyframes.length - 1; idx++) {
      _easings.push(easings);
    }
    return _easings;
  }
  if (keyframes.length - 1 !== easings.length) {
    throw new Error("There must be one fewer easing than keyframes");
  }
  return easings;
}
function sanitizeTimings(keyframes, timings) {
  if (typeof timings === "number") {
    const _timings = [];
    let time = 0;
    for (let idx = 0; idx < keyframes.length; idx++) {
      _timings.push(time);
      time += timings;
    }
    return _timings;
  }
  if (keyframes.length !== timings.length) {
    throw new Error("There must be same number of timings as keyframes");
  }
  return timings;
}
function merge(timings, keyframes, easings, interpolators) {
  const _keyframes = keyframes.map((keyframe, idx) => {
    if (idx === 0) {
      return [timings[idx], { ...keyframe, ease: void 0, interpolate: void 0 }];
    }
    return [
      timings[idx],
      { ...keyframe, ease: easings[idx - 1], interpolate: interpolators[idx - 1] }
    ];
  });
  return _keyframes;
}
function factorInterpolator(start, end, ease = import_popmotion.linear) {
  return (0, import_popmotion.interpolate)([0, 1], [start, end], { ease });
}

// dist/keyframes/keyframes.js
var Keyframes = class extends import_engine.KeyFrames {
  constructor({ features = [], timings, keyframes, easings = linear, interpolators = "linear" }) {
    super([]);
    this.activeFeatures = {};
    this._setActiveFeatures = this._setActiveFeatures.bind(this);
    this.getFrame = this.getFrame.bind(this);
    this.set = this.set.bind(this);
    this.activeFeatures = features.reduce((activeFeatures, feature) => {
      activeFeatures[feature] = false;
      return activeFeatures;
    }, {});
    this.set({ timings, keyframes, easings, interpolators });
  }
  set({ timings, keyframes, easings = linear, interpolators = "linear" }) {
    if (!keyframes || keyframes.length === 0) {
      throw new Error("There must be at least one keyframe");
    }
    const _interpolators = sanitizeInterpolators(keyframes, interpolators);
    const _easings = sanitizeEasings(keyframes, easings);
    const _timings = sanitizeTimings(keyframes, timings);
    this._setActiveFeatures(keyframes);
    const _keyframes = merge(_timings, keyframes, _easings, _interpolators);
    this.keyframes = keyframes;
    this.timings = timings;
    this.easings = easings;
    this.interpolators = interpolators;
    this.setKeyFrames(_keyframes);
  }
  getFrame() {
    const factor = this.factor;
    const start = this.getStartData();
    const end = this.getEndData();
    const frame = {};
    Object.keys(this.activeFeatures).forEach((key) => {
      if (this.activeFeatures[key]) {
        frame[key] = factorInterpolator(start[key], end[key], end.ease)(factor);
      }
    });
    return frame;
  }
  _setActiveFeatures(keyframes) {
    const firstKeyframe = keyframes[0];
    this.activeFeatures = Object.keys(firstKeyframe).reduce((activeFeatures, key) => {
      if (firstKeyframe[key] !== void 0) {
        activeFeatures[key] = true;
      }
      return activeFeatures;
    }, this.activeFeatures);
  }
};
var keyframes_default = Keyframes;

// dist/keyframes/camera-keyframes.js
var import_web_mercator = require("@math.gl/web-mercator");
var import_core3 = require("@math.gl/core");
var LINEARLY_INTERPOLATED_PROPS = ["bearing", "pitch"];
var DEFAULT_OPTS = {
  speed: 1.2,
  curve: 1.414
  // screenSpeed and maxDuration are used only if specified
};
function flyToInterpolator(start, end, factor, options) {
  const viewport = (0, import_web_mercator.flyToViewport)(
    start,
    // @ts-ignore width/height not necessary on end
    end,
    end.ease(factor),
    {
      ...DEFAULT_OPTS,
      ...options
    }
  );
  for (const key of LINEARLY_INTERPOLATED_PROPS) {
    viewport[key] = (0, import_core3.lerp)(start[key] || 0, end[key] || 0, end.ease(factor));
  }
  return viewport;
}
var CameraKeyFrames = class extends keyframes_default {
  constructor({ timings, keyframes, easings, interpolators, width, height }) {
    super({
      timings,
      keyframes,
      easings,
      interpolators,
      features: ["latitude", "longitude", "zoom", "pitch", "bearing"]
    });
    this.width = width;
    this.height = height;
  }
  getFrame() {
    const factor = this.factor;
    const start = this.getStartData();
    const end = this.getEndData();
    if (end.interpolate === "flyTo") {
      if (!this.width || !this.height) {
        throw new Error("width and height must be defined to use flyTo interpolator");
      }
      const maxDuration = this.getEndTime() - this.getStartTime();
      return flyToInterpolator({ ...start, width: this.width, height: this.height }, end, factor, {
        maxDuration
      });
    }
    return super.getFrame();
  }
};

// dist/keyframes/deck-layer-keyframes.js
function getFeatures(keyframes) {
  return keyframes && keyframes[0] ? Object.keys(keyframes[0]) : [];
}
var DeckLayerKeyframes = class extends keyframes_default {
  constructor({ id, features, timings, keyframes, easings }) {
    super({ timings, keyframes, easings, features: features || getFeatures(keyframes) });
    this.id = id;
  }
};

// dist/keyframes/kepler-layer-keyframes.js
function getFeatures2(layer) {
  return layer ? Object.keys(layer.config.visConfig) : [];
}
var KeplerLayerKeyframes = class extends keyframes_default {
  constructor({ layer, timings, keyframes, easings }) {
    super({ timings, keyframes, easings, features: getFeatures2(layer) });
    this.layer = layer;
  }
  set({ layer = void 0, timings, keyframes, easings, interpolators }) {
    if (layer)
      this.layer = layer;
    super.set({ timings, keyframes, easings, interpolators });
  }
};
var kepler_layer_keyframes_default = KeplerLayerKeyframes;

// dist/keyframes/kepler-filter-keyframes.js
function getKeyFramesFree(filter) {
  const delta = filter.value[1] - filter.value[0];
  return {
    keyframes: [
      { value: [filter.domain[0], filter.domain[0] + delta] },
      { value: [filter.domain[1] - delta, filter.domain[1]] }
    ],
    easings: linear
  };
}
function timeRangeKeyframes({ filter, timings }) {
  if (filter.type !== "timeRange") {
    throw new Error("filter type must be 'timeRange'.'");
  }
  const duration = timings[1] - timings[0];
  switch (filter.animationWindow) {
    default:
    case "free": {
      return getKeyFramesFree(filter);
    }
    case "incremental": {
      return {
        keyframes: [
          { value: [filter.value[0], filter.value[0] + 1] },
          { value: [filter.value[0], filter.domain[1]] }
        ],
        easings: linear
      };
    }
    case "point": {
      return {
        keyframes: [{ value: filter.domain[0] }, { value: filter.domain[1] }],
        easings: linear
      };
    }
    case "interval": {
      const { bins, plotType } = filter;
      const { interval } = plotType;
      if (!interval || !bins || Object.keys(bins).length === 0 || !Object.values(bins)[0][interval]) {
        return getKeyFramesFree(filter);
      }
      const intervalBins = Object.values(bins)[0][interval];
      const delta = Math.round(duration / intervalBins.length);
      return {
        timings: intervalBins.map((_, idx) => timings[0] + delta * idx),
        keyframes: intervalBins.map((bin) => {
          return {
            value: [bin.x0, bin.x1]
          };
        }),
        easings: hold
      };
    }
  }
}
var KeplerFilterKeyframes = class extends keyframes_default {
  constructor({ filter = void 0, filterIdx, timings, keyframes = void 0, easings, interpolators, getTimeRangeFilterKeyframes = void 0 }) {
    if ((filter == null ? void 0 : filter.type) === "input") {
      throw new Error("filter type 'input' is not supported.");
    }
    super(KeplerFilterKeyframes._processParams({
      filter,
      timings,
      keyframes,
      easings,
      interpolators,
      getTimeRangeFilterKeyframes
    }));
    this.id = filter == null ? void 0 : filter.id;
    this.type = filter == null ? void 0 : filter.type;
    this.animationWindow = filter == null ? void 0 : filter.animationWindow;
    this.filterIdx = filterIdx;
    this.getTimeRangeFilterKeyframes = getTimeRangeFilterKeyframes;
  }
  set({ filter = void 0, filterIdx = void 0, timings, keyframes, easings, interpolators }) {
    if (filter && filterIdx) {
      this.id = filter.id;
      this.type = filter.type;
      this.animationWindow = filter.animationWindow;
      this.filterIdx = filterIdx;
    }
    super.set(KeplerFilterKeyframes._processParams({
      filter,
      timings,
      keyframes,
      easings,
      interpolators,
      getTimeRangeFilterKeyframes: this.getTimeRangeFilterKeyframes
    }));
  }
  // @ts-expect-error TODO: wrap frame in {value: }
  getFrame() {
    const factor = this.factor;
    const start = this.getStartData();
    const end = this.getEndData();
    if (["select", "multiSelect", "polygon"].includes(this.type || "")) {
      return start.value;
    }
    if (this.type === "range") {
      return [
        factorInterpolator(start.value[0], end.value[0], end.ease)(factor),
        factorInterpolator(start.value[1], end.value[1], end.ease)(factor)
      ];
    }
    if (this.type === "timeRange") {
      switch (this.animationWindow) {
        case "free":
        case "incremental": {
          return [
            factorInterpolator(start.value[0], end.value[0], end.ease)(factor),
            factorInterpolator(start.value[1], end.value[1], end.ease)(factor)
          ];
        }
        case "point": {
          return factorInterpolator(start.value, end.value, end.ease)(factor);
        }
        case "interval":
        default: {
          return start.value;
        }
      }
    }
    return super.getFrame();
  }
  static _processParams({ filter = void 0, timings, keyframes = void 0, easings, interpolators, getTimeRangeFilterKeyframes = void 0 }) {
    let params = { features: ["value"], timings, keyframes, easings, interpolators };
    if (filter && filter.type === "timeRange" && keyframes === void 0) {
      if (!Array.isArray(timings) || timings.length !== 2)
        throw new Error("[start, end] timings required.");
      params = {
        ...params,
        ...getTimeRangeFilterKeyframes ? getTimeRangeFilterKeyframes({ filter, timings }) : timeRangeKeyframes({ filter, timings })
      };
    }
    return params;
  }
};
var kepler_filter_keyframes_default = KeplerFilterKeyframes;

// dist/keyframes/kepler-trip-keyframes.js
function tripKeyframes({ animationConfig }) {
  return {
    keyframes: [{ currentTime: animationConfig.domain[0] }, { currentTime: animationConfig.domain[1] }]
  };
}
var KeplerTripKeyframes = class extends keyframes_default {
  constructor({ animationConfig = void 0, timings, keyframes = void 0, easings, interpolators }) {
    super(KeplerTripKeyframes._processParams({
      animationConfig,
      timings,
      keyframes,
      easings,
      interpolators
    }));
  }
  set({ animationConfig = void 0, timings, keyframes = void 0, easings, interpolators }) {
    super.set(KeplerTripKeyframes._processParams({
      animationConfig,
      timings,
      keyframes,
      easings,
      interpolators
    }));
  }
  static _processParams({ animationConfig = void 0, timings, keyframes = void 0, easings, interpolators }) {
    let params = {
      features: ["currentTime"],
      timings,
      keyframes,
      easings,
      interpolators
    };
    if (animationConfig && keyframes === void 0) {
      if (!Array.isArray(timings) || timings.length !== 2)
        throw new Error("[start, end] timings required.");
      params = { ...params, ...tripKeyframes({ animationConfig }) };
    }
    return params;
  }
};
var kepler_trip_keyframes_default = KeplerTripKeyframes;

// dist/animations/deck-animation.js
function noop() {
}
var DeckAnimation = class extends Animation {
  constructor({ id = "deck", cameraKeyframe = void 0, getLayers = (_) => [], layerKeyframes = [], onLayersUpdate = noop, onCameraUpdate = noop }) {
    super({ id });
    this.layerKeyframes = {};
    this.layerKeyframes = {};
    this.onLayersUpdate = onLayersUpdate;
    this.onCameraUpdate = onCameraUpdate;
    this.getLayers = getLayers;
    this.setKeyframes({ cameraKeyframe, layerKeyframes });
    this.draw();
  }
  setOnLayersUpdate(onLayersUpdate) {
    this.onLayersUpdate = onLayersUpdate;
  }
  setOnCameraUpdate(onCameraUpdate) {
    this.onCameraUpdate = onCameraUpdate;
  }
  setGetLayers(getLayers) {
    this.getLayers = getLayers;
    this.draw();
  }
  setKeyframes({ layerKeyframes = [], cameraKeyframe = void 0, timeline = void 0 }) {
    if (this.cameraKeyframe && cameraKeyframe) {
      this.cameraKeyframe.set(cameraKeyframe);
    } else if (cameraKeyframe) {
      this.cameraKeyframe = new CameraKeyFrames(cameraKeyframe);
      this.unattachedKeyframes.push(this.cameraKeyframe);
    }
    if (layerKeyframes && layerKeyframes.length > 0) {
      this.layerKeyframes = layerKeyframes.reduce((acc, value) => {
        if (acc[value.id]) {
          acc[value.id].set(value);
        } else {
          acc[value.id] = new DeckLayerKeyframes(value);
          this.unattachedKeyframes.push(acc[value.id]);
        }
        return acc;
      }, this.layerKeyframes);
    }
    if (timeline) {
      this.attachKeyframes(timeline);
    }
  }
  getKeyframes() {
    return {
      cameraKeyframe: this.cameraKeyframe,
      layerKeyframes: this.layerKeyframes
    };
  }
  animator(animation) {
    if (animation.cameraKeyframe) {
      animation.onCameraUpdate(animation.cameraKeyframe.getFrame());
    }
    if (Object.values(animation.layerKeyframes).length > 0) {
      animation.onLayersUpdate(this.getLayers(animation));
    }
  }
  applyLayerKeyframes(layers) {
    return layers.map((layer) => {
      if (this.layerKeyframes[layer.id]) {
        const frame = this.layerKeyframes[layer.id].getFrame();
        return layer.clone({
          ...frame,
          updateTriggers: frame
        });
      }
      return layer;
    });
  }
};

// dist/animations/kepler-animation.js
function noop2() {
}
function findLayer({ layers, layerKeyframe }) {
  return layers.find((layer) => layer.id === layerKeyframe.id) || layers.find((layer) => layer.config.label === layerKeyframe.label);
}
function findFilterIdx({ filters, filterKeyframe }) {
  return Number.isFinite(filterKeyframe.filterIdx) ? filterKeyframe.filterIdx : filters.findIndex((filter) => filter.id === filterKeyframe.id);
}
var KeplerAnimation = class extends Animation {
  constructor({ id = "kepler", layers = [], layerKeyframes = [], filters = [], filterKeyframes = [], getTimeRangeFilterKeyframes = void 0, animationConfig = void 0, tripKeyframe = void 0, cameraKeyframe = void 0, onTripFrameUpdate = noop2, onFilterFrameUpdate = noop2, onLayerFrameUpdate = noop2, onCameraFrameUpdate = noop2 }) {
    super({ id });
    this.layerKeyframes = {};
    this.filterKeyframes = {};
    this.tripKeyframe = void 0;
    this.onTripFrameUpdate = onTripFrameUpdate;
    this.onFilterFrameUpdate = onFilterFrameUpdate;
    this.onLayerFrameUpdate = onLayerFrameUpdate;
    this.onCameraFrameUpdate = onCameraFrameUpdate;
    this.layerKeyframes = {};
    this.filterKeyframes = {};
    this.setKeyframes({
      layers,
      layerKeyframes,
      filters,
      filterKeyframes,
      cameraKeyframe,
      animationConfig,
      tripKeyframe,
      getTimeRangeFilterKeyframes
    });
    this.draw();
  }
  setKeyframes({ layers = [], layerKeyframes = [], filters = [], filterKeyframes = [], getTimeRangeFilterKeyframes = void 0, animationConfig = void 0, tripKeyframe = void 0, cameraKeyframe = void 0, timeline = void 0 }) {
    if (this.tripKeyframe && tripKeyframe) {
      this.tripKeyframe.set({ animationConfig, ...tripKeyframe });
    } else if (tripKeyframe) {
      this.tripKeyframe = new kepler_trip_keyframes_default({ animationConfig, ...tripKeyframe });
      this.unattachedKeyframes.push(this.tripKeyframe);
    }
    if (this.cameraKeyframe && cameraKeyframe) {
      this.cameraKeyframe.set(cameraKeyframe);
    } else if (cameraKeyframe) {
      this.cameraKeyframe = new CameraKeyFrames(cameraKeyframe);
      this.unattachedKeyframes.push(this.cameraKeyframe);
    }
    if (layerKeyframes.length > 0) {
      this.layerKeyframes = layerKeyframes.reduce((acc, layerKeyframe) => {
        const layer = findLayer({ layers, layerKeyframe });
        if (layer) {
          if (acc[layer.id]) {
            acc[layer.id].set({ layer, ...layerKeyframe });
          } else {
            acc[layer.id] = new kepler_layer_keyframes_default({ layer, ...layerKeyframe });
            this.unattachedKeyframes.push(acc[layer.id]);
          }
        }
        return acc;
      }, this.layerKeyframes);
    }
    if (filterKeyframes.length > 0) {
      this.filterKeyframes = filterKeyframes.reduce((acc, filterKeyframe) => {
        const filterIdx = findFilterIdx({ filters, filterKeyframe });
        const filter = Number.isFinite(filterIdx) && filters[filterIdx];
        if (filter) {
          if (acc[filter.id]) {
            acc[filter.id].set({ filter, ...filterKeyframe });
          } else {
            acc[filter.id] = new kepler_filter_keyframes_default({
              filter,
              filterIdx,
              getTimeRangeFilterKeyframes,
              ...filterKeyframe
            });
            this.unattachedKeyframes.push(acc[filter.id]);
          }
        }
        return acc;
      }, this.filterKeyframes);
    }
    if (timeline) {
      this.attachKeyframes(timeline);
    }
  }
  getKeyframes() {
    return {
      cameraKeyframe: this.cameraKeyframe,
      layerKeyframes: this.layerKeyframes,
      filterKeyframes: this.filterKeyframes,
      tripKeyframe: this.tripKeyframe
    };
  }
  animator(animation) {
    if (animation.cameraKeyframe) {
      animation.onCameraFrameUpdate(animation.cameraKeyframe.getFrame());
    }
    if (animation.tripKeyframe) {
      animation.onTripFrameUpdate(animation.tripKeyframe.getFrame().currentTime);
    }
    for (const filterKeyframe of Object.values(animation.filterKeyframes)) {
      animation.onFilterFrameUpdate(filterKeyframe.filterIdx, "value", filterKeyframe.getFrame());
    }
    for (const layerKeyframe of Object.values(animation.layerKeyframes)) {
      animation.onLayerFrameUpdate(layerKeyframe.layer, layerKeyframe.getFrame());
    }
  }
};

// dist/animations/animation-manager.js
var import_engine2 = require("@luma.gl/engine");
var AnimationManager = class {
  constructor({ timeline = void 0, animations = [] }) {
    this.animations = {};
    this.timeline = timeline || new import_engine2.Timeline();
    for (const animation of animations) {
      this.attachAnimation(animation);
    }
  }
  attachAnimation(animation) {
    animation.attachKeyframes(this.timeline);
    this.animations[animation.id] = animation;
  }
  setKeyframes(animationId, params) {
    this.animations[animationId].setKeyframes({
      timeline: this.timeline,
      ...params
    });
  }
  getKeyframes(animationId) {
    return this.animations[animationId].getKeyframes();
  }
  getAnimation(animationId) {
    return this.animations[animationId];
  }
  draw() {
    Object.values(this.animations).forEach((animation) => animation.draw());
  }
};

// dist/capture/video-capture.js
var import_downloadjs = __toESM(require("downloadjs"), 1);

// dist/capture/utils.js
function guid() {
  function s4() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
}

// dist/capture/video-capture.js
var VideoCapture = class {
  constructor() {
    this.recording = false;
    this.capturing = false;
    this.timeMs = 0;
    this.onStop = null;
    this.recording = false;
    this.capturing = false;
    this.timeMs = 0;
    this.timecode = null;
    this.encoder = null;
    this.filename = null;
    this._getNextTimeMs = this._getNextTimeMs.bind(this);
    this._step = this._step.bind(this);
    this._capture = this._capture.bind(this);
    this.capture = this.capture.bind(this);
    this.render = this.render.bind(this);
    this.download = this.download.bind(this);
    this.stop = this.stop.bind(this);
    this._save = this._save.bind(this);
  }
  isRecording() {
    return this.recording;
  }
  /**
   * Start recording.
   */
  render({ Encoder, formatConfigs, timecode, filename = void 0, onStop = void 0 }) {
    if (!this.isRecording()) {
      console.time("render");
      this.filename = this._sanitizeFilename(filename);
      this.timecode = this._sanatizeTimecode(timecode);
      console.log(`Starting recording for ${this.timecode.duration}ms.`);
      this.onStop = onStop;
      this.encoder = new Encoder({ ...formatConfigs, framerate: this.timecode.framerate });
      this.recording = true;
      this.encoder.start();
    }
  }
  /**
   * Capture a frame of the canvas.
   */
  capture(canvas, proceedToNextFrame) {
    if (!this.capturing && this.isRecording()) {
      this.capturing = true;
      this._capture(canvas).then((data) => {
        var _a;
        this.capturing = false;
        if (data.kind === "next-frame") {
          proceedToNextFrame(data.nextTimeMs);
        } else if (data.kind === "stop") {
          (_a = this.onStop) == null ? void 0 : _a.call(this);
        } else {
          console.log(data);
        }
      });
    }
  }
  /**
   * Stop and save recording. Execute onComplete when finished.
   */
  stop({ onComplete = void 0, onSave = void 0, onStopped = void 0, abort = false }) {
    if (this.isRecording()) {
      console.log(`Stopped recording. Recorded for ${this.timeMs}ms.`);
      this.recording = false;
      this.capturing = false;
      if (onStopped) {
        onStopped();
      }
      console.timeEnd("render");
      const finish = () => {
        if (onComplete) {
          onComplete();
        }
        this.timecode = null;
        this.onStop = void 0;
      };
      if (!abort) {
        this._save(onSave).then(finish);
      }
      finish();
    }
  }
  download(blob) {
    if (blob) {
      (0, import_downloadjs.default)(blob, this.filename + this.encoder.extension, this.encoder.mimeType);
    }
    return false;
  }
  async _save(callback) {
    if (!callback) {
      callback = this.download;
    }
    console.time("save");
    await this.encoder.save().then(callback).then(() => console.timeEnd("save"));
  }
  _sanitizeFilename(filename) {
    if (!filename) {
      filename = guid();
    }
    return filename;
  }
  _sanatizeTimecode(timecode) {
    const parsedTimecode = {
      duration: void 0,
      ...timecode
    };
    if (!parsedTimecode.start) {
      parsedTimecode.start = 0;
    }
    this.timeMs = parsedTimecode.start;
    if (!parsedTimecode.duration) {
      parsedTimecode.duration = parsedTimecode.end - parsedTimecode.start;
    }
    if (parsedTimecode.duration <= 0) {
      throw new Error(`Invalid recording length (${parsedTimecode.duration}ms).  Must be greater than 0.`);
    }
    return parsedTimecode;
  }
  /**
   * Capture the current canvas.
   */
  async _capture(canvas) {
    if (!this.isRecording()) {
      return { kind: "error", error: "NOT_RECORDING" };
    }
    return await this.encoder.add(canvas).then(this._step).catch((reason) => ({ kind: "error", error: reason }));
  }
  _step() {
    const nextTimeMs = this._getNextTimeMs();
    if (nextTimeMs > this.timecode.end) {
      return { kind: "stop" };
    }
    this.timeMs = nextTimeMs;
    return { kind: "next-frame", nextTimeMs };
  }
  // Get next time MS based on current time MS and framerate
  // @return time in milliseconds for next frame.
  _getNextTimeMs() {
    const frameLengthMs = Math.floor(1e3 / this.timecode.framerate);
    return this.timeMs + frameLengthMs;
  }
};

// dist/adapters/deck-adapter.js
var DeckAdapter = class {
  constructor({ animationManager = void 0, glContext = void 0 }) {
    this.animationManager = animationManager || new AnimationManager({});
    this.glContext = glContext;
    this.videoCapture = new VideoCapture();
    this.shouldAnimate = false;
    this.enabled = false;
    this.getProps = this.getProps.bind(this);
    this.render = this.render.bind(this);
    this.stop = this.stop.bind(this);
    this.seek = this.seek.bind(this);
  }
  setDeck(deck) {
    this.deck = deck;
  }
  getProps({ deck, onNextFrame = void 0, extraProps = void 0 }) {
    if (deck) {
      this.deck = deck;
    }
    const props = {
      _animate: this.shouldAnimate
    };
    if (onNextFrame) {
      props.onAfterRender = () => this.onAfterRender(onNextFrame);
    }
    if (this.enabled) {
      props.controller = false;
    } else {
      props.controller = true;
    }
    if (this.glContext) {
      props.gl = this.glContext;
    }
    return { ...extraProps, ...props };
  }
  render({ Encoder = PreviewEncoder, formatConfigs = {}, filename = void 0, timecode = { start: 0, end: 0, framerate: 30 }, onStopped = void 0, onSave = void 0, onComplete = void 0 }) {
    this.shouldAnimate = true;
    this.videoCapture.render({
      Encoder,
      formatConfigs,
      timecode,
      filename,
      onStop: () => this.stop({ onStopped, onSave, onComplete })
    });
    this.enabled = true;
    this.seek({ timeMs: timecode.start });
  }
  stop({ onStopped, onSave, onComplete, abort }) {
    this.enabled = false;
    this.shouldAnimate = false;
    this.videoCapture.stop({ onStopped, onSave, onComplete, abort });
  }
  seek({ timeMs }) {
    this.animationManager.timeline.setTime(timeMs);
    this.animationManager.draw();
  }
  onAfterRender(proceedToNextFrame, readyToCapture = true) {
    const areAllLayersLoaded = this.deck && this.deck.props.layers.every((layer) => layer.isLoaded);
    if (this.videoCapture.isRecording() && areAllLayersLoaded && readyToCapture) {
      const canvas = this.deck.canvas;
      this.videoCapture.capture(canvas, (nextTimeMs) => {
        this.seek({ timeMs: nextTimeMs });
        proceedToNextFrame(nextTimeMs);
      });
    }
  }
};
//# sourceMappingURL=index.cjs.map
