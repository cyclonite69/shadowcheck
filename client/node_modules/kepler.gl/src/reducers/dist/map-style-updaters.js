"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultMapStyles = exports.editCustomMapStyleUpdater = exports.addCustomMapStyleUpdater = exports.INITIAL_MAP_STYLE = void 0;
exports.getInitialInputStyle = getInitialInputStyle;
exports.getMapStyles = getMapStyles;
exports.setBackgroundColorUpdater = exports.set3dBuildingColorUpdater = exports.resetMapConfigMapStyleUpdater = exports.requestMapStylesUpdater = exports.removeCustomMapStyleUpdater = exports.receiveMapConfigUpdater = exports.mapStyleChangeUpdater = exports.mapConfigChangeUpdater = exports.loadMapStylesUpdater = exports.loadMapStyleErrUpdater = exports.loadCustomMapStyleUpdater = exports.inputMapStyleUpdater = exports.initMapStyleUpdater = void 0;
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _tasks = _interopRequireWildcard(require("react-palm/tasks"));
var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));
var _console = _interopRequireDefault(require("global/console"));
var _utils = require("@kepler.gl/utils");
var _commonUtils = require("@kepler.gl/common-utils");
var _constants = require("@kepler.gl/constants");
var _tasks2 = require("@kepler.gl/tasks");
var _d3Color = require("d3-color");
var _actions = require("@kepler.gl/actions");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
// Utils
var getDefaultMapStyles = exports.getDefaultMapStyles = function getDefaultMapStyles(cdnUrl) {
  return _constants.DEFAULT_MAP_STYLES.reduce(function (accu, curr) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, curr.id, _objectSpread(_objectSpread({}, curr), {}, {
      icon: "".concat(cdnUrl, "/").concat(curr.icon)
    })));
  }, {});
};
var getDefaultState = function getDefaultState() {
  var visibleLayerGroups = {};
  var topLayerGroups = {};
  return {
    styleType: _constants.DEFAULT_BASE_MAP_STYLE,
    visibleLayerGroups: visibleLayerGroups,
    topLayerGroups: topLayerGroups,
    mapStyles: getDefaultMapStyles((0, _utils.getApplicationConfig)().cdnUrl),
    // save mapbox access token
    mapboxApiAccessToken: null,
    mapboxApiUrl: _constants.DEFAULT_MAPBOX_API_URL,
    mapStylesReplaceDefault: false,
    inputStyle: getInitialInputStyle(),
    threeDBuildingColor: (0, _utils.hexToRgb)(_constants.DEFAULT_BLDG_COLOR),
    custom3DBuildingColor: false,
    backgroundColor: (0, _utils.hexToRgb)(_constants.DEFAULT_BACKGROUND_COLOR),
    isLoading: {},
    bottomMapStyle: undefined,
    topMapStyle: undefined
  };
};

/**
 * Updaters for `mapStyle`. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {mapStyleUpdaters} from '@kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // click button to hide label from background map
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             mapStyle: mapStyleUpdaters.mapConfigChangeUpdater(
 *               mapStyle,
 *               {payload: {visibleLayerGroups: {label: false, road: true, background: true}}}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable @typescript-eslint/no-unused-vars */
// @ts-ignore
var mapStyleUpdaters = null;
/* eslint-enable @typescript-eslint/no-unused-vars */
/**
 * Default initial `mapStyle`
 * @memberof mapStyleUpdaters
 * @constant
 * @property styleType - Default: `'dark'`
 * @property visibleLayerGroups - Default: `{}`
 * @property topLayerGroups - Default: `{}`
 * @property mapStyles - mapping from style key to style object
 * @property mapboxApiAccessToken - Default: `null`
 * @Property mapboxApiUrl - Default null
 * @Property mapStylesReplaceDefault - Default: `false`
 * @property inputStyle - Default: `{}`
 * @property threeDBuildingColor - Default: `[r, g, b]`
 * @property backgroundColor - Default: `[r, g, b]`
 * @public
 */
var INITIAL_MAP_STYLE = exports.INITIAL_MAP_STYLE = getDefaultState();
/**
 * Create two map styles from preset map style, one for top map one for bottom
 *
 * @param {string} styleType - current map style
 * @param {Object} visibleLayerGroups - visible layers of bottom map
 * @param {Object} topLayerGroups - visible layers of top map
 * @param {Object} mapStyles - a dictionary of all map styles
 * @returns {Object} bottomMapStyle | topMapStyle | isRaster
 */
function getMapStyles(_ref) {
  var styleType = _ref.styleType,
    visibleLayerGroups = _ref.visibleLayerGroups,
    topLayerGroups = _ref.topLayerGroups,
    mapStyles = _ref.mapStyles;
  var mapStyle = mapStyles[styleType];

  // style might not be loaded yet
  if (!mapStyle || !mapStyle.style) {
    return {};
  }
  var editable = Object.keys(visibleLayerGroups).length;
  var bottomMapStyle = !editable ? mapStyle.style : (0, _utils.editBottomMapStyle)({
    id: styleType,
    mapStyle: mapStyle,
    visibleLayerGroups: visibleLayerGroups
  });
  var hasTopLayer = editable > 0 && Object.values(topLayerGroups).some(function (v) {
    return v;
  });

  // mute top layer if not visible in bottom layer
  var topLayers = hasTopLayer && Object.keys(topLayerGroups).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, topLayerGroups[key] && visibleLayerGroups[key]));
  }, {});
  var topMapStyle = hasTopLayer ? (0, _utils.editTopMapStyle)({
    id: styleType,
    mapStyle: mapStyle,
    visibleLayerGroups: topLayers
  }) : null;
  return {
    bottomMapStyle: bottomMapStyle,
    topMapStyle: topMapStyle,
    editable: editable
  };
}
function findLayerFillColor(layer) {
  return layer && layer.paint && layer.paint['background-color'];
}

// need to be careful because some basemap layer.paint['background-color'] values may be an interpolate array expression instead of a color string
// https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#paint-background-background-color
// https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/#interpolate
function getPaintColor(color) {
  if (Array.isArray(color) && color[0] === 'interpolate') {
    // get color of first zoom break
    // ["interpolate", ["linear"], ["zoom"], 11, "hsl(35, 32%, 91%)", 13, "hsl(35, 12%, 89%)"]
    return color[4];
  }
  return color;
}
function get3DBuildingColor(style) {
  // set building color to be the same as the background color.
  if (!style.style) {
    return (0, _utils.hexToRgb)(_constants.DEFAULT_BLDG_COLOR);
  }
  var backgroundLayer = (style.style.layers || []).find(function (_ref2) {
    var id = _ref2.id;
    return id === 'background';
  });
  var buildingLayer = (style.style.layers || []).find(function (_ref3) {
    var id = _ref3.id;
    return id.match(/building/);
  });
  var buildingColor = findLayerFillColor(buildingLayer) || findLayerFillColor(backgroundLayer) || _constants.DEFAULT_BLDG_COLOR;

  // brighten or darken building based on style
  var operation = style.id.match(/(?=(dark|night))/) ? 'brighter' : 'darker';
  var alpha = 0.2;
  var rgbObj = (0, _d3Color.rgb)(buildingColor)[operation]([alpha]);
  return [rgbObj.r, rgbObj.g, rgbObj.b];
}
function getBackgroundColorFromStyleBaseLayer(style, backupBackgroundColor) {
  var _colorMaybeToRGB;
  if (!style.style) {
    return (0, _utils.colorMaybeToRGB)(backupBackgroundColor) || backupBackgroundColor;
  }

  // @ts-expect-error style.style not typed
  var baseLayer = (style.style.layers || []).find(function (_ref4) {
    var id = _ref4.id;
    return _constants.BASE_MAP_BACKGROUND_LAYER_IDS.includes(id);
  });
  var backgroundColorOfBaseLayer = getPaintColor(findLayerFillColor(baseLayer));
  var newBackgroundColor = typeof backgroundColorOfBaseLayer === 'string' ? backgroundColorOfBaseLayer : backupBackgroundColor;
  var newBackgroundColorAsRGBArray = (_colorMaybeToRGB = (0, _utils.colorMaybeToRGB)(newBackgroundColor)
  // if newBackgroundColor was in string HSL format it can introduce RGB numbers with decimals,
  // which may render the background-color CSS of the <StyledMap> container incorrectly when using our own color utils `rgbToHex()`
  // so we attempt to round to nearest integer here
  ) === null || _colorMaybeToRGB === void 0 ? void 0 : _colorMaybeToRGB.map(function (channelNumber) {
    return Math.round(channelNumber);
  });
  return newBackgroundColorAsRGBArray || backupBackgroundColor;
}

// determine new backgroundColor from either previous state basemap style, previous state backgroundColor, or the DEFAULT_BACKGROUND_COLOR
function getBackgroundColor(previousState, styleType) {
  var previousStateMapStyle = previousState.mapStyles[previousState.styleType];
  var backupBackgroundColor = previousState.backgroundColor || _constants.DEFAULT_BACKGROUND_COLOR;
  var backgroundColor = styleType === _constants.NO_MAP_ID ?
  // if the style has switched to the "no basemap" style,
  // attempt to detect backgroundColor of the previous basemap if it was a mapbox basemap
  // and set it as the "no basemap" backgroundColor
  getBackgroundColorFromStyleBaseLayer(previousStateMapStyle, backupBackgroundColor) :
  // otherwise leave it alone and rely on the previous state's preexisting backgroundColor
  // or DEFAULT_BACKGROUND_COLOR as a last resort
  backupBackgroundColor;
  return backgroundColor;
}
function getLayerGroupsFromStyle(style) {
  return Array.isArray(style === null || style === void 0 ? void 0 : style.layers) ? _constants.DEFAULT_LAYER_GROUPS.filter(function (lg) {
    return style.layers.filter(lg.filter).length;
  }) : [];
}

// Updaters

/**
 * @memberof mapStyleUpdaters
 * @public
 */
var requestMapStylesUpdater = exports.requestMapStylesUpdater = function requestMapStylesUpdater(state, _ref5) {
  var _ref5$payload = _ref5.payload,
    mapStyles = _ref5$payload.mapStyles,
    onSuccess = _ref5$payload.onSuccess;
  var toLoad = Object.keys(mapStyles).reduce(function (accu, id) {
    return _objectSpread(_objectSpread({}, accu), !state.isLoading[id] ? (0, _defineProperty2["default"])({}, id, mapStyles[id]) : {});
  }, {});
  var loadMapStyleTasks = getLoadMapStyleTasks(toLoad, state.mapboxApiAccessToken, state.mapboxApiUrl, onSuccess);
  var isLoading = Object.keys(toLoad).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, true));
  }, {});
  var nextState = _objectSpread(_objectSpread({}, state), {}, {
    isLoading: isLoading
  });
  return (0, _tasks.withTask)(nextState, loadMapStyleTasks);
};

/**
 * Propagate `mapStyle` reducer with `mapboxApiAccessToken` and `mapStylesReplaceDefault`.
 * if mapStylesReplaceDefault is true mapStyles is emptied; loadMapStylesUpdater() will
 * populate mapStyles.
 *
 * @memberof mapStyleUpdaters
 * @public
 */
var initMapStyleUpdater = exports.initMapStyleUpdater = function initMapStyleUpdater(state, _ref7) {
  var _ref7$payload = _ref7.payload,
    payload = _ref7$payload === void 0 ? {} : _ref7$payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    // save mapbox access token to map style state
    mapboxApiAccessToken: payload.mapboxApiAccessToken || state.mapboxApiAccessToken,
    mapboxApiUrl: payload.mapboxApiUrl || state.mapboxApiUrl,
    mapStyles: !payload.mapStylesReplaceDefault ? state.mapStyles : {},
    mapStylesReplaceDefault: payload.mapStylesReplaceDefault || false
  });
};
// });

/**
 * Update `visibleLayerGroups`to change layer group visibility
 * @memberof mapStyleUpdaters
 * @public
 */
var mapConfigChangeUpdater = exports.mapConfigChangeUpdater = function mapConfigChangeUpdater(state, action) {
  return _objectSpread(_objectSpread(_objectSpread({}, state), action.payload), getMapStyles(_objectSpread(_objectSpread({}, state), action.payload)));
};
var hasStyleObject = function hasStyleObject(style) {
  return (0, _utils.isPlainObject)(style === null || style === void 0 ? void 0 : style.style);
};

/**
 * Change to another map style. The selected style should already been loaded into `mapStyle.mapStyles`
 * @memberof mapStyleUpdaters
 * @public
 */
var mapStyleChangeUpdater = exports.mapStyleChangeUpdater = function mapStyleChangeUpdater(state, _ref8) {
  var _state$mapStyles$styl, _state$mapStyles$styl2;
  var _ref8$payload = _ref8.payload,
    styleType = _ref8$payload.styleType,
    onSuccess = _ref8$payload.onSuccess;
  if (
  // we might not have received the style yet
  !state.mapStyles[styleType] ||
  // or if it is a managed custom style asset
  // and if it has not been hydrated with URL info yet (during app first initialization)
  // and it does not have a style object (during adding a custom style)
  ((_state$mapStyles$styl = state.mapStyles[styleType]) === null || _state$mapStyles$styl === void 0 ? void 0 : _state$mapStyles$styl.custom) === 'MANAGED' && !((_state$mapStyles$styl2 = state.mapStyles[styleType]) !== null && _state$mapStyles$styl2 !== void 0 && _state$mapStyles$styl2.url) && !hasStyleObject(state.mapStyles[styleType])) {
    return state;
  }
  if (!hasStyleObject(state.mapStyles[styleType])) {
    // style hasn't loaded yet
    return requestMapStylesUpdater(_objectSpread(_objectSpread({}, state), {}, {
      styleType: styleType
    }), {
      payload: {
        mapStyles: (0, _defineProperty2["default"])({}, styleType, state.mapStyles[styleType]),
        onSuccess: onSuccess
      }
    });
  }
  var defaultLGVisibility = (0, _utils.getDefaultLayerGroupVisibility)(state.mapStyles[styleType]);
  var visibleLayerGroups = (0, _utils.mergeLayerGroupVisibility)(defaultLGVisibility, state.visibleLayerGroups);
  var threeDBuildingColor = state.custom3DBuildingColor ? state.threeDBuildingColor : get3DBuildingColor(state.mapStyles[styleType]);

  // determine new backgroundColor from either previous state basemap style, previous state backgroundColor, or the DEFAULT_BACKGROUND_COLOR
  var backgroundColor = getBackgroundColor(state, styleType);
  return _objectSpread(_objectSpread({}, state), {}, {
    styleType: styleType,
    visibleLayerGroups: visibleLayerGroups,
    threeDBuildingColor: threeDBuildingColor,
    backgroundColor: backgroundColor
  }, getMapStyles(_objectSpread(_objectSpread({}, state), {}, {
    visibleLayerGroups: visibleLayerGroups,
    styleType: styleType
  })));
};

/**
 * Callback when load map style success
 * @memberof mapStyleUpdaters
 * @public
 */
var loadMapStylesUpdater = exports.loadMapStylesUpdater = function loadMapStylesUpdater(state, action) {
  var _ref9 = action.payload || {},
    newStyles = _ref9.newStyles,
    onSuccess = _ref9.onSuccess;
  var addLayerGroups = Object.keys(newStyles).reduce(function (accu, id) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, _objectSpread(_objectSpread({}, newStyles[id]), {}, {
      layerGroups: newStyles[id].layerGroups || getLayerGroupsFromStyle(newStyles[id].style)
    })));
  }, {});
  // reset isLoading
  var isLoading = Object.keys(state.isLoading).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), state.isLoading[key] && hasStyleObject(newStyles[key]) ? (0, _defineProperty2["default"])({}, key, false) : (0, _defineProperty2["default"])({}, key, state.isLoading[key]));
  }, {});
  // add new styles to state
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    isLoading: isLoading,
    mapStyles: _objectSpread(_objectSpread({}, state.mapStyles), addLayerGroups)
  });
  var tasks = createActionTask(onSuccess, {
    styleType: state.styleType
  });
  var nextState = newStyles[state.styleType] ? mapStyleChangeUpdater(newState, {
    payload: {
      styleType: state.styleType
    }
  }) : newState;
  return tasks ? (0, _tasks.withTask)(nextState, tasks) : nextState;
};
function createActionTask(action, payload) {
  if (typeof action === 'function') {
    return (0, _tasks2.ACTION_TASK)().map(function () {
      return action(payload);
    });
  }
  return null;
}

/**
 * Callback when load map style error
 * @memberof mapStyleUpdaters
 * @public
 */
// do nothing for now, if didn't load, skip it
var loadMapStyleErrUpdater = exports.loadMapStyleErrUpdater = function loadMapStyleErrUpdater(state, _ref12) {
  var _ref12$payload = _ref12.payload,
    ids = _ref12$payload.ids,
    error = _ref12$payload.error;
  _console["default"].error(error);
  // reset isLoading
  var isLoading = Object.keys(state.isLoading).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), state.isLoading[key] && (ids || []).includes(key) ? (0, _defineProperty2["default"])({}, key, false) : (0, _defineProperty2["default"])({}, key, state.isLoading[key]));
  }, {});
  return _objectSpread(_objectSpread({}, state), {}, {
    isLoading: isLoading
  });
};

/**
 * Load map style object when pass in saved map config
 * @memberof mapStyleUpdaters
 * @param state `mapStyle`
 * @param action
 * @param action.payload saved map config `{mapStyle, visState, mapState}`
 * @returns nextState or `react-pam` tasks to load map style object
 */
var receiveMapConfigUpdater = exports.receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref15) {
  var config = _ref15.payload.config;
  var _ref16 = config || {},
    mapStyle = _ref16.mapStyle;
  if (!mapStyle) {
    return state;
  }

  // merge default mapStyles
  var merged = mapStyle.mapStyles ? _objectSpread(_objectSpread({}, mapStyle), {}, {
    mapStyles: _objectSpread(_objectSpread({}, mapStyle.mapStyles), state.mapStyles)
  }) : mapStyle;

  // set custom3DBuildingColor: true if mapStyle contains threeDBuildingColor
  // @ts-expect-error
  merged.custom3DBuildingColor =
  // @ts-expect-error
  Boolean(mapStyle.threeDBuildingColor) || merged.custom3DBuildingColor;
  var newState = mapConfigChangeUpdater(state, {
    payload: merged
  });
  return mapStyleChangeUpdater(newState, {
    payload: {
      styleType: newState.styleType
    }
  });
};
function getLoadMapStyleTasks(mapStyles, mapboxApiAccessToken, mapboxApiUrl, onSuccess) {
  return [_tasks["default"].all(Object.values(mapStyles)
  // @ts-expect-error
  .map(function (_ref17) {
    var id = _ref17.id,
      url = _ref17.url,
      accessToken = _ref17.accessToken;
    return {
      id: id,
      url: (0, _utils.getStyleDownloadUrl)(url, accessToken || mapboxApiAccessToken, mapboxApiUrl)
    };
  }).map(_tasks2.LOAD_MAP_STYLE_TASK)).bimap(
  // success
  function (results) {
    return (0, _actions.loadMapStyles)(results.reduce(function (accu, _ref18) {
      var id = _ref18.id,
        style = _ref18.style;
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, _objectSpread(_objectSpread({}, mapStyles[id]), {}, {
        style: style
      })));
    }, {}), onSuccess);
  },
  // error
  function (err) {
    return (0, _actions.loadMapStyleErr)(Object.keys(mapStyles), err);
  })];
}
/**
 * Reset map style config to initial state
 * @memberof mapStyleUpdaters
 * @param state `mapStyle`
 * @returns nextState
 * @public
 */
var resetMapConfigMapStyleUpdater = exports.resetMapConfigMapStyleUpdater = function resetMapConfigMapStyleUpdater(state) {
  var emptyConfig = _objectSpread(_objectSpread(_objectSpread({}, INITIAL_MAP_STYLE), {}, {
    mapboxApiAccessToken: state.mapboxApiAccessToken,
    mapboxApiUrl: state.mapboxApiUrl,
    mapStylesReplaceDefault: state.mapStylesReplaceDefault
  }, state.initialState), {}, {
    mapStyles: state.mapStyles,
    initialState: state.initialState
  });
  return mapStyleChangeUpdater(emptyConfig, {
    payload: {
      styleType: emptyConfig.styleType
    }
  });
};

/**
 * Callback when a custom map style object is received
 * @memberof mapStyleUpdaters
 * @public
 */
var loadCustomMapStyleUpdater = exports.loadCustomMapStyleUpdater = function loadCustomMapStyleUpdater(state, _ref19) {
  var _ref19$payload = _ref19.payload,
    icon = _ref19$payload.icon,
    style = _ref19$payload.style,
    error = _ref19$payload.error;
  return _objectSpread(_objectSpread({}, state), {}, {
    // @ts-expect-error
    inputStyle: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, state.inputStyle), style ? {
      id: state.inputStyle.custom === 'MANAGED' ? state.inputStyle.id // custom MANAGED type
      :
      // @ts-expect-error
      style.id || (0, _commonUtils.generateHashId)(),
      // custom LOCAL type
      // make a copy of the style object
      style: (0, _cloneDeep["default"])(style),
      // @ts-expect-error
      label: state.inputStyle.label || style.name,
      // gathering layer group info from style json
      layerGroups: getLayerGroupsFromStyle(style)
    } : {}), icon ? {
      icon: icon
    } : {}), error !== undefined ? {
      error: error
    } : {})
  });
};

/**
 * Input a custom map style object
 * @memberof mapStyleUpdaters
 * @public
 */
var inputMapStyleUpdater = exports.inputMapStyleUpdater = function inputMapStyleUpdater(state, _ref20) {
  var _updated$icon, _updated$url, _updated$url2;
  var _ref20$payload = _ref20.payload,
    inputStyle = _ref20$payload.inputStyle,
    mapState = _ref20$payload.mapState;
  var updated = _objectSpread(_objectSpread({}, state.inputStyle), inputStyle);

  // differentiate between either a url to hosted style json that needs an icon url,
  // or an icon already available client-side as a data uri
  var isUpdatedIconDataUri = (_updated$icon = updated.icon) === null || _updated$icon === void 0 ? void 0 : _updated$icon.startsWith('data:image');
  var isMapboxStyleUrl = ((_updated$url = updated.url) === null || _updated$url === void 0 ? void 0 : _updated$url.startsWith('mapbox://')) || ((_updated$url2 = updated.url) === null || _updated$url2 === void 0 ? void 0 : _updated$url2.includes('mapbox.com'));
  var icon = !isUpdatedIconDataUri && isMapboxStyleUrl ?
  // Get image icon urls only for mapbox map lib.
  (0, _utils.getStyleImageIcon)({
    mapState: mapState,
    styleUrl: updated.url || '',
    mapboxApiAccessToken: updated.accessToken || state.mapboxApiAccessToken || '',
    mapboxApiUrl: state.mapboxApiUrl || _constants.DEFAULT_MAPBOX_API_URL
  }) : updated.icon;
  return _objectSpread(_objectSpread({}, state), {}, {
    inputStyle: _objectSpread(_objectSpread({}, updated), {}, {
      isValid: true,
      icon: icon
    })
  });
};

/**
 * Add map style from user input to reducer and set it to current style
 * This action is called when user click confirm after putting in a valid style url in the custom map style dialog.
 * It should not be called from outside kepler.gl without a valid `inputStyle` in the `mapStyle` reducer.
 * @memberof mapStyleUpdaters
 */
var addCustomMapStyleUpdater = exports.addCustomMapStyleUpdater = function addCustomMapStyleUpdater(state) {
  var styleId = state.inputStyle.id;
  if (!styleId) return state;
  var newState = getNewStateWithCustomMapStyle(state);
  // set new style
  return mapStyleChangeUpdater(newState, {
    payload: {
      styleType: styleId
    }
  });
};

/**
 * Edit map style from user input to reducer.
 * This action is called when user clicks confirm after editing an existing custom style in the custom map style dialog.
 * It should not be called from outside kepler.gl without a valid `inputStyle` in the `mapStyle` reducer.
 * @memberof mapStyleUpdaters
 */
var editCustomMapStyleUpdater = exports.editCustomMapStyleUpdater = function editCustomMapStyleUpdater(state) {
  return getNewStateWithCustomMapStyle(state);
};
function getNewStateWithCustomMapStyle(state) {
  var styleId = state.inputStyle.id;
  if (!styleId) return state;
  return _objectSpread(_objectSpread({}, state), {}, {
    // @ts-expect-error Property 'layerGroups' is missing in type 'InputStyle' but required in type 'BaseMapStyle'. Legacy case?
    mapStyles: _objectSpread(_objectSpread({}, state.mapStyles), {}, (0, _defineProperty2["default"])({}, styleId, _objectSpread(_objectSpread({}, state.mapStyles[styleId]), state.inputStyle))),
    // set to default
    inputStyle: getInitialInputStyle()
  });
}

/**
 * Remove a custom map style from `state.mapStyle.mapStyles`.
 * @memberof mapStyleUpdaters
 */
var removeCustomMapStyleUpdater = exports.removeCustomMapStyleUpdater = function removeCustomMapStyleUpdater(state, action) {
  var id = action.payload.id;

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  var _state$mapStyles = state.mapStyles,
    _ = _state$mapStyles[id],
    restOfMapStyles = (0, _objectWithoutProperties2["default"])(_state$mapStyles, [id].map(_toPropertyKey));
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    mapStyles: restOfMapStyles
  });
  if (state.styleType === id) {
    // if removing a custom style that is also the current active base map,
    // then reset to the default active base map (`mapStyle.styleType`)
    return mapStyleChangeUpdater(newState, {
      payload: {
        styleType: getDefaultState().styleType
      }
    });
  }
  return newState;
};

/**
 * Updates 3d building color
 * @memberof mapStyleUpdaters
 */
var set3dBuildingColorUpdater = exports.set3dBuildingColorUpdater = function set3dBuildingColorUpdater(state, _ref21) {
  var color = _ref21.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    threeDBuildingColor: color,
    custom3DBuildingColor: true
  });
};

/**
 * Updates background color
 * @memberof mapStyleUpdaters
 */
var setBackgroundColorUpdater = exports.setBackgroundColorUpdater = function setBackgroundColorUpdater(state, _ref22) {
  var color = _ref22.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    backgroundColor: color
  });
};

/**
 * Return the initial input style
 * @return Object
 */
function getInitialInputStyle() {
  return {
    id: null,
    accessToken: null,
    error: false,
    isValid: false,
    label: null,
    style: null,
    url: null,
    icon: null,
    custom: 'LOCAL',
    uploadedFile: null
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfdGFza3MiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfY2xvbmVEZWVwIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9jb25zb2xlIiwiX3V0aWxzIiwiX2NvbW1vblV0aWxzIiwiX2NvbnN0YW50cyIsIl90YXNrczIiLCJfZDNDb2xvciIsIl9hY3Rpb25zIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwiX3RvUHJvcGVydHlLZXkiLCJfdG9QcmltaXRpdmUiLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eTIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImdldERlZmF1bHRNYXBTdHlsZXMiLCJleHBvcnRzIiwiY2RuVXJsIiwiREVGQVVMVF9NQVBfU1RZTEVTIiwicmVkdWNlIiwiYWNjdSIsImN1cnIiLCJpZCIsImljb24iLCJjb25jYXQiLCJnZXREZWZhdWx0U3RhdGUiLCJ2aXNpYmxlTGF5ZXJHcm91cHMiLCJ0b3BMYXllckdyb3VwcyIsInN0eWxlVHlwZSIsIkRFRkFVTFRfQkFTRV9NQVBfU1RZTEUiLCJtYXBTdHlsZXMiLCJnZXRBcHBsaWNhdGlvbkNvbmZpZyIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwibWFwYm94QXBpVXJsIiwiREVGQVVMVF9NQVBCT1hfQVBJX1VSTCIsIm1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0IiwiaW5wdXRTdHlsZSIsImdldEluaXRpYWxJbnB1dFN0eWxlIiwidGhyZWVEQnVpbGRpbmdDb2xvciIsImhleFRvUmdiIiwiREVGQVVMVF9CTERHX0NPTE9SIiwiY3VzdG9tM0RCdWlsZGluZ0NvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9SIiwiaXNMb2FkaW5nIiwiYm90dG9tTWFwU3R5bGUiLCJ1bmRlZmluZWQiLCJ0b3BNYXBTdHlsZSIsIm1hcFN0eWxlVXBkYXRlcnMiLCJJTklUSUFMX01BUF9TVFlMRSIsImdldE1hcFN0eWxlcyIsIl9yZWYiLCJtYXBTdHlsZSIsInN0eWxlIiwiZWRpdGFibGUiLCJlZGl0Qm90dG9tTWFwU3R5bGUiLCJoYXNUb3BMYXllciIsInZhbHVlcyIsInNvbWUiLCJ2IiwidG9wTGF5ZXJzIiwia2V5IiwiZWRpdFRvcE1hcFN0eWxlIiwiZmluZExheWVyRmlsbENvbG9yIiwibGF5ZXIiLCJwYWludCIsImdldFBhaW50Q29sb3IiLCJjb2xvciIsIkFycmF5IiwiaXNBcnJheSIsImdldDNEQnVpbGRpbmdDb2xvciIsImJhY2tncm91bmRMYXllciIsImxheWVycyIsImZpbmQiLCJfcmVmMiIsImJ1aWxkaW5nTGF5ZXIiLCJfcmVmMyIsIm1hdGNoIiwiYnVpbGRpbmdDb2xvciIsIm9wZXJhdGlvbiIsImFscGhhIiwicmdiT2JqIiwicmdiIiwiZyIsImIiLCJnZXRCYWNrZ3JvdW5kQ29sb3JGcm9tU3R5bGVCYXNlTGF5ZXIiLCJiYWNrdXBCYWNrZ3JvdW5kQ29sb3IiLCJfY29sb3JNYXliZVRvUkdCIiwiY29sb3JNYXliZVRvUkdCIiwiYmFzZUxheWVyIiwiX3JlZjQiLCJCQVNFX01BUF9CQUNLR1JPVU5EX0xBWUVSX0lEUyIsImluY2x1ZGVzIiwiYmFja2dyb3VuZENvbG9yT2ZCYXNlTGF5ZXIiLCJuZXdCYWNrZ3JvdW5kQ29sb3IiLCJuZXdCYWNrZ3JvdW5kQ29sb3JBc1JHQkFycmF5IiwibWFwIiwiY2hhbm5lbE51bWJlciIsIk1hdGgiLCJyb3VuZCIsImdldEJhY2tncm91bmRDb2xvciIsInByZXZpb3VzU3RhdGUiLCJwcmV2aW91c1N0YXRlTWFwU3R5bGUiLCJOT19NQVBfSUQiLCJnZXRMYXllckdyb3Vwc0Zyb21TdHlsZSIsIkRFRkFVTFRfTEFZRVJfR1JPVVBTIiwibGciLCJyZXF1ZXN0TWFwU3R5bGVzVXBkYXRlciIsInN0YXRlIiwiX3JlZjUiLCJfcmVmNSRwYXlsb2FkIiwicGF5bG9hZCIsIm9uU3VjY2VzcyIsInRvTG9hZCIsImxvYWRNYXBTdHlsZVRhc2tzIiwiZ2V0TG9hZE1hcFN0eWxlVGFza3MiLCJuZXh0U3RhdGUiLCJ3aXRoVGFzayIsImluaXRNYXBTdHlsZVVwZGF0ZXIiLCJfcmVmNyIsIl9yZWY3JHBheWxvYWQiLCJtYXBDb25maWdDaGFuZ2VVcGRhdGVyIiwiYWN0aW9uIiwiaGFzU3R5bGVPYmplY3QiLCJpc1BsYWluT2JqZWN0IiwibWFwU3R5bGVDaGFuZ2VVcGRhdGVyIiwiX3JlZjgiLCJfc3RhdGUkbWFwU3R5bGVzJHN0eWwiLCJfc3RhdGUkbWFwU3R5bGVzJHN0eWwyIiwiX3JlZjgkcGF5bG9hZCIsImN1c3RvbSIsInVybCIsImRlZmF1bHRMR1Zpc2liaWxpdHkiLCJnZXREZWZhdWx0TGF5ZXJHcm91cFZpc2liaWxpdHkiLCJtZXJnZUxheWVyR3JvdXBWaXNpYmlsaXR5IiwibG9hZE1hcFN0eWxlc1VwZGF0ZXIiLCJfcmVmOSIsIm5ld1N0eWxlcyIsImFkZExheWVyR3JvdXBzIiwibGF5ZXJHcm91cHMiLCJuZXdTdGF0ZSIsInRhc2tzIiwiY3JlYXRlQWN0aW9uVGFzayIsIkFDVElPTl9UQVNLIiwibG9hZE1hcFN0eWxlRXJyVXBkYXRlciIsIl9yZWYxMiIsIl9yZWYxMiRwYXlsb2FkIiwiaWRzIiwiZXJyb3IiLCJDb25zb2xlIiwicmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIiLCJfcmVmMTUiLCJjb25maWciLCJfcmVmMTYiLCJtZXJnZWQiLCJCb29sZWFuIiwiVGFzayIsImFsbCIsIl9yZWYxNyIsImFjY2Vzc1Rva2VuIiwiZ2V0U3R5bGVEb3dubG9hZFVybCIsIkxPQURfTUFQX1NUWUxFX1RBU0siLCJiaW1hcCIsInJlc3VsdHMiLCJsb2FkTWFwU3R5bGVzIiwiX3JlZjE4IiwiZXJyIiwibG9hZE1hcFN0eWxlRXJyIiwicmVzZXRNYXBDb25maWdNYXBTdHlsZVVwZGF0ZXIiLCJlbXB0eUNvbmZpZyIsImluaXRpYWxTdGF0ZSIsImxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXIiLCJfcmVmMTkiLCJfcmVmMTkkcGF5bG9hZCIsImdlbmVyYXRlSGFzaElkIiwiY2xvbmVEZWVwIiwibGFiZWwiLCJuYW1lIiwiaW5wdXRNYXBTdHlsZVVwZGF0ZXIiLCJfcmVmMjAiLCJfdXBkYXRlZCRpY29uIiwiX3VwZGF0ZWQkdXJsIiwiX3VwZGF0ZWQkdXJsMiIsIl9yZWYyMCRwYXlsb2FkIiwibWFwU3RhdGUiLCJ1cGRhdGVkIiwiaXNVcGRhdGVkSWNvbkRhdGFVcmkiLCJzdGFydHNXaXRoIiwiaXNNYXBib3hTdHlsZVVybCIsImdldFN0eWxlSW1hZ2VJY29uIiwic3R5bGVVcmwiLCJpc1ZhbGlkIiwiYWRkQ3VzdG9tTWFwU3R5bGVVcGRhdGVyIiwic3R5bGVJZCIsImdldE5ld1N0YXRlV2l0aEN1c3RvbU1hcFN0eWxlIiwiZWRpdEN1c3RvbU1hcFN0eWxlVXBkYXRlciIsInJlbW92ZUN1c3RvbU1hcFN0eWxlVXBkYXRlciIsIl9zdGF0ZSRtYXBTdHlsZXMiLCJfIiwicmVzdE9mTWFwU3R5bGVzIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMiIsInNldDNkQnVpbGRpbmdDb2xvclVwZGF0ZXIiLCJfcmVmMjEiLCJzZXRCYWNrZ3JvdW5kQ29sb3JVcGRhdGVyIiwiX3JlZjIyIiwidXBsb2FkZWRGaWxlIl0sInNvdXJjZXMiOlsiLi4vc3JjL21hcC1zdHlsZS11cGRhdGVycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgVGFzaywge3dpdGhUYXNrfSBmcm9tICdyZWFjdC1wYWxtL3Rhc2tzJztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoL2Nsb25lRGVlcCc7XG5pbXBvcnQgQ29uc29sZSBmcm9tICdnbG9iYWwvY29uc29sZSc7XG5cbi8vIFV0aWxzXG5pbXBvcnQge1xuICBnZXREZWZhdWx0TGF5ZXJHcm91cFZpc2liaWxpdHksXG4gIGdldFN0eWxlRG93bmxvYWRVcmwsXG4gIG1lcmdlTGF5ZXJHcm91cFZpc2liaWxpdHksXG4gIGVkaXRUb3BNYXBTdHlsZSxcbiAgZWRpdEJvdHRvbU1hcFN0eWxlLFxuICBnZXRTdHlsZUltYWdlSWNvbixcbiAgaXNQbGFpbk9iamVjdCxcbiAgaGV4VG9SZ2IsXG4gIGNvbG9yTWF5YmVUb1JHQixcbiAgZ2V0QXBwbGljYXRpb25Db25maWdcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge2dlbmVyYXRlSGFzaElkfSBmcm9tICdAa2VwbGVyLmdsL2NvbW1vbi11dGlscyc7XG5pbXBvcnQge1xuICBERUZBVUxUX01BUF9TVFlMRVMsXG4gIERFRkFVTFRfTEFZRVJfR1JPVVBTLFxuICBERUZBVUxUX01BUEJPWF9BUElfVVJMLFxuICBOT19NQVBfSUQsXG4gIERFRkFVTFRfQkxER19DT0xPUixcbiAgREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9SLFxuICBCQVNFX01BUF9CQUNLR1JPVU5EX0xBWUVSX0lEUyxcbiAgREVGQVVMVF9CQVNFX01BUF9TVFlMRVxufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge0FDVElPTl9UQVNLLCBMT0FEX01BUF9TVFlMRV9UQVNLfSBmcm9tICdAa2VwbGVyLmdsL3Rhc2tzJztcbmltcG9ydCB7cmdifSBmcm9tICdkMy1jb2xvcic7XG5cbmltcG9ydCB7XG4gIFJHQkNvbG9yLFxuICBMYXllckdyb3VwLFxuICBCYXNlTWFwU3R5bGUsXG4gIE1hcFN0eWxlcyxcbiAgSW5wdXRTdHlsZSxcbiAgVmlzaWJsZUxheWVyR3JvdXBzXG59IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuaW1wb3J0IHtcbiAgQWN0aW9uVHlwZXMsXG4gIFJlY2VpdmVNYXBDb25maWdQYXlsb2FkLFxuICBLZXBsZXJHbEluaXRQYXlsb2FkLFxuICBNYXBTdHlsZUFjdGlvbnMsXG4gIGxvYWRNYXBTdHlsZXMsXG4gIGxvYWRNYXBTdHlsZUVyclxufSBmcm9tICdAa2VwbGVyLmdsL2FjdGlvbnMnO1xuXG5leHBvcnQgdHlwZSBNYXBib3hTdHlsZVVybCA9IHN0cmluZztcblxuZXhwb3J0IHR5cGUgTWFwU3R5bGUgPSB7XG4gIHN0eWxlVHlwZTogc3RyaW5nO1xuICB2aXNpYmxlTGF5ZXJHcm91cHM6IFZpc2libGVMYXllckdyb3VwcztcbiAgdG9wTGF5ZXJHcm91cHM6IFZpc2libGVMYXllckdyb3VwcztcbiAgbWFwU3R5bGVzOiBNYXBTdHlsZXM7XG4gIC8vIHNhdmUgbWFwYm94IGFjY2VzcyB0b2tlblxuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogc3RyaW5nIHwgbnVsbDtcbiAgbWFwYm94QXBpVXJsOiBzdHJpbmc7XG4gIG1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0OiBib29sZWFuO1xuICBpbnB1dFN0eWxlOiBJbnB1dFN0eWxlO1xuICB0aHJlZURCdWlsZGluZ0NvbG9yOiBSR0JDb2xvcjtcbiAgYmFja2dyb3VuZENvbG9yOiBSR0JDb2xvcjtcbiAgY3VzdG9tM0RCdWlsZGluZ0NvbG9yOiBib29sZWFuO1xuICBib3R0b21NYXBTdHlsZTogYW55O1xuICB0b3BNYXBTdHlsZTogYW55O1xuICBpbml0aWFsU3RhdGU/OiBNYXBTdHlsZTtcbiAgaXNMb2FkaW5nOiB7XG4gICAgW2tleTogc3RyaW5nXTogYm9vbGVhbjtcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXREZWZhdWx0TWFwU3R5bGVzID0gKGNkblVybDogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBERUZBVUxUX01BUF9TVFlMRVMucmVkdWNlKFxuICAgIChhY2N1LCBjdXJyKSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIFtjdXJyLmlkXToge1xuICAgICAgICAuLi5jdXJyLFxuICAgICAgICBpY29uOiBgJHtjZG5Vcmx9LyR7Y3Vyci5pY29ufWBcbiAgICAgIH1cbiAgICB9KSxcbiAgICB7fVxuICApO1xufTtcblxuY29uc3QgZ2V0RGVmYXVsdFN0YXRlID0gKCk6IE1hcFN0eWxlID0+IHtcbiAgY29uc3QgdmlzaWJsZUxheWVyR3JvdXBzID0ge307XG4gIGNvbnN0IHRvcExheWVyR3JvdXBzID0ge307XG5cbiAgcmV0dXJuIHtcbiAgICBzdHlsZVR5cGU6IERFRkFVTFRfQkFTRV9NQVBfU1RZTEUsXG4gICAgdmlzaWJsZUxheWVyR3JvdXBzLFxuICAgIHRvcExheWVyR3JvdXBzLFxuICAgIG1hcFN0eWxlczogZ2V0RGVmYXVsdE1hcFN0eWxlcyhnZXRBcHBsaWNhdGlvbkNvbmZpZygpLmNkblVybCksXG4gICAgLy8gc2F2ZSBtYXBib3ggYWNjZXNzIHRva2VuXG4gICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IG51bGwsXG4gICAgbWFwYm94QXBpVXJsOiBERUZBVUxUX01BUEJPWF9BUElfVVJMLFxuICAgIG1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0OiBmYWxzZSxcbiAgICBpbnB1dFN0eWxlOiBnZXRJbml0aWFsSW5wdXRTdHlsZSgpLFxuICAgIHRocmVlREJ1aWxkaW5nQ29sb3I6IGhleFRvUmdiKERFRkFVTFRfQkxER19DT0xPUiksXG4gICAgY3VzdG9tM0RCdWlsZGluZ0NvbG9yOiBmYWxzZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGhleFRvUmdiKERFRkFVTFRfQkFDS0dST1VORF9DT0xPUiksXG4gICAgaXNMb2FkaW5nOiB7fSxcbiAgICBib3R0b21NYXBTdHlsZTogdW5kZWZpbmVkLFxuICAgIHRvcE1hcFN0eWxlOiB1bmRlZmluZWRcbiAgfTtcbn07XG5cbi8qKlxuICogVXBkYXRlcnMgZm9yIGBtYXBTdHlsZWAuIENhbiBiZSB1c2VkIGluIHlvdXIgcm9vdCByZWR1Y2VyIHRvIGRpcmVjdGx5IG1vZGlmeSBrZXBsZXIuZ2wncyBzdGF0ZS5cbiAqIFJlYWQgbW9yZSBhYm91dCBbVXNpbmcgdXBkYXRlcnNdKC4uL2FkdmFuY2VkLXVzYWdlL3VzaW5nLXVwZGF0ZXJzLm1kKVxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQga2VwbGVyR2xSZWR1Y2VyLCB7bWFwU3R5bGVVcGRhdGVyc30gZnJvbSAnQGtlcGxlci5nbC9yZWR1Y2Vycyc7XG4gKiAvLyBSb290IFJlZHVjZXJcbiAqIGNvbnN0IHJlZHVjZXJzID0gY29tYmluZVJlZHVjZXJzKHtcbiAqICBrZXBsZXJHbDoga2VwbGVyR2xSZWR1Y2VyLFxuICogIGFwcDogYXBwUmVkdWNlclxuICogfSk7XG4gKlxuICogY29uc3QgY29tcG9zZWRSZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAqICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gKiAgICAvLyBjbGljayBidXR0b24gdG8gaGlkZSBsYWJlbCBmcm9tIGJhY2tncm91bmQgbWFwXG4gKiAgICBjYXNlICdDTElDS19CVVRUT04nOlxuICogICAgICByZXR1cm4ge1xuICogICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgIGtlcGxlckdsOiB7XG4gKiAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbCxcbiAqICAgICAgICAgIGZvbzoge1xuICogICAgICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wuZm9vLFxuICogICAgICAgICAgICAgbWFwU3R5bGU6IG1hcFN0eWxlVXBkYXRlcnMubWFwQ29uZmlnQ2hhbmdlVXBkYXRlcihcbiAqICAgICAgICAgICAgICAgbWFwU3R5bGUsXG4gKiAgICAgICAgICAgICAgIHtwYXlsb2FkOiB7dmlzaWJsZUxheWVyR3JvdXBzOiB7bGFiZWw6IGZhbHNlLCByb2FkOiB0cnVlLCBiYWNrZ3JvdW5kOiB0cnVlfX19XG4gKiAgICAgICAgICAgICApXG4gKiAgICAgICAgICB9XG4gKiAgICAgICAgfVxuICogICAgICB9O1xuICogIH1cbiAqICByZXR1cm4gcmVkdWNlcnMoc3RhdGUsIGFjdGlvbik7XG4gKiB9O1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGNvbXBvc2VkUmVkdWNlcjtcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG1hcFN0eWxlVXBkYXRlcnMgPSBudWxsO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogRGVmYXVsdCBpbml0aWFsIGBtYXBTdHlsZWBcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAY29uc3RhbnRcbiAqIEBwcm9wZXJ0eSBzdHlsZVR5cGUgLSBEZWZhdWx0OiBgJ2RhcmsnYFxuICogQHByb3BlcnR5IHZpc2libGVMYXllckdyb3VwcyAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSB0b3BMYXllckdyb3VwcyAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSBtYXBTdHlsZXMgLSBtYXBwaW5nIGZyb20gc3R5bGUga2V5IHRvIHN0eWxlIG9iamVjdFxuICogQHByb3BlcnR5IG1hcGJveEFwaUFjY2Vzc1Rva2VuIC0gRGVmYXVsdDogYG51bGxgXG4gKiBAUHJvcGVydHkgbWFwYm94QXBpVXJsIC0gRGVmYXVsdCBudWxsXG4gKiBAUHJvcGVydHkgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQgLSBEZWZhdWx0OiBgZmFsc2VgXG4gKiBAcHJvcGVydHkgaW5wdXRTdHlsZSAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSB0aHJlZURCdWlsZGluZ0NvbG9yIC0gRGVmYXVsdDogYFtyLCBnLCBiXWBcbiAqIEBwcm9wZXJ0eSBiYWNrZ3JvdW5kQ29sb3IgLSBEZWZhdWx0OiBgW3IsIGcsIGJdYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgSU5JVElBTF9NQVBfU1RZTEU6IE1hcFN0eWxlID0gZ2V0RGVmYXVsdFN0YXRlKCk7XG5cbmludGVyZmFjZSBHZXRNYXBTdHlsZXNQYXJhbSB7XG4gIHN0eWxlVHlwZTogc3RyaW5nO1xuICB2aXNpYmxlTGF5ZXJHcm91cHM6IHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufTtcbiAgdG9wTGF5ZXJHcm91cHM6IHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufTtcbiAgbWFwU3R5bGVzOiB7W2lkOiBzdHJpbmddOiBhbnl9O1xufVxuXG4vKipcbiAqIENyZWF0ZSB0d28gbWFwIHN0eWxlcyBmcm9tIHByZXNldCBtYXAgc3R5bGUsIG9uZSBmb3IgdG9wIG1hcCBvbmUgZm9yIGJvdHRvbVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVR5cGUgLSBjdXJyZW50IG1hcCBzdHlsZVxuICogQHBhcmFtIHtPYmplY3R9IHZpc2libGVMYXllckdyb3VwcyAtIHZpc2libGUgbGF5ZXJzIG9mIGJvdHRvbSBtYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b3BMYXllckdyb3VwcyAtIHZpc2libGUgbGF5ZXJzIG9mIHRvcCBtYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXBTdHlsZXMgLSBhIGRpY3Rpb25hcnkgb2YgYWxsIG1hcCBzdHlsZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGJvdHRvbU1hcFN0eWxlIHwgdG9wTWFwU3R5bGUgfCBpc1Jhc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwU3R5bGVzKHtcbiAgc3R5bGVUeXBlLFxuICB2aXNpYmxlTGF5ZXJHcm91cHMsXG4gIHRvcExheWVyR3JvdXBzLFxuICBtYXBTdHlsZXNcbn06IEdldE1hcFN0eWxlc1BhcmFtKSB7XG4gIGNvbnN0IG1hcFN0eWxlID0gbWFwU3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgLy8gc3R5bGUgbWlnaHQgbm90IGJlIGxvYWRlZCB5ZXRcbiAgaWYgKCFtYXBTdHlsZSB8fCAhbWFwU3R5bGUuc3R5bGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCBlZGl0YWJsZSA9IE9iamVjdC5rZXlzKHZpc2libGVMYXllckdyb3VwcykubGVuZ3RoO1xuXG4gIGNvbnN0IGJvdHRvbU1hcFN0eWxlID0gIWVkaXRhYmxlXG4gICAgPyBtYXBTdHlsZS5zdHlsZVxuICAgIDogZWRpdEJvdHRvbU1hcFN0eWxlKHtcbiAgICAgICAgaWQ6IHN0eWxlVHlwZSxcbiAgICAgICAgbWFwU3R5bGUsXG4gICAgICAgIHZpc2libGVMYXllckdyb3Vwc1xuICAgICAgfSk7XG5cbiAgY29uc3QgaGFzVG9wTGF5ZXIgPSBlZGl0YWJsZSA+IDAgJiYgT2JqZWN0LnZhbHVlcyh0b3BMYXllckdyb3Vwcykuc29tZSh2ID0+IHYpO1xuXG4gIC8vIG11dGUgdG9wIGxheWVyIGlmIG5vdCB2aXNpYmxlIGluIGJvdHRvbSBsYXllclxuICBjb25zdCB0b3BMYXllcnMgPVxuICAgIGhhc1RvcExheWVyICYmXG4gICAgT2JqZWN0LmtleXModG9wTGF5ZXJHcm91cHMpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiB0b3BMYXllckdyb3Vwc1trZXldICYmIHZpc2libGVMYXllckdyb3Vwc1trZXldXG4gICAgICB9KSxcbiAgICAgIHt9IGFzIHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufVxuICAgICk7XG5cbiAgY29uc3QgdG9wTWFwU3R5bGUgPSBoYXNUb3BMYXllclxuICAgID8gZWRpdFRvcE1hcFN0eWxlKHtcbiAgICAgICAgaWQ6IHN0eWxlVHlwZSxcbiAgICAgICAgbWFwU3R5bGUsXG4gICAgICAgIHZpc2libGVMYXllckdyb3VwczogdG9wTGF5ZXJzXG4gICAgICB9KVxuICAgIDogbnVsbDtcblxuICByZXR1cm4ge2JvdHRvbU1hcFN0eWxlLCB0b3BNYXBTdHlsZSwgZWRpdGFibGV9O1xufVxuXG5mdW5jdGlvbiBmaW5kTGF5ZXJGaWxsQ29sb3IobGF5ZXIpIHtcbiAgcmV0dXJuIGxheWVyICYmIGxheWVyLnBhaW50ICYmIGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLWNvbG9yJ107XG59XG5cbi8vIG5lZWQgdG8gYmUgY2FyZWZ1bCBiZWNhdXNlIHNvbWUgYmFzZW1hcCBsYXllci5wYWludFsnYmFja2dyb3VuZC1jb2xvciddIHZhbHVlcyBtYXkgYmUgYW4gaW50ZXJwb2xhdGUgYXJyYXkgZXhwcmVzc2lvbiBpbnN0ZWFkIG9mIGEgY29sb3Igc3RyaW5nXG4vLyBodHRwczovL2RvY3MubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvc3R5bGUtc3BlYy9sYXllcnMvI3BhaW50LWJhY2tncm91bmQtYmFja2dyb3VuZC1jb2xvclxuLy8gaHR0cHM6Ly9kb2NzLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3N0eWxlLXNwZWMvZXhwcmVzc2lvbnMvI2ludGVycG9sYXRlXG5mdW5jdGlvbiBnZXRQYWludENvbG9yKGNvbG9yKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSAmJiBjb2xvclswXSA9PT0gJ2ludGVycG9sYXRlJykge1xuICAgIC8vIGdldCBjb2xvciBvZiBmaXJzdCB6b29tIGJyZWFrXG4gICAgLy8gW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJ6b29tXCJdLCAxMSwgXCJoc2woMzUsIDMyJSwgOTElKVwiLCAxMywgXCJoc2woMzUsIDEyJSwgODklKVwiXVxuICAgIHJldHVybiBjb2xvcls0XTtcbiAgfVxuICByZXR1cm4gY29sb3I7XG59XG5cbmZ1bmN0aW9uIGdldDNEQnVpbGRpbmdDb2xvcihzdHlsZSk6IFJHQkNvbG9yIHtcbiAgLy8gc2V0IGJ1aWxkaW5nIGNvbG9yIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICBpZiAoIXN0eWxlLnN0eWxlKSB7XG4gICAgcmV0dXJuIGhleFRvUmdiKERFRkFVTFRfQkxER19DT0xPUik7XG4gIH1cblxuICBjb25zdCBiYWNrZ3JvdW5kTGF5ZXIgPSAoc3R5bGUuc3R5bGUubGF5ZXJzIHx8IFtdKS5maW5kKCh7aWR9KSA9PiBpZCA9PT0gJ2JhY2tncm91bmQnKTtcblxuICBjb25zdCBidWlsZGluZ0xheWVyID0gKHN0eWxlLnN0eWxlLmxheWVycyB8fCBbXSkuZmluZCgoe2lkfSkgPT4gaWQubWF0Y2goL2J1aWxkaW5nLykpO1xuXG4gIGNvbnN0IGJ1aWxkaW5nQ29sb3IgPVxuICAgIGZpbmRMYXllckZpbGxDb2xvcihidWlsZGluZ0xheWVyKSB8fCBmaW5kTGF5ZXJGaWxsQ29sb3IoYmFja2dyb3VuZExheWVyKSB8fCBERUZBVUxUX0JMREdfQ09MT1I7XG5cbiAgLy8gYnJpZ2h0ZW4gb3IgZGFya2VuIGJ1aWxkaW5nIGJhc2VkIG9uIHN0eWxlXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHN0eWxlLmlkLm1hdGNoKC8oPz0oZGFya3xuaWdodCkpLykgPyAnYnJpZ2h0ZXInIDogJ2Rhcmtlcic7XG5cbiAgY29uc3QgYWxwaGEgPSAwLjI7XG4gIGNvbnN0IHJnYk9iaiA9IHJnYihidWlsZGluZ0NvbG9yKVtvcGVyYXRpb25dKFthbHBoYV0pO1xuICByZXR1cm4gW3JnYk9iai5yLCByZ2JPYmouZywgcmdiT2JqLmJdO1xufVxuXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kQ29sb3JGcm9tU3R5bGVCYXNlTGF5ZXIoXG4gIHN0eWxlOiBCYXNlTWFwU3R5bGUsXG4gIGJhY2t1cEJhY2tncm91bmRDb2xvcjogUkdCQ29sb3Jcbik6IFJHQkNvbG9yIHtcbiAgaWYgKCFzdHlsZS5zdHlsZSkge1xuICAgIHJldHVybiBjb2xvck1heWJlVG9SR0IoYmFja3VwQmFja2dyb3VuZENvbG9yKSB8fCBiYWNrdXBCYWNrZ3JvdW5kQ29sb3I7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yIHN0eWxlLnN0eWxlIG5vdCB0eXBlZFxuICBjb25zdCBiYXNlTGF5ZXIgPSAoc3R5bGUuc3R5bGUubGF5ZXJzIHx8IFtdKS5maW5kKCh7aWR9KSA9PlxuICAgIEJBU0VfTUFQX0JBQ0tHUk9VTkRfTEFZRVJfSURTLmluY2x1ZGVzKGlkKVxuICApO1xuXG4gIGNvbnN0IGJhY2tncm91bmRDb2xvck9mQmFzZUxheWVyID0gZ2V0UGFpbnRDb2xvcihmaW5kTGF5ZXJGaWxsQ29sb3IoYmFzZUxheWVyKSk7XG5cbiAgY29uc3QgbmV3QmFja2dyb3VuZENvbG9yID1cbiAgICB0eXBlb2YgYmFja2dyb3VuZENvbG9yT2ZCYXNlTGF5ZXIgPT09ICdzdHJpbmcnXG4gICAgICA/IGJhY2tncm91bmRDb2xvck9mQmFzZUxheWVyXG4gICAgICA6IGJhY2t1cEJhY2tncm91bmRDb2xvcjtcblxuICBjb25zdCBuZXdCYWNrZ3JvdW5kQ29sb3JBc1JHQkFycmF5ID0gY29sb3JNYXliZVRvUkdCKG5ld0JhY2tncm91bmRDb2xvcilcbiAgICAvLyBpZiBuZXdCYWNrZ3JvdW5kQ29sb3Igd2FzIGluIHN0cmluZyBIU0wgZm9ybWF0IGl0IGNhbiBpbnRyb2R1Y2UgUkdCIG51bWJlcnMgd2l0aCBkZWNpbWFscyxcbiAgICAvLyB3aGljaCBtYXkgcmVuZGVyIHRoZSBiYWNrZ3JvdW5kLWNvbG9yIENTUyBvZiB0aGUgPFN0eWxlZE1hcD4gY29udGFpbmVyIGluY29ycmVjdGx5IHdoZW4gdXNpbmcgb3VyIG93biBjb2xvciB1dGlscyBgcmdiVG9IZXgoKWBcbiAgICAvLyBzbyB3ZSBhdHRlbXB0IHRvIHJvdW5kIHRvIG5lYXJlc3QgaW50ZWdlciBoZXJlXG4gICAgPy5tYXAoY2hhbm5lbE51bWJlciA9PiBNYXRoLnJvdW5kKGNoYW5uZWxOdW1iZXIpKSBhcyBSR0JDb2xvciB8IG51bGw7XG5cbiAgcmV0dXJuIG5ld0JhY2tncm91bmRDb2xvckFzUkdCQXJyYXkgfHwgYmFja3VwQmFja2dyb3VuZENvbG9yO1xufVxuXG4vLyBkZXRlcm1pbmUgbmV3IGJhY2tncm91bmRDb2xvciBmcm9tIGVpdGhlciBwcmV2aW91cyBzdGF0ZSBiYXNlbWFwIHN0eWxlLCBwcmV2aW91cyBzdGF0ZSBiYWNrZ3JvdW5kQ29sb3IsIG9yIHRoZSBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1JcbmZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcihwcmV2aW91c1N0YXRlOiBNYXBTdHlsZSwgc3R5bGVUeXBlOiBzdHJpbmcpIHtcbiAgY29uc3QgcHJldmlvdXNTdGF0ZU1hcFN0eWxlID0gcHJldmlvdXNTdGF0ZS5tYXBTdHlsZXNbcHJldmlvdXNTdGF0ZS5zdHlsZVR5cGVdO1xuICBjb25zdCBiYWNrdXBCYWNrZ3JvdW5kQ29sb3IgPSBwcmV2aW91c1N0YXRlLmJhY2tncm91bmRDb2xvciB8fCBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1I7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9XG4gICAgc3R5bGVUeXBlID09PSBOT19NQVBfSURcbiAgICAgID8gLy8gaWYgdGhlIHN0eWxlIGhhcyBzd2l0Y2hlZCB0byB0aGUgXCJubyBiYXNlbWFwXCIgc3R5bGUsXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gZGV0ZWN0IGJhY2tncm91bmRDb2xvciBvZiB0aGUgcHJldmlvdXMgYmFzZW1hcCBpZiBpdCB3YXMgYSBtYXBib3ggYmFzZW1hcFxuICAgICAgICAvLyBhbmQgc2V0IGl0IGFzIHRoZSBcIm5vIGJhc2VtYXBcIiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgZ2V0QmFja2dyb3VuZENvbG9yRnJvbVN0eWxlQmFzZUxheWVyKHByZXZpb3VzU3RhdGVNYXBTdHlsZSwgYmFja3VwQmFja2dyb3VuZENvbG9yKVxuICAgICAgOiAvLyBvdGhlcndpc2UgbGVhdmUgaXQgYWxvbmUgYW5kIHJlbHkgb24gdGhlIHByZXZpb3VzIHN0YXRlJ3MgcHJlZXhpc3RpbmcgYmFja2dyb3VuZENvbG9yXG4gICAgICAgIC8vIG9yIERFRkFVTFRfQkFDS0dST1VORF9DT0xPUiBhcyBhIGxhc3QgcmVzb3J0XG4gICAgICAgIGJhY2t1cEJhY2tncm91bmRDb2xvcjtcblxuICByZXR1cm4gYmFja2dyb3VuZENvbG9yO1xufVxuXG5mdW5jdGlvbiBnZXRMYXllckdyb3Vwc0Zyb21TdHlsZShzdHlsZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdHlsZT8ubGF5ZXJzKVxuICAgID8gREVGQVVMVF9MQVlFUl9HUk9VUFMuZmlsdGVyKGxnID0+IHN0eWxlLmxheWVycy5maWx0ZXIobGcuZmlsdGVyKS5sZW5ndGgpXG4gICAgOiBbXTtcbn1cblxuLy8gVXBkYXRlcnNcblxuLyoqXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVxdWVzdE1hcFN0eWxlc1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHttYXBTdHlsZXMsIG9uU3VjY2Vzc319OiBNYXBTdHlsZUFjdGlvbnMuUmVxdWVzdE1hcFN0eWxlc1VwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+IHtcbiAgY29uc3QgdG9Mb2FkID0gT2JqZWN0LmtleXMobWFwU3R5bGVzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGlkKSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIC4uLighc3RhdGUuaXNMb2FkaW5nW2lkXSA/IHtbaWRdOiBtYXBTdHlsZXNbaWRdfSA6IHt9KVxuICAgIH0pLFxuICAgIHt9XG4gICk7XG4gIGNvbnN0IGxvYWRNYXBTdHlsZVRhc2tzID0gZ2V0TG9hZE1hcFN0eWxlVGFza3MoXG4gICAgdG9Mb2FkLFxuICAgIHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgIHN0YXRlLm1hcGJveEFwaVVybCxcbiAgICBvblN1Y2Nlc3NcbiAgKTtcblxuICBjb25zdCBpc0xvYWRpbmcgPSBPYmplY3Qua2V5cyh0b0xvYWQpLnJlZHVjZShcbiAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIFtrZXldOiB0cnVlXG4gICAgfSksXG4gICAge31cbiAgKTtcbiAgY29uc3QgbmV4dFN0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGlzTG9hZGluZ1xuICB9O1xuICByZXR1cm4gd2l0aFRhc2sobmV4dFN0YXRlLCBsb2FkTWFwU3R5bGVUYXNrcyk7XG59O1xuXG4vKipcbiAqIFByb3BhZ2F0ZSBgbWFwU3R5bGVgIHJlZHVjZXIgd2l0aCBgbWFwYm94QXBpQWNjZXNzVG9rZW5gIGFuZCBgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHRgLlxuICogaWYgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQgaXMgdHJ1ZSBtYXBTdHlsZXMgaXMgZW1wdGllZDsgbG9hZE1hcFN0eWxlc1VwZGF0ZXIoKSB3aWxsXG4gKiBwb3B1bGF0ZSBtYXBTdHlsZXMuXG4gKlxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRNYXBTdHlsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge1xuICAgIHBheWxvYWQgPSB7fVxuICB9OiB7XG4gICAgdHlwZT86IHR5cGVvZiBBY3Rpb25UeXBlcy5JTklUO1xuICAgIHBheWxvYWQ6IEtlcGxlckdsSW5pdFBheWxvYWQ7XG4gIH1cbik6IE1hcFN0eWxlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAvLyBzYXZlIG1hcGJveCBhY2Nlc3MgdG9rZW4gdG8gbWFwIHN0eWxlIHN0YXRlXG4gIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBwYXlsb2FkLm1hcGJveEFwaUFjY2Vzc1Rva2VuIHx8IHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICBtYXBib3hBcGlVcmw6IHBheWxvYWQubWFwYm94QXBpVXJsIHx8IHN0YXRlLm1hcGJveEFwaVVybCxcbiAgbWFwU3R5bGVzOiAhcGF5bG9hZC5tYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCA/IHN0YXRlLm1hcFN0eWxlcyA6IHt9LFxuICBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdDogcGF5bG9hZC5tYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCB8fCBmYWxzZVxufSk7XG4vLyB9KTtcblxuLyoqXG4gKiBVcGRhdGUgYHZpc2libGVMYXllckdyb3Vwc2B0byBjaGFuZ2UgbGF5ZXIgZ3JvdXAgdmlzaWJpbGl0eVxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcENvbmZpZ0NoYW5nZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAgYWN0aW9uOiBNYXBTdHlsZUFjdGlvbnMuTWFwQ29uZmlnQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogTWFwU3R5bGUgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIC4uLmFjdGlvbi5wYXlsb2FkLFxuICAgIC4uLmdldE1hcFN0eWxlcyh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLmFjdGlvbi5wYXlsb2FkXG4gICAgfSlcbiAgfTtcbn07XG5cbmNvbnN0IGhhc1N0eWxlT2JqZWN0ID0gc3R5bGUgPT4gaXNQbGFpbk9iamVjdChzdHlsZT8uc3R5bGUpO1xuXG4vKipcbiAqIENoYW5nZSB0byBhbm90aGVyIG1hcCBzdHlsZS4gVGhlIHNlbGVjdGVkIHN0eWxlIHNob3VsZCBhbHJlYWR5IGJlZW4gbG9hZGVkIGludG8gYG1hcFN0eWxlLm1hcFN0eWxlc2BcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHtzdHlsZVR5cGUsIG9uU3VjY2Vzc319OiBNYXBTdHlsZUFjdGlvbnMuTWFwU3R5bGVDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIGlmIChcbiAgICAvLyB3ZSBtaWdodCBub3QgaGF2ZSByZWNlaXZlZCB0aGUgc3R5bGUgeWV0XG4gICAgIXN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdIHx8XG4gICAgLy8gb3IgaWYgaXQgaXMgYSBtYW5hZ2VkIGN1c3RvbSBzdHlsZSBhc3NldFxuICAgIC8vIGFuZCBpZiBpdCBoYXMgbm90IGJlZW4gaHlkcmF0ZWQgd2l0aCBVUkwgaW5mbyB5ZXQgKGR1cmluZyBhcHAgZmlyc3QgaW5pdGlhbGl6YXRpb24pXG4gICAgLy8gYW5kIGl0IGRvZXMgbm90IGhhdmUgYSBzdHlsZSBvYmplY3QgKGR1cmluZyBhZGRpbmcgYSBjdXN0b20gc3R5bGUpXG4gICAgKHN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdPy5jdXN0b20gPT09ICdNQU5BR0VEJyAmJlxuICAgICAgIXN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdPy51cmwgJiZcbiAgICAgICFoYXNTdHlsZU9iamVjdChzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXSkpXG4gICkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGlmICghaGFzU3R5bGVPYmplY3Qoc3RhdGUubWFwU3R5bGVzW3N0eWxlVHlwZV0pKSB7XG4gICAgLy8gc3R5bGUgaGFzbid0IGxvYWRlZCB5ZXRcbiAgICByZXR1cm4gcmVxdWVzdE1hcFN0eWxlc1VwZGF0ZXIoXG4gICAgICB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBzdHlsZVR5cGVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBtYXBTdHlsZXM6IHtcbiAgICAgICAgICAgIFtzdHlsZVR5cGVdOiBzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25TdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgY29uc3QgZGVmYXVsdExHVmlzaWJpbGl0eSA9IGdldERlZmF1bHRMYXllckdyb3VwVmlzaWJpbGl0eShzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXSk7XG5cbiAgY29uc3QgdmlzaWJsZUxheWVyR3JvdXBzID0gbWVyZ2VMYXllckdyb3VwVmlzaWJpbGl0eShcbiAgICBkZWZhdWx0TEdWaXNpYmlsaXR5LFxuICAgIHN0YXRlLnZpc2libGVMYXllckdyb3Vwc1xuICApO1xuXG4gIGNvbnN0IHRocmVlREJ1aWxkaW5nQ29sb3I6IFJHQkNvbG9yID0gc3RhdGUuY3VzdG9tM0RCdWlsZGluZ0NvbG9yXG4gICAgPyBzdGF0ZS50aHJlZURCdWlsZGluZ0NvbG9yXG4gICAgOiBnZXQzREJ1aWxkaW5nQ29sb3Ioc3RhdGUubWFwU3R5bGVzW3N0eWxlVHlwZV0pO1xuXG4gIC8vIGRldGVybWluZSBuZXcgYmFja2dyb3VuZENvbG9yIGZyb20gZWl0aGVyIHByZXZpb3VzIHN0YXRlIGJhc2VtYXAgc3R5bGUsIHByZXZpb3VzIHN0YXRlIGJhY2tncm91bmRDb2xvciwgb3IgdGhlIERFRkFVTFRfQkFDS0dST1VORF9DT0xPUlxuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3Ioc3RhdGUsIHN0eWxlVHlwZSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBzdHlsZVR5cGUsXG4gICAgdmlzaWJsZUxheWVyR3JvdXBzLFxuICAgIHRocmVlREJ1aWxkaW5nQ29sb3IsXG4gICAgYmFja2dyb3VuZENvbG9yLFxuICAgIC4uLmdldE1hcFN0eWxlcyh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHZpc2libGVMYXllckdyb3VwcyxcbiAgICAgIHN0eWxlVHlwZVxuICAgIH0pXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHdoZW4gbG9hZCBtYXAgc3R5bGUgc3VjY2Vzc1xuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRNYXBTdHlsZXNVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIGFjdGlvbjogTWFwU3R5bGVBY3Rpb25zLkxvYWRNYXBTdHlsZXNVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IHtuZXdTdHlsZXMsIG9uU3VjY2Vzc30gPSBhY3Rpb24ucGF5bG9hZCB8fCB7fTtcblxuICBjb25zdCBhZGRMYXllckdyb3VwcyA9IE9iamVjdC5rZXlzKG5ld1N0eWxlcykucmVkdWNlKFxuICAgIChhY2N1LCBpZCkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICBbaWRdOiB7XG4gICAgICAgIC4uLm5ld1N0eWxlc1tpZF0sXG4gICAgICAgIGxheWVyR3JvdXBzOiBuZXdTdHlsZXNbaWRdLmxheWVyR3JvdXBzIHx8IGdldExheWVyR3JvdXBzRnJvbVN0eWxlKG5ld1N0eWxlc1tpZF0uc3R5bGUpXG4gICAgICB9XG4gICAgfSksXG4gICAge31cbiAgKTtcbiAgLy8gcmVzZXQgaXNMb2FkaW5nXG4gIGNvbnN0IGlzTG9hZGluZyA9IE9iamVjdC5rZXlzKHN0YXRlLmlzTG9hZGluZykucmVkdWNlKFxuICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgLi4uKHN0YXRlLmlzTG9hZGluZ1trZXldICYmIGhhc1N0eWxlT2JqZWN0KG5ld1N0eWxlc1trZXldKVxuICAgICAgICA/IHtba2V5XTogZmFsc2V9XG4gICAgICAgIDoge1trZXldOiBzdGF0ZS5pc0xvYWRpbmdba2V5XX0pXG4gICAgfSksXG4gICAge31cbiAgKTtcbiAgLy8gYWRkIG5ldyBzdHlsZXMgdG8gc3RhdGVcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgaXNMb2FkaW5nLFxuICAgIG1hcFN0eWxlczoge1xuICAgICAgLi4uc3RhdGUubWFwU3R5bGVzLFxuICAgICAgLi4uYWRkTGF5ZXJHcm91cHNcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdGFza3MgPSBjcmVhdGVBY3Rpb25UYXNrKG9uU3VjY2Vzcywge3N0eWxlVHlwZTogc3RhdGUuc3R5bGVUeXBlfSk7XG5cbiAgY29uc3QgbmV4dFN0YXRlID0gbmV3U3R5bGVzW3N0YXRlLnN0eWxlVHlwZV1cbiAgICA/IG1hcFN0eWxlQ2hhbmdlVXBkYXRlcihuZXdTdGF0ZSwge3BheWxvYWQ6IHtzdHlsZVR5cGU6IHN0YXRlLnN0eWxlVHlwZX19KVxuICAgIDogbmV3U3RhdGU7XG5cbiAgcmV0dXJuIHRhc2tzID8gd2l0aFRhc2sobmV4dFN0YXRlLCB0YXNrcykgOiBuZXh0U3RhdGU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25UYXNrKGFjdGlvbiwgcGF5bG9hZCkge1xuICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBQ1RJT05fVEFTSygpLm1hcCgoKSA9PiBhY3Rpb24ocGF5bG9hZCkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgd2hlbiBsb2FkIG1hcCBzdHlsZSBlcnJvclxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuLy8gZG8gbm90aGluZyBmb3Igbm93LCBpZiBkaWRuJ3QgbG9hZCwgc2tpcCBpdFxuZXhwb3J0IGNvbnN0IGxvYWRNYXBTdHlsZUVyclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHtpZHMsIGVycm9yfX06IE1hcFN0eWxlQWN0aW9ucy5Mb2FkTWFwU3R5bGVFcnJVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIENvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAvLyByZXNldCBpc0xvYWRpbmdcbiAgY29uc3QgaXNMb2FkaW5nID0gT2JqZWN0LmtleXMoc3RhdGUuaXNMb2FkaW5nKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGtleSkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICAuLi4oc3RhdGUuaXNMb2FkaW5nW2tleV0gJiYgKGlkcyB8fCBbXSkuaW5jbHVkZXMoa2V5KVxuICAgICAgICA/IHtba2V5XTogZmFsc2V9XG4gICAgICAgIDoge1trZXldOiBzdGF0ZS5pc0xvYWRpbmdba2V5XX0pXG4gICAgfSksXG4gICAge31cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGlzTG9hZGluZ1xuICB9O1xufTtcblxuLyoqXG4gKiBMb2FkIG1hcCBzdHlsZSBvYmplY3Qgd2hlbiBwYXNzIGluIHNhdmVkIG1hcCBjb25maWdcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGUgYG1hcFN0eWxlYFxuICogQHBhcmFtIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkIHNhdmVkIG1hcCBjb25maWcgYHttYXBTdHlsZSwgdmlzU3RhdGUsIG1hcFN0YXRlfWBcbiAqIEByZXR1cm5zIG5leHRTdGF0ZSBvciBgcmVhY3QtcGFtYCB0YXNrcyB0byBsb2FkIG1hcCBzdHlsZSBvYmplY3RcbiAqL1xuZXhwb3J0IGNvbnN0IHJlY2VpdmVNYXBDb25maWdVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIHtcbiAgICBwYXlsb2FkOiB7Y29uZmlnfVxuICB9OiB7XG4gICAgdHlwZT86IHR5cGVvZiBBY3Rpb25UeXBlcy5SRUNFSVZFX01BUF9DT05GSUc7XG4gICAgcGF5bG9hZDogUmVjZWl2ZU1hcENvbmZpZ1BheWxvYWQ7XG4gIH1cbik6IE1hcFN0eWxlID0+IHtcbiAgY29uc3Qge21hcFN0eWxlfSA9IGNvbmZpZyB8fCB7fTtcblxuICBpZiAoIW1hcFN0eWxlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLy8gbWVyZ2UgZGVmYXVsdCBtYXBTdHlsZXNcbiAgY29uc3QgbWVyZ2VkID0gbWFwU3R5bGUubWFwU3R5bGVzXG4gICAgPyB7XG4gICAgICAgIC4uLm1hcFN0eWxlLFxuICAgICAgICBtYXBTdHlsZXM6IHtcbiAgICAgICAgICAuLi5tYXBTdHlsZS5tYXBTdHlsZXMsXG4gICAgICAgICAgLi4uc3RhdGUubWFwU3R5bGVzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICA6IG1hcFN0eWxlO1xuXG4gIC8vIHNldCBjdXN0b20zREJ1aWxkaW5nQ29sb3I6IHRydWUgaWYgbWFwU3R5bGUgY29udGFpbnMgdGhyZWVEQnVpbGRpbmdDb2xvclxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIG1lcmdlZC5jdXN0b20zREJ1aWxkaW5nQ29sb3IgPVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBCb29sZWFuKG1hcFN0eWxlLnRocmVlREJ1aWxkaW5nQ29sb3IpIHx8IG1lcmdlZC5jdXN0b20zREJ1aWxkaW5nQ29sb3I7XG4gIGNvbnN0IG5ld1N0YXRlID0gbWFwQ29uZmlnQ2hhbmdlVXBkYXRlcihzdGF0ZSwge3BheWxvYWQ6IG1lcmdlZH0pO1xuXG4gIHJldHVybiBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIobmV3U3RhdGUsIHtwYXlsb2FkOiB7c3R5bGVUeXBlOiBuZXdTdGF0ZS5zdHlsZVR5cGV9fSk7XG59O1xuXG5mdW5jdGlvbiBnZXRMb2FkTWFwU3R5bGVUYXNrcyhtYXBTdHlsZXMsIG1hcGJveEFwaUFjY2Vzc1Rva2VuLCBtYXBib3hBcGlVcmwsIG9uU3VjY2Vzcykge1xuICByZXR1cm4gW1xuICAgIFRhc2suYWxsKFxuICAgICAgT2JqZWN0LnZhbHVlcyhtYXBTdHlsZXMpXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgLm1hcCgoe2lkLCB1cmwsIGFjY2Vzc1Rva2VufSkgPT4gKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB1cmw6IGdldFN0eWxlRG93bmxvYWRVcmwodXJsLCBhY2Nlc3NUb2tlbiB8fCBtYXBib3hBcGlBY2Nlc3NUb2tlbiwgbWFwYm94QXBpVXJsKVxuICAgICAgICB9KSlcbiAgICAgICAgLm1hcChMT0FEX01BUF9TVFlMRV9UQVNLKVxuICAgICkuYmltYXAoXG4gICAgICAvLyBzdWNjZXNzXG4gICAgICByZXN1bHRzID0+XG4gICAgICAgIGxvYWRNYXBTdHlsZXMoXG4gICAgICAgICAgcmVzdWx0cy5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjdSwge2lkLCBzdHlsZX0pID0+ICh7XG4gICAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICAgIFtpZF06IHtcbiAgICAgICAgICAgICAgICAuLi5tYXBTdHlsZXNbaWRdLFxuICAgICAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAge31cbiAgICAgICAgICApLFxuICAgICAgICAgIG9uU3VjY2Vzc1xuICAgICAgICApLFxuICAgICAgLy8gZXJyb3JcbiAgICAgIGVyciA9PiBsb2FkTWFwU3R5bGVFcnIoT2JqZWN0LmtleXMobWFwU3R5bGVzKSwgZXJyKVxuICAgIClcbiAgXTtcbn1cbi8qKlxuICogUmVzZXQgbWFwIHN0eWxlIGNvbmZpZyB0byBpbml0aWFsIHN0YXRlXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGBtYXBTdHlsZWBcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVzZXRNYXBDb25maWdNYXBTdHlsZVVwZGF0ZXIgPSAoc3RhdGU6IE1hcFN0eWxlKTogTWFwU3R5bGUgPT4ge1xuICBjb25zdCBlbXB0eUNvbmZpZyA9IHtcbiAgICAuLi5JTklUSUFMX01BUF9TVFlMRSxcbiAgICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogc3RhdGUubWFwYm94QXBpQWNjZXNzVG9rZW4sXG4gICAgbWFwYm94QXBpVXJsOiBzdGF0ZS5tYXBib3hBcGlVcmwsXG4gICAgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQ6IHN0YXRlLm1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0LFxuICAgIC4uLnN0YXRlLmluaXRpYWxTdGF0ZSxcbiAgICBtYXBTdHlsZXM6IHN0YXRlLm1hcFN0eWxlcyxcbiAgICBpbml0aWFsU3RhdGU6IHN0YXRlLmluaXRpYWxTdGF0ZVxuICB9O1xuXG4gIHJldHVybiBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIoZW1wdHlDb25maWcsIHtwYXlsb2FkOiB7c3R5bGVUeXBlOiBlbXB0eUNvbmZpZy5zdHlsZVR5cGV9fSk7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHdoZW4gYSBjdXN0b20gbWFwIHN0eWxlIG9iamVjdCBpcyByZWNlaXZlZFxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHtpY29uLCBzdHlsZSwgZXJyb3J9fTogTWFwU3R5bGVBY3Rpb25zLkxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGlucHV0U3R5bGU6IHtcbiAgICAuLi5zdGF0ZS5pbnB1dFN0eWxlLFxuICAgIC8vIHN0eWxlIGpzb24gYW5kIGljb24gd2lsbCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgLi4uKHN0eWxlXG4gICAgICA/IHtcbiAgICAgICAgICBpZDpcbiAgICAgICAgICAgIHN0YXRlLmlucHV0U3R5bGUuY3VzdG9tID09PSAnTUFOQUdFRCdcbiAgICAgICAgICAgICAgPyBzdGF0ZS5pbnB1dFN0eWxlLmlkIC8vIGN1c3RvbSBNQU5BR0VEIHR5cGVcbiAgICAgICAgICAgICAgOiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgc3R5bGUuaWQgfHwgZ2VuZXJhdGVIYXNoSWQoKSwgLy8gY3VzdG9tIExPQ0FMIHR5cGVcbiAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICAgICAgc3R5bGU6IGNsb25lRGVlcChzdHlsZSksXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGxhYmVsOiBzdGF0ZS5pbnB1dFN0eWxlLmxhYmVsIHx8IHN0eWxlLm5hbWUsXG4gICAgICAgICAgLy8gZ2F0aGVyaW5nIGxheWVyIGdyb3VwIGluZm8gZnJvbSBzdHlsZSBqc29uXG4gICAgICAgICAgbGF5ZXJHcm91cHM6IGdldExheWVyR3JvdXBzRnJvbVN0eWxlKHN0eWxlKVxuICAgICAgICB9XG4gICAgICA6IHt9KSxcbiAgICAuLi4oaWNvbiA/IHtpY29ufSA6IHt9KSxcbiAgICAuLi4oZXJyb3IgIT09IHVuZGVmaW5lZCA/IHtlcnJvcn0gOiB7fSlcbiAgfVxufSk7XG5cbi8qKlxuICogSW5wdXQgYSBjdXN0b20gbWFwIHN0eWxlIG9iamVjdFxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGlucHV0TWFwU3R5bGVVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIHtwYXlsb2FkOiB7aW5wdXRTdHlsZSwgbWFwU3RhdGV9fTogTWFwU3R5bGVBY3Rpb25zLklucHV0TWFwU3R5bGVVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgLi4uc3RhdGUuaW5wdXRTdHlsZSxcbiAgICAuLi5pbnB1dFN0eWxlXG4gIH07XG5cbiAgLy8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGVpdGhlciBhIHVybCB0byBob3N0ZWQgc3R5bGUganNvbiB0aGF0IG5lZWRzIGFuIGljb24gdXJsLFxuICAvLyBvciBhbiBpY29uIGFscmVhZHkgYXZhaWxhYmxlIGNsaWVudC1zaWRlIGFzIGEgZGF0YSB1cmlcbiAgY29uc3QgaXNVcGRhdGVkSWNvbkRhdGFVcmkgPSB1cGRhdGVkLmljb24/LnN0YXJ0c1dpdGgoJ2RhdGE6aW1hZ2UnKTtcbiAgY29uc3QgaXNNYXBib3hTdHlsZVVybCA9XG4gICAgdXBkYXRlZC51cmw/LnN0YXJ0c1dpdGgoJ21hcGJveDovLycpIHx8IHVwZGF0ZWQudXJsPy5pbmNsdWRlcygnbWFwYm94LmNvbScpO1xuXG4gIGNvbnN0IGljb24gPVxuICAgICFpc1VwZGF0ZWRJY29uRGF0YVVyaSAmJiBpc01hcGJveFN0eWxlVXJsXG4gICAgICA/IC8vIEdldCBpbWFnZSBpY29uIHVybHMgb25seSBmb3IgbWFwYm94IG1hcCBsaWIuXG4gICAgICAgIGdldFN0eWxlSW1hZ2VJY29uKHtcbiAgICAgICAgICBtYXBTdGF0ZSxcbiAgICAgICAgICBzdHlsZVVybDogdXBkYXRlZC51cmwgfHwgJycsXG4gICAgICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IHVwZGF0ZWQuYWNjZXNzVG9rZW4gfHwgc3RhdGUubWFwYm94QXBpQWNjZXNzVG9rZW4gfHwgJycsXG4gICAgICAgICAgbWFwYm94QXBpVXJsOiBzdGF0ZS5tYXBib3hBcGlVcmwgfHwgREVGQVVMVF9NQVBCT1hfQVBJX1VSTFxuICAgICAgICB9KVxuICAgICAgOiB1cGRhdGVkLmljb247XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBpbnB1dFN0eWxlOiB7XG4gICAgICAuLi51cGRhdGVkLFxuICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgIGljb25cbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEFkZCBtYXAgc3R5bGUgZnJvbSB1c2VyIGlucHV0IHRvIHJlZHVjZXIgYW5kIHNldCBpdCB0byBjdXJyZW50IHN0eWxlXG4gKiBUaGlzIGFjdGlvbiBpcyBjYWxsZWQgd2hlbiB1c2VyIGNsaWNrIGNvbmZpcm0gYWZ0ZXIgcHV0dGluZyBpbiBhIHZhbGlkIHN0eWxlIHVybCBpbiB0aGUgY3VzdG9tIG1hcCBzdHlsZSBkaWFsb2cuXG4gKiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBmcm9tIG91dHNpZGUga2VwbGVyLmdsIHdpdGhvdXQgYSB2YWxpZCBgaW5wdXRTdHlsZWAgaW4gdGhlIGBtYXBTdHlsZWAgcmVkdWNlci5cbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRDdXN0b21NYXBTdHlsZVVwZGF0ZXIgPSAoc3RhdGU6IE1hcFN0eWxlKTogTWFwU3R5bGUgPT4ge1xuICBjb25zdCBzdHlsZUlkID0gc3RhdGUuaW5wdXRTdHlsZS5pZDtcbiAgaWYgKCFzdHlsZUlkKSByZXR1cm4gc3RhdGU7XG5cbiAgY29uc3QgbmV3U3RhdGUgPSBnZXROZXdTdGF0ZVdpdGhDdXN0b21NYXBTdHlsZShzdGF0ZSk7XG4gIC8vIHNldCBuZXcgc3R5bGVcbiAgcmV0dXJuIG1hcFN0eWxlQ2hhbmdlVXBkYXRlcihuZXdTdGF0ZSwge3BheWxvYWQ6IHtzdHlsZVR5cGU6IHN0eWxlSWR9fSk7XG59O1xuXG4vKipcbiAqIEVkaXQgbWFwIHN0eWxlIGZyb20gdXNlciBpbnB1dCB0byByZWR1Y2VyLlxuICogVGhpcyBhY3Rpb24gaXMgY2FsbGVkIHdoZW4gdXNlciBjbGlja3MgY29uZmlybSBhZnRlciBlZGl0aW5nIGFuIGV4aXN0aW5nIGN1c3RvbSBzdHlsZSBpbiB0aGUgY3VzdG9tIG1hcCBzdHlsZSBkaWFsb2cuXG4gKiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBmcm9tIG91dHNpZGUga2VwbGVyLmdsIHdpdGhvdXQgYSB2YWxpZCBgaW5wdXRTdHlsZWAgaW4gdGhlIGBtYXBTdHlsZWAgcmVkdWNlci5cbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBlZGl0Q3VzdG9tTWFwU3R5bGVVcGRhdGVyID0gKHN0YXRlOiBNYXBTdHlsZSk6IE1hcFN0eWxlID0+IHtcbiAgcmV0dXJuIGdldE5ld1N0YXRlV2l0aEN1c3RvbU1hcFN0eWxlKHN0YXRlKTtcbn07XG5cbmZ1bmN0aW9uIGdldE5ld1N0YXRlV2l0aEN1c3RvbU1hcFN0eWxlKHN0YXRlOiBNYXBTdHlsZSk6IE1hcFN0eWxlIHtcbiAgY29uc3Qgc3R5bGVJZCA9IHN0YXRlLmlucHV0U3R5bGUuaWQ7XG4gIGlmICghc3R5bGVJZCkgcmV0dXJuIHN0YXRlO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQcm9wZXJ0eSAnbGF5ZXJHcm91cHMnIGlzIG1pc3NpbmcgaW4gdHlwZSAnSW5wdXRTdHlsZScgYnV0IHJlcXVpcmVkIGluIHR5cGUgJ0Jhc2VNYXBTdHlsZScuIExlZ2FjeSBjYXNlP1xuICAgIG1hcFN0eWxlczoge1xuICAgICAgLi4uc3RhdGUubWFwU3R5bGVzLFxuICAgICAgW3N0eWxlSWRdOiB7XG4gICAgICAgIC4uLnN0YXRlLm1hcFN0eWxlc1tzdHlsZUlkXSwgLy8gZG8gbm90IHVuaW50ZW50aW9uYWxseSBkcm9wIGFueSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgICAgLi4uc3RhdGUuaW5wdXRTdHlsZVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gc2V0IHRvIGRlZmF1bHRcbiAgICBpbnB1dFN0eWxlOiBnZXRJbml0aWFsSW5wdXRTdHlsZSgpXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY3VzdG9tIG1hcCBzdHlsZSBmcm9tIGBzdGF0ZS5tYXBTdHlsZS5tYXBTdHlsZXNgLlxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUN1c3RvbU1hcFN0eWxlVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0eWxlLFxuICBhY3Rpb246IE1hcFN0eWxlQWN0aW9ucy5SZW1vdmVDdXN0b21NYXBTdHlsZVVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+IHtcbiAgY29uc3Qge2lkfSA9IGFjdGlvbi5wYXlsb2FkO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3Qge1tpZF06IF8sIC4uLnJlc3RPZk1hcFN0eWxlc30gPSBzdGF0ZS5tYXBTdHlsZXM7XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgbWFwU3R5bGVzOiByZXN0T2ZNYXBTdHlsZXNcbiAgfTtcblxuICBpZiAoc3RhdGUuc3R5bGVUeXBlID09PSBpZCkge1xuICAgIC8vIGlmIHJlbW92aW5nIGEgY3VzdG9tIHN0eWxlIHRoYXQgaXMgYWxzbyB0aGUgY3VycmVudCBhY3RpdmUgYmFzZSBtYXAsXG4gICAgLy8gdGhlbiByZXNldCB0byB0aGUgZGVmYXVsdCBhY3RpdmUgYmFzZSBtYXAgKGBtYXBTdHlsZS5zdHlsZVR5cGVgKVxuICAgIHJldHVybiBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIobmV3U3RhdGUsIHtwYXlsb2FkOiB7c3R5bGVUeXBlOiBnZXREZWZhdWx0U3RhdGUoKS5zdHlsZVR5cGV9fSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgM2QgYnVpbGRpbmcgY29sb3JcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBzZXQzZEJ1aWxkaW5nQ29sb3JVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIHtwYXlsb2FkOiBjb2xvcn06IE1hcFN0eWxlQWN0aW9ucy5TZXQzZEJ1aWxkaW5nQ29sb3JVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgdGhyZWVEQnVpbGRpbmdDb2xvcjogY29sb3IsXG4gIGN1c3RvbTNEQnVpbGRpbmdDb2xvcjogdHJ1ZVxufSk7XG5cbi8qKlxuICogVXBkYXRlcyBiYWNrZ3JvdW5kIGNvbG9yXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICovXG5leHBvcnQgY29uc3Qgc2V0QmFja2dyb3VuZENvbG9yVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0eWxlLFxuICB7cGF5bG9hZDogY29sb3J9OiBNYXBTdHlsZUFjdGlvbnMuU2V0QmFja2dyb3VuZENvbG9yVXBkYXRlckFjdGlvblxuKTogTWFwU3R5bGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGJhY2tncm91bmRDb2xvcjogY29sb3Jcbn0pO1xuXG4vKipcbiAqIFJldHVybiB0aGUgaW5pdGlhbCBpbnB1dCBzdHlsZVxuICogQHJldHVybiBPYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluaXRpYWxJbnB1dFN0eWxlKCk6IElucHV0U3R5bGUge1xuICByZXR1cm4ge1xuICAgIGlkOiBudWxsLFxuICAgIGFjY2Vzc1Rva2VuOiBudWxsLFxuICAgIGVycm9yOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICBsYWJlbDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICB1cmw6IG51bGwsXG4gICAgaWNvbjogbnVsbCxcbiAgICBjdXN0b206ICdMT0NBTCcsXG4gICAgdXBsb2FkZWRGaWxlOiBudWxsXG4gIH07XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFHQSxJQUFBQSxNQUFBLEdBQUFDLHVCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxVQUFBLEdBQUFDLHNCQUFBLENBQUFGLE9BQUE7QUFDQSxJQUFBRyxRQUFBLEdBQUFELHNCQUFBLENBQUFGLE9BQUE7QUFHQSxJQUFBSSxNQUFBLEdBQUFKLE9BQUE7QUFZQSxJQUFBSyxZQUFBLEdBQUFMLE9BQUE7QUFDQSxJQUFBTSxVQUFBLEdBQUFOLE9BQUE7QUFVQSxJQUFBTyxPQUFBLEdBQUFQLE9BQUE7QUFDQSxJQUFBUSxRQUFBLEdBQUFSLE9BQUE7QUFVQSxJQUFBUyxRQUFBLEdBQUFULE9BQUE7QUFPNEIsU0FBQVUseUJBQUFDLENBQUEsNkJBQUFDLE9BQUEsbUJBQUFDLENBQUEsT0FBQUQsT0FBQSxJQUFBRSxDQUFBLE9BQUFGLE9BQUEsWUFBQUYsd0JBQUEsWUFBQUEseUJBQUFDLENBQUEsV0FBQUEsQ0FBQSxHQUFBRyxDQUFBLEdBQUFELENBQUEsS0FBQUYsQ0FBQTtBQUFBLFNBQUFaLHdCQUFBWSxDQUFBLEVBQUFFLENBQUEsU0FBQUEsQ0FBQSxJQUFBRixDQUFBLElBQUFBLENBQUEsQ0FBQUksVUFBQSxTQUFBSixDQUFBLGVBQUFBLENBQUEsZ0JBQUFLLE9BQUEsQ0FBQUwsQ0FBQSwwQkFBQUEsQ0FBQSxzQkFBQUEsQ0FBQSxRQUFBRyxDQUFBLEdBQUFKLHdCQUFBLENBQUFHLENBQUEs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