"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQueryTool = getQueryTool;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _react = _interopRequireDefault(require("react"));
var _duckdb = require("@openassistant/duckdb");
var _tables = require("@openassistant/tables");
var _utils = require("@openassistant/utils");
var _utils2 = require("./utils");
var _tableTool = require("./kepler-tools/table-tool");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
function getQueryTool(datasets, layers) {
  var toolCache = _utils.ToolCache.getInstance();

  // context for query tools
  var getValues = /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(datasetName, variableName) {
      var values;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            values = (0, _utils2.getValuesFromDataset)(datasets, layers, datasetName, variableName);
            return _context.abrupt("return", values);
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getValues(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();

  // customize some query tools from localQuery tool
  function QueryToolComponent(props) {
    return /*#__PURE__*/_react["default"].createElement(_tables.QueryDuckDBComponent, (0, _extends2["default"])({}, props, {
      getValues: getValues,
      getDuckDB: _duckdb.getDuckDB
    }));
  }

  // this tool will execute a generic select SQL query against user's dataset
  var genericQuery = _objectSpread(_objectSpread({}, _duckdb.localQuery), {}, {
    description: "execute a generic select SQL query in duckdb to answer user's question. Please note:\n1. This tool is NOT for filtering the user dataset.\n2. This tool does NOT support geometry column and geometric operations.\n3. The variableNames should not be empty. If it is not provided, then pick a variable name from the dataset.\n4. There is no need to add a sub-query to add an auto-increment column 'row_index' to the original dataset.\n",
    context: _objectSpread(_objectSpread({}, _duckdb.localQuery.context), {}, {
      getValues: getValues
    }),
    component: QueryToolComponent
  });

  // customize a filterDataset tool from localQuery tool
  // this tool will use the selected rows (row indexes) to filter the user dataset and save the result as a new dataset.
  var filterDataset = _objectSpread(_objectSpread({}, _duckdb.localQuery), {}, {
    description: "filter the user dataset by using a select SQL query in duckdb and save the result as a new dataset.\nPlease note:\n1. Do not use * to select all columns, instead use all the column names in dataset.\n",
    context: _objectSpread(_objectSpread({}, _duckdb.localQuery.context), {}, {
      getValues: getValues
    }),
    component: _tableTool.TableToolComponent
  });

  // customize a table tool from localQuery tool to create a new table/dataset in kepler.gl using SQL query
  var tableTool = _objectSpread(_objectSpread({}, _duckdb.localQuery), {}, {
    description: "Create a new table/dataset in kepler.gl using SQL query which will\n1. add a new column to the original dataset\n2. delete a column from the original dataset\n3. rename a column in the original dataset\n4. change the column type in the original dataset.\nPlease note:\n1. Do not use * to select all columns, instead use all the column names in dataset.\n2. List all column names the new table or dataset will have.\n",
    context: _objectSpread(_objectSpread({}, _duckdb.localQuery.context), {}, {
      getValues: getValues
    }),
    component: _tableTool.TableToolComponent
  });

  // customize a mergeTables tool from localQuery tool to merge two datasets into a new dataset
  var mergeTablesTool = _objectSpread(_objectSpread({}, _duckdb.mergeTables), {}, {
    context: {
      getValues: getValues
    },
    onToolCompleted: function onToolCompleted(toolName, additionalData) {
      toolCache.addDataset(toolName, additionalData);
    }
    // component: MergeTablesToolComponent
  });
  return {
    filterDataset: filterDataset,
    genericQuery: genericQuery,
    tableTool: tableTool,
    mergeTablesTool: mergeTablesTool
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9kdWNrZGIiLCJfdGFibGVzIiwiX3V0aWxzIiwiX3V0aWxzMiIsIl90YWJsZVRvb2wiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm8iLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsImdldFF1ZXJ5VG9vbCIsImRhdGFzZXRzIiwibGF5ZXJzIiwidG9vbENhY2hlIiwiVG9vbENhY2hlIiwiZ2V0SW5zdGFuY2UiLCJnZXRWYWx1ZXMiLCJfcmVmIiwiX2FzeW5jVG9HZW5lcmF0b3IyIiwiX3JlZ2VuZXJhdG9yIiwibWFyayIsIl9jYWxsZWUiLCJkYXRhc2V0TmFtZSIsInZhcmlhYmxlTmFtZSIsInZhbHVlcyIsIndyYXAiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwicHJldiIsIm5leHQiLCJnZXRWYWx1ZXNGcm9tRGF0YXNldCIsImFicnVwdCIsInN0b3AiLCJfeCIsIl94MiIsIlF1ZXJ5VG9vbENvbXBvbmVudCIsInByb3BzIiwiY3JlYXRlRWxlbWVudCIsIlF1ZXJ5RHVja0RCQ29tcG9uZW50IiwiX2V4dGVuZHMyIiwiZ2V0RHVja0RCIiwiZ2VuZXJpY1F1ZXJ5IiwibG9jYWxRdWVyeSIsImRlc2NyaXB0aW9uIiwiY29udGV4dCIsImNvbXBvbmVudCIsImZpbHRlckRhdGFzZXQiLCJUYWJsZVRvb2xDb21wb25lbnQiLCJ0YWJsZVRvb2wiLCJtZXJnZVRhYmxlc1Rvb2wiLCJtZXJnZVRhYmxlcyIsIm9uVG9vbENvbXBsZXRlZCIsInRvb2xOYW1lIiwiYWRkaXRpb25hbERhdGEiLCJhZGREYXRhc2V0Il0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Rvb2xzL3F1ZXJ5LXRvb2wudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge0RhdGFzZXRzfSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJ0BrZXBsZXIuZ2wvbGF5ZXJzJztcbmltcG9ydCB7XG4gIGdldER1Y2tEQixcbiAgbG9jYWxRdWVyeSxcbiAgTG9jYWxRdWVyeVRvb2wsXG4gIG1lcmdlVGFibGVzLFxuICBNZXJnZVRhYmxlc1Rvb2xcbn0gZnJvbSAnQG9wZW5hc3Npc3RhbnQvZHVja2RiJztcbmltcG9ydCB7UXVlcnlEdWNrREJDb21wb25lbnQsIFF1ZXJ5RHVja0RCT3V0cHV0RGF0YX0gZnJvbSAnQG9wZW5hc3Npc3RhbnQvdGFibGVzJztcbmltcG9ydCB7VG9vbENhY2hlfSBmcm9tICdAb3BlbmFzc2lzdGFudC91dGlscyc7XG5cbmltcG9ydCB7Z2V0VmFsdWVzRnJvbURhdGFzZXR9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtUYWJsZVRvb2xDb21wb25lbnR9IGZyb20gJy4va2VwbGVyLXRvb2xzL3RhYmxlLXRvb2wnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVlcnlUb29sKGRhdGFzZXRzOiBEYXRhc2V0cywgbGF5ZXJzOiBMYXllcltdKSB7XG4gIGNvbnN0IHRvb2xDYWNoZSA9IFRvb2xDYWNoZS5nZXRJbnN0YW5jZSgpO1xuXG4gIC8vIGNvbnRleHQgZm9yIHF1ZXJ5IHRvb2xzXG4gIGNvbnN0IGdldFZhbHVlcyA9IGFzeW5jIChkYXRhc2V0TmFtZTogc3RyaW5nLCB2YXJpYWJsZU5hbWU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IGdldFZhbHVlc0Zyb21EYXRhc2V0KGRhdGFzZXRzLCBsYXllcnMsIGRhdGFzZXROYW1lLCB2YXJpYWJsZU5hbWUpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gY3VzdG9taXplIHNvbWUgcXVlcnkgdG9vbHMgZnJvbSBsb2NhbFF1ZXJ5IHRvb2xcbiAgZnVuY3Rpb24gUXVlcnlUb29sQ29tcG9uZW50KHByb3BzOiBRdWVyeUR1Y2tEQk91dHB1dERhdGEpIHtcbiAgICByZXR1cm4gPFF1ZXJ5RHVja0RCQ29tcG9uZW50IHsuLi5wcm9wc30gZ2V0VmFsdWVzPXtnZXRWYWx1ZXN9IGdldER1Y2tEQj17Z2V0RHVja0RCfSAvPjtcbiAgfVxuXG4gIC8vIHRoaXMgdG9vbCB3aWxsIGV4ZWN1dGUgYSBnZW5lcmljIHNlbGVjdCBTUUwgcXVlcnkgYWdhaW5zdCB1c2VyJ3MgZGF0YXNldFxuICBjb25zdCBnZW5lcmljUXVlcnk6IExvY2FsUXVlcnlUb29sID0ge1xuICAgIC4uLmxvY2FsUXVlcnksXG4gICAgZGVzY3JpcHRpb246IGBleGVjdXRlIGEgZ2VuZXJpYyBzZWxlY3QgU1FMIHF1ZXJ5IGluIGR1Y2tkYiB0byBhbnN3ZXIgdXNlcidzIHF1ZXN0aW9uLiBQbGVhc2Ugbm90ZTpcbjEuIFRoaXMgdG9vbCBpcyBOT1QgZm9yIGZpbHRlcmluZyB0aGUgdXNlciBkYXRhc2V0LlxuMi4gVGhpcyB0b29sIGRvZXMgTk9UIHN1cHBvcnQgZ2VvbWV0cnkgY29sdW1uIGFuZCBnZW9tZXRyaWMgb3BlcmF0aW9ucy5cbjMuIFRoZSB2YXJpYWJsZU5hbWVzIHNob3VsZCBub3QgYmUgZW1wdHkuIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgdGhlbiBwaWNrIGEgdmFyaWFibGUgbmFtZSBmcm9tIHRoZSBkYXRhc2V0LlxuNC4gVGhlcmUgaXMgbm8gbmVlZCB0byBhZGQgYSBzdWItcXVlcnkgdG8gYWRkIGFuIGF1dG8taW5jcmVtZW50IGNvbHVtbiAncm93X2luZGV4JyB0byB0aGUgb3JpZ2luYWwgZGF0YXNldC5cbmAsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4ubG9jYWxRdWVyeS5jb250ZXh0LFxuICAgICAgZ2V0VmFsdWVzXG4gICAgfSxcbiAgICBjb21wb25lbnQ6IFF1ZXJ5VG9vbENvbXBvbmVudFxuICB9O1xuXG4gIC8vIGN1c3RvbWl6ZSBhIGZpbHRlckRhdGFzZXQgdG9vbCBmcm9tIGxvY2FsUXVlcnkgdG9vbFxuICAvLyB0aGlzIHRvb2wgd2lsbCB1c2UgdGhlIHNlbGVjdGVkIHJvd3MgKHJvdyBpbmRleGVzKSB0byBmaWx0ZXIgdGhlIHVzZXIgZGF0YXNldCBhbmQgc2F2ZSB0aGUgcmVzdWx0IGFzIGEgbmV3IGRhdGFzZXQuXG4gIGNvbnN0IGZpbHRlckRhdGFzZXQ6IExvY2FsUXVlcnlUb29sID0ge1xuICAgIC4uLmxvY2FsUXVlcnksXG4gICAgZGVzY3JpcHRpb246IGBmaWx0ZXIgdGhlIHVzZXIgZGF0YXNldCBieSB1c2luZyBhIHNlbGVjdCBTUUwgcXVlcnkgaW4gZHVja2RiIGFuZCBzYXZlIHRoZSByZXN1bHQgYXMgYSBuZXcgZGF0YXNldC5cblBsZWFzZSBub3RlOlxuMS4gRG8gbm90IHVzZSAqIHRvIHNlbGVjdCBhbGwgY29sdW1ucywgaW5zdGVhZCB1c2UgYWxsIHRoZSBjb2x1bW4gbmFtZXMgaW4gZGF0YXNldC5cbmAsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4ubG9jYWxRdWVyeS5jb250ZXh0LFxuICAgICAgZ2V0VmFsdWVzXG4gICAgfSxcbiAgICBjb21wb25lbnQ6IFRhYmxlVG9vbENvbXBvbmVudFxuICB9O1xuXG4gIC8vIGN1c3RvbWl6ZSBhIHRhYmxlIHRvb2wgZnJvbSBsb2NhbFF1ZXJ5IHRvb2wgdG8gY3JlYXRlIGEgbmV3IHRhYmxlL2RhdGFzZXQgaW4ga2VwbGVyLmdsIHVzaW5nIFNRTCBxdWVyeVxuICBjb25zdCB0YWJsZVRvb2w6IExvY2FsUXVlcnlUb29sID0ge1xuICAgIC4uLmxvY2FsUXVlcnksXG4gICAgZGVzY3JpcHRpb246IGBDcmVhdGUgYSBuZXcgdGFibGUvZGF0YXNldCBpbiBrZXBsZXIuZ2wgdXNpbmcgU1FMIHF1ZXJ5IHdoaWNoIHdpbGxcbjEuIGFkZCBhIG5ldyBjb2x1bW4gdG8gdGhlIG9yaWdpbmFsIGRhdGFzZXRcbjIuIGRlbGV0ZSBhIGNvbHVtbiBmcm9tIHRoZSBvcmlnaW5hbCBkYXRhc2V0XG4zLiByZW5hbWUgYSBjb2x1bW4gaW4gdGhlIG9yaWdpbmFsIGRhdGFzZXRcbjQuIGNoYW5nZSB0aGUgY29sdW1uIHR5cGUgaW4gdGhlIG9yaWdpbmFsIGRhdGFzZXQuXG5QbGVhc2Ugbm90ZTpcbjEuIERvIG5vdCB1c2UgKiB0byBzZWxlY3QgYWxsIGNvbHVtbnMsIGluc3RlYWQgdXNlIGFsbCB0aGUgY29sdW1uIG5hbWVzIGluIGRhdGFzZXQuXG4yLiBMaXN0IGFsbCBjb2x1bW4gbmFtZXMgdGhlIG5ldyB0YWJsZSBvciBkYXRhc2V0IHdpbGwgaGF2ZS5cbmAsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4ubG9jYWxRdWVyeS5jb250ZXh0LFxuICAgICAgZ2V0VmFsdWVzXG4gICAgfSxcbiAgICBjb21wb25lbnQ6IFRhYmxlVG9vbENvbXBvbmVudFxuICB9O1xuXG4gIC8vIGN1c3RvbWl6ZSBhIG1lcmdlVGFibGVzIHRvb2wgZnJvbSBsb2NhbFF1ZXJ5IHRvb2wgdG8gbWVyZ2UgdHdvIGRhdGFzZXRzIGludG8gYSBuZXcgZGF0YXNldFxuICBjb25zdCBtZXJnZVRhYmxlc1Rvb2w6IE1lcmdlVGFibGVzVG9vbCA9IHtcbiAgICAuLi5tZXJnZVRhYmxlcyxcbiAgICBjb250ZXh0OiB7XG4gICAgICBnZXRWYWx1ZXNcbiAgICB9LFxuICAgIG9uVG9vbENvbXBsZXRlZDogKHRvb2xOYW1lOiBzdHJpbmcsIGFkZGl0aW9uYWxEYXRhOiB1bmtub3duKSA9PiB7XG4gICAgICB0b29sQ2FjaGUuYWRkRGF0YXNldCh0b29sTmFtZSwgYWRkaXRpb25hbERhdGEpO1xuICAgIH1cbiAgICAvLyBjb21wb25lbnQ6IE1lcmdlVGFibGVzVG9vbENvbXBvbmVudFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZmlsdGVyRGF0YXNldCxcbiAgICBnZW5lcmljUXVlcnksXG4gICAgdGFibGVUb29sLFxuICAgIG1lcmdlVGFibGVzVG9vbFxuICB9O1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUdBLElBQUFBLE1BQUEsR0FBQUMsc0JBQUEsQ0FBQUMsT0FBQTtBQUdBLElBQUFDLE9BQUEsR0FBQUQsT0FBQTtBQU9BLElBQUFFLE9BQUEsR0FBQUYsT0FBQTtBQUNBLElBQUFHLE1BQUEsR0FBQUgsT0FBQTtBQUVBLElBQUFJLE9BQUEsR0FBQUosT0FBQTtBQUNBLElBQUFLLFVBQUEsR0FBQUwsT0FBQTtBQUE2RCxTQUFBTSxRQUFBQyxDQUFBLEVBQUFDLENBQUEsUUFBQUMsQ0FBQSxHQUFBQyxNQUFBLENBQUFDLElBQUEsQ0FBQUosQ0FBQSxPQUFBRyxNQUFBLENBQUFFLHFCQUFBLFFBQUFDLENBQUEsR0FBQUgsTUFBQSxDQUFBRSxxQkFBQSxDQUFBTCxDQUFBLEdBQUFDLENBQUEsS0FBQUssQ0FBQSxHQUFBQSxDQUFBLENBQUFDLE1BQUEsV0FBQU4sQ0FBQSxXQUFBRSxNQUFBLENBQUFLLHdCQUFBLENBQUFSLENBQUEsRUFBQUMsQ0FBQSxFQUFBUSxVQUFBLE9BQUFQLENBQUEsQ0FBQVEsSUFBQSxDQUFBQyxLQUFBLENBQUFULENBQUEsRUFBQUksQ0FBQSxZQUFBSixDQUFBO0FBQUEsU0FBQVUsY0FBQVosQ0FBQSxhQUFBQyxDQUFBLE1BQUFBLENBQUEsR0FBQVksU0FBQSxDQUFBQyxNQUFBLEVBQUFiLENBQUEsVUFBQUMsQ0FBQSxXQUFBVyxTQUFBLENBQUFaLENBQUEsSUFBQVksU0FBQSxDQUFBWixDQUFBLFFBQUFBLENBQUEsT0FBQUYsT0FBQSxDQUFBSSxNQUFBLENBQUFELENBQUEsT0FBQWEsT0FBQSxXQUFBZCxDQUFBLFFBQUFlLGdCQUFBLGFBQUFoQixDQUFBLEVBQUFDLENBQUEsRUFBQUMsQ0FBQSxDQUFBRCxDQUFBLFNBQUFFLE1BQUEsQ0FBQWMseUJBQUEsR0FBQWQsTUFBQSxDQUFBZSxnQkFBQSxDQUFBbEIsQ0FBQSxFQUFBRyxNQUFBLENBQUFjLHlCQUFBLENBQUFmLENBQUEsS0FBQUgsT0FBQSxDQUFBSSxNQUFBLENBQUFELENBQUEsR0FBQWEsT0FBQSxXQUFBZCxDQUFBLElBQUFFLE1BQUEsQ0FBQWdCLGNBQUEsQ0FBQW5CLENBQUEsRUFBQUMsQ0FBQSxFQUFBRSxNQUFBLENBQUFLLHdCQUFBLENBQUFOLENBQUEsRUFBQUQsQ0FBQSxpQkFBQUQsQ0FBQSxJQWpCN0Q7QUFDQTtBQWtCTyxTQUFTb0IsWUFBWUEsQ0FBQ0MsUUFBa0IsRUFBRUMsTUFBZSxFQUFFO0VBQ2hFLElBQU1DLFNBQVMsR0FBR0MsZ0JBQVMsQ0FBQ0MsV0FBVyxDQUFDLENBQUM7O0VBRXpDO0VBQ0EsSUFBTUMsU0FBUztJQUFBLElBQUFDLElBQUEsT0FBQUMsa0JBQUEsMkJBQUFDLFlBQUEsWUFBQUMsSUFBQSxDQUFHLFNBQUFDLFFBQU9DLFdBQW1CLEVBQUVDLFlBQW9CO01BQUEsSUFBQUMsTUFBQTtNQUFBLE9BQUFMLFlBQUEsWUFBQU0sSUFBQSxVQUFBQyxTQUFBQyxRQUFBO1FBQUEsa0JBQUFBLFFBQUEsQ0FBQUMsSUFBQSxHQUFBRCxRQUFBLENBQUFFLElBQUE7VUFBQTtZQUMxREwsTUFBTSxHQUFHLElBQUFNLDRCQUFvQixFQUFDbkIsUUFBUSxFQUFFQyxNQUFNLEVBQUVVLFdBQVcsRUFBRUMsWUFBWSxDQUFDO1lBQUEsT0FBQUksUUFBQSxDQUFBSSxNQUFBLFdBQ3pFUCxNQUFNO1VBQUE7VUFBQTtZQUFBLE9BQUFHLFFBQUEsQ0FBQUssSUFBQTtRQUFBO01BQUEsR0FBQVgsT0FBQTtJQUFBLENBQ2Q7SUFBQSxnQkFIS0wsU0FBU0EsQ0FBQWlCLEVBQUEsRUFBQUMsR0FBQTtNQUFBLE9BQUFqQixJQUFBLENBQUFoQixLQUFBLE9BQUFFLFNBQUE7SUFBQTtFQUFBLEdBR2Q7O0VBRUQ7RUFDQSxTQUFTZ0Msa0JBQWtCQSxDQUFDQyxLQUE0QixFQUFFO0lBQ3hELG9CQUFPdkQsTUFBQSxZQUFBd0QsYUFBQSxDQUFDcEQsT0FBQSxDQUFBcUQsb0JBQW9CLE1BQUFDLFNBQUEsaUJBQUtILEtBQUs7TUFBRXBCLFNBQVMsRUFBRUEsU0FBVTtNQUFDd0IsU0FBUyxFQUFFQTtJQUFVLEVBQUUsQ0FBQztFQUN4Rjs7RUFFQTtFQUNBLElBQU1DLFlBQTRCLEdBQUF2QyxhQUFBLENBQUFBLGFBQUEsS0FDN0J3QyxrQkFBVTtJQUNiQyxXQUFXLG1iQUtkO0lBQ0dDLE9BQU8sRUFBQTFDLGFBQUEsQ0FBQUEsYUFBQSxLQUNGd0Msa0JBQVUsQ0FBQ0UsT0FBTztNQUNyQjVCLFNBQVMsRUFBVEE7SUFBUyxFQUNWO0lBQ0Q2QixTQUFTLEVBQUVWO0VBQWtCLEVBQzlCOztFQUVEO0VBQ0E7RUFDQSxJQUFNVyxhQUE2QixHQUFBNUMsYUFBQSxDQUFBQSxhQUFBLEtBQzlCd0Msa0JBQVU7SUFDYkMsV0FBVyw0TUFHZDtJQUNHQyxPQUFPLEVBQUExQyxhQUFBLENBQUFBLGFBQUEsS0FDRndDLGtCQUFVLENBQUNFLE9BQU87TUFDckI1QixTQUFTLEVBQVRBO0lBQVMsRUFDVjtJQUNENkIsU0FBUyxFQUFFRTtFQUFrQixFQUM5Qjs7RUFFRDtFQUNBLElBQU1DLFNBQXlCLEdBQUE5QyxhQUFBLENBQUFBLGFBQUEsS0FDMUJ3QyxrQkFBVTtJQUNiQyxXQUFXLG9hQVFkO0lBQ0dDLE9BQU8sRUFBQTFDLGFBQUEsQ0FBQUEsYUFBQSxLQUNGd0Msa0JBQVUsQ0FBQ0UsT0FBTztNQUNyQjVCLFNBQVMsRUFBVEE7SUFBUyxFQUNWO0lBQ0Q2QixTQUFTLEVBQUVFO0VBQWtCLEVBQzlCOztFQUVEO0VBQ0EsSUFBTUUsZUFBZ0MsR0FBQS9DLGFBQUEsQ0FBQUEsYUFBQSxLQUNqQ2dELG1CQUFXO0lBQ2ROLE9BQU8sRUFBRTtNQUNQNUIsU0FBUyxFQUFUQTtJQUNGLENBQUM7SUFDRG1DLGVBQWUsRUFBRSxTQUFqQkEsZUFBZUEsQ0FBR0MsUUFBZ0IsRUFBRUMsY0FBdUIsRUFBSztNQUM5RHhDLFNBQVMsQ0FBQ3lDLFVBQVUsQ0FBQ0YsUUFBUSxFQUFFQyxjQUFjLENBQUM7SUFDaEQ7SUFDQTtFQUFBLEVBQ0Q7RUFFRCxPQUFPO0lBQ0xQLGFBQWEsRUFBYkEsYUFBYTtJQUNiTCxZQUFZLEVBQVpBLFlBQVk7SUFDWk8sU0FBUyxFQUFUQSxTQUFTO0lBQ1RDLGVBQWUsRUFBZkE7RUFDRixDQUFDO0FBQ0giLCJpZ25vcmVMaXN0IjpbXX0=