"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fitBoundsUpdater = exports.INITIAL_MAP_STATE = void 0;
exports.getMapDimForSplitMap = getMapDimForSplitMap;
exports.pickViewportPropsFromMapState = pickViewportPropsFromMapState;
exports.updateMapUpdater = exports.toggleSplitMapViewportUpdater = exports.toggleSplitMapUpdater = exports.togglePerspectiveUpdater = exports.resetMapConfigUpdater = exports.receiveMapConfigUpdater = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _geoViewport = _interopRequireDefault(require("@mapbox/geo-viewport"));
var _booleanWithin = _interopRequireDefault(require("@turf/boolean-within"));
var _bboxPolygon = _interopRequireDefault(require("@turf/bbox-polygon"));
var _webMercator = require("@math.gl/web-mercator");
var _deepmerge = _interopRequireDefault(require("deepmerge"));
var _pick = _interopRequireDefault(require("lodash/pick"));
var _src = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/utils/src");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
/**
 * Updaters for `mapState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {mapStateUpdaters} from '@kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // click button to close side panel
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             mapState: mapStateUpdaters.fitBoundsUpdater(
 *               mapState, {payload: [127.34, 31.09, 127.56, 31.59]]}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable @typescript-eslint/no-unused-vars */
// @ts-ignore
var mapStateUpdaters = null;
/* eslint-enable @typescript-eslint/no-unused-vars */
/**
 * Default initial `mapState`
 * @memberof mapStateUpdaters
 * @constant
 * @property pitch Default: `0`
 * @property bearing Default: `0`
 * @property latitude Default: `37.75043`
 * @property longitude Default: `-122.34679`
 * @property zoom Default: `9`
 * @property dragRotate Default: `false`
 * @property width Default: `800`
 * @property height Default: `800`
 * @property minZoom: `undefined`,
 * @property maxZoom: `undefined`,
 * @property maxBounds: `undefined`,
 * @property isSplit: `false`,
 * @property isViewportSynced: `true`,
 * @property isZoomLocked: `false`,
 * @property splitMapViewports: `[]`
 * @public
 */
var INITIAL_MAP_STATE = exports.INITIAL_MAP_STATE = {
  pitch: 0,
  bearing: 0,
  latitude: 37.75043,
  longitude: -122.34679,
  zoom: 9,
  dragRotate: false,
  width: 800,
  height: 800,
  minZoom: undefined,
  maxZoom: undefined,
  maxBounds: undefined,
  isSplit: false,
  isViewportSynced: true,
  isZoomLocked: false,
  splitMapViewports: []
};

/* Updaters */
/**
 * Update map viewport
 * @memberof mapStateUpdaters
 * @public
 */
var updateMapUpdater = exports.updateMapUpdater = function updateMapUpdater(state, action) {
  var _action$payload = action.payload,
    inputViewport = _action$payload.viewport,
    _action$payload$mapIn = _action$payload.mapIndex,
    mapIndex = _action$payload$mapIn === void 0 ? 0 : _action$payload$mapIn;
  var viewport = (0, _src.validateViewPort)(inputViewport);
  if (state.isViewportSynced) {
    // The `updateViewport` function is typed as (Viewport, Viewport) -> Viewport but here the
    // expected typing is (MapState, Viewport) -> MapState.
    // this could be a potential bug as we treat Viewport and MapState as equal seemingly
    // @ts-expect-error Type 'Viewport' is missing the following properties from type 'MapState': isSplit, isViewportSynced, isZoomLocked, splitMapViewports
    return updateViewport(state, viewport);
  }
  var otherViewportMapIndex = -1;
  var splitMapViewports = state.splitMapViewports.map(function (currentViewport, i) {
    if (i === mapIndex) {
      // update the matching viewport with the newViewport info in the action payload
      return updateViewport(currentViewport, viewport);
    }
    otherViewportMapIndex = i;
    // make no changes to the other viewport (yet)
    return currentViewport;
  });

  // make conditional updates to the other viewport not matching this payload's `mapIndex`
  if (Number.isFinite(otherViewportMapIndex) && otherViewportMapIndex > -1) {
    // width and height are a special case and are always updated
    splitMapViewports[otherViewportMapIndex] = _objectSpread(_objectSpread({}, splitMapViewports[otherViewportMapIndex]), {}, {
      width: splitMapViewports[mapIndex].width,
      height: splitMapViewports[mapIndex].height
    });
    if (state.isZoomLocked) {
      // update the other viewport with the new zoom from the split viewport that was updated with this payload's `mapIndex`
      splitMapViewports[otherViewportMapIndex] = _objectSpread(_objectSpread({}, splitMapViewports[otherViewportMapIndex]), {}, {
        zoom: splitMapViewports[mapIndex].zoom
      });
    }
  }
  return _objectSpread(_objectSpread(_objectSpread({}, state), splitMapViewports[mapIndex]), {}, {
    // update the mapState with the new array of split viewports
    splitMapViewports: splitMapViewports
  });
};

/**
 * Fit map viewport to bounds
 * @memberof mapStateUpdaters
 * @public
 */
var fitBoundsUpdater = exports.fitBoundsUpdater = function fitBoundsUpdater(state, action) {
  var centerAndZoom = (0, _src.getCenterAndZoomFromBounds)(action.payload, {
    width: state.width,
    height: state.height
  });
  if (!centerAndZoom) {
    // bounds is invalid
    return state;
  }
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    latitude: centerAndZoom.center[1],
    longitude: centerAndZoom.center[0]
  }, Number.isFinite(centerAndZoom.zoom) ? {
    zoom: centerAndZoom.zoom
  } : {});

  // if fitting to bounds while split and unsynced
  // copy the new latitude, longitude, and zoom values to each split viewport
  if (newState.splitMapViewports.length) {
    newState.splitMapViewports = newState.splitMapViewports.map(function (currentViewport) {
      return _objectSpread(_objectSpread({}, currentViewport), {}, {
        latitude: newState.latitude,
        longitude: newState.longitude,
        zoom: newState.zoom
      });
    });
  }
  return newState;
};

/**
 * Toggle between 3d and 2d map.
 * @memberof mapStateUpdaters
 * @public
 */
var togglePerspectiveUpdater = exports.togglePerspectiveUpdater = function togglePerspectiveUpdater(state) {
  var newState = _objectSpread(_objectSpread(_objectSpread({}, state), {
    pitch: state.dragRotate ? 0 : 50,
    bearing: state.dragRotate ? 0 : 24
  }), {}, {
    dragRotate: !state.dragRotate
  });

  // if toggling 3d and 2d while split and unsynced
  // copy the new pitch, bearing, and dragRotate values to each split viewport
  if (newState.splitMapViewports.length) {
    newState.splitMapViewports = newState.splitMapViewports.map(function (currentViewport) {
      return _objectSpread(_objectSpread({}, currentViewport), {}, {
        pitch: newState.pitch,
        bearing: newState.bearing,
        dragRotate: newState.dragRotate
      });
    });
  }
  return newState;
};

/**
 * reset mapState to initial State
 * @memberof mapStateUpdaters
 * @public
 */
var resetMapConfigUpdater = exports.resetMapConfigUpdater = function resetMapConfigUpdater(state) {
  return _objectSpread(_objectSpread(_objectSpread({}, INITIAL_MAP_STATE), state.initialState), {}, {
    initialState: state.initialState
  });
};

// consider case where you have a split map and user wants to reset
/**
 * Update `mapState` to propagate a new config
 * @memberof mapStateUpdaters
 * @public
 */
var receiveMapConfigUpdater = exports.receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref) {
  var _ref$payload = _ref.payload,
    _ref$payload$config = _ref$payload.config,
    config = _ref$payload$config === void 0 ? {} : _ref$payload$config,
    _ref$payload$options = _ref$payload.options,
    options = _ref$payload$options === void 0 ? {} : _ref$payload$options,
    _ref$payload$bounds = _ref$payload.bounds,
    bounds = _ref$payload$bounds === void 0 ? null : _ref$payload$bounds;
  /**
   * @type {Partial<MapState>}
   */
  var mapState = (config || {}).mapState || {};
  // merged received mapState with previous state
  // state also may include properties that are new to an existing, saved project's mapState

  var mergedState = (0, _deepmerge["default"])(state, mapState, {
    // note: deepmerge by default will merge arrays by concatenating them
    // but we need to overwrite destination arrays with source arrays, if present
    // https://github.com/TehShrike/deepmerge#arraymerge-example-overwrite-target-array
    arrayMerge: function arrayMerge(_destinationArray, sourceArray) {
      return sourceArray;
    }
  });

  // if center map
  // center map will override mapState config
  if (options.centerMap && bounds) {
    mergedState = fitBoundsUpdater(mergedState, {
      payload: bounds
    });
  }

  // make sure we validate map state before we merge
  mergedState = (0, _src.validateViewPort)(mergedState);
  return _objectSpread(_objectSpread({}, mergedState), getMapDimForSplitMap(mergedState.isSplit, state));
};

/**
 * Toggle between one or split maps
 * @memberof mapStateUpdaters
 * @public
 */
var toggleSplitMapUpdater = exports.toggleSplitMapUpdater = function toggleSplitMapUpdater(state) {
  return _objectSpread(_objectSpread(_objectSpread({}, state), getMapDimForSplitMap(!state.isSplit, state)), {}, {
    isSplit: !state.isSplit
  }, !state.isSplit === false ? {
    // if toggling to no longer split (single mode) then reset a few properties
    isViewportSynced: true,
    isZoomLocked: false,
    splitMapViewports: []
  } : {});
};

/**
 * Toggle between locked and unlocked split viewports
 * @memberof mapStateUpdaters
 * @public
 */
var toggleSplitMapViewportUpdater = exports.toggleSplitMapViewportUpdater = function toggleSplitMapViewportUpdater(state, action) {
  // new map state immediately gets the new, optional payload values for isViewportSynced and/or isZoomLocked
  var newMapState = _objectSpread(_objectSpread({}, state), action.payload || {});
  if (newMapState.isViewportSynced) {
    // switching from unsynced to synced viewports
    newMapState.splitMapViewports = [];
  } else {
    // switching from synced to unsynced viewports
    // or already in unsynced mode and toggling locked zoom

    if (state.isZoomLocked && !newMapState.isZoomLocked) {
      // switching off locked zoom while unsynced
      // don't copy the mapStates to left and right viewports because there will be zoom "jumping"
      return newMapState;
    }
    if (!state.isZoomLocked && newMapState.isZoomLocked) {
      // switching on locked zoom while unsynced
      // only copy zoom viewport property from the most recently interacted-with viewport to the other
      // TODO: do we want to check for a match a different way, such as a combo of `latitude` and `longitude`?
      var lastUpdatedViewportIndex = newMapState.splitMapViewports.findIndex(function (v) {
        return newMapState.zoom === v.zoom;
      });
      var splitMapViewports = newMapState.splitMapViewports.map(function (currentViewport, i) {
        if (i === lastUpdatedViewportIndex) {
          // no zoom to modify here
          return currentViewport;
        }
        // the other viewport gets the most recently interacted-with viewport's zoom
        // WHY? the viewport the user was last interacting with will set zoom across the board for smooth UX
        return _objectSpread(_objectSpread({}, currentViewport), {}, {
          zoom: newMapState.splitMapViewports[lastUpdatedViewportIndex].zoom
        });
      });
      newMapState.splitMapViewports = splitMapViewports;
      return newMapState;
    }

    // if current viewport is synced, and we are unsyncing it
    // or already in unsynced mode and NOT toggling locked zoom
    // make a fresh copy of the current viewport object, assign it to splitMapViewports[]
    // pickViewportPropsFromMapState is called twice to avoid memory allocation conflicts
    var leftViewport = pickViewportPropsFromMapState(newMapState);
    var rightViewport = pickViewportPropsFromMapState(newMapState);
    newMapState.splitMapViewports = [leftViewport, rightViewport];
  }

  // return new state
  return newMapState;
};

// Helpers
function getMapDimForSplitMap(isSplit, state) {
  // cases:
  // 1. state split: true - isSplit: true
  // do nothing
  // 2. state split: false - isSplit: false
  // do nothing
  if (state.isSplit === isSplit) {
    return {};
  }
  var width = state.isSplit && !isSplit ?
  // 3. state split: true - isSplit: false
  // double width
  state.width * 2 :
  // 4. state split: false - isSplit: true
  // split width
  state.width / 2;
  return {
    width: width
  };
}
function updateViewportBasedOnBounds(state, newMapState) {
  // Get the new viewport bounds
  var viewportBounds = _geoViewport["default"].bounds([newMapState.longitude, newMapState.latitude], newMapState.zoom, [newMapState.width, newMapState.height], _src.MAPBOX_TILE_SIZE);
  // Generate turf Polygon from bounds for comparison
  var viewportBoundsPolygon = (0, _bboxPolygon["default"])(viewportBounds);
  // @ts-ignore
  var newStateMaxBounds = newMapState.maxBounds;
  // @ts-ignore
  var maxBoundsPolygon = (0, _bboxPolygon["default"])(newStateMaxBounds);

  // If maxBounds has changed reset the viewport to snap to bounds
  var hasMaxBoundsChanged = !state.maxBounds || !state.maxBounds.every(function (val, idx) {
    return val === newStateMaxBounds[idx];
  });
  if (hasMaxBoundsChanged) {
    // Check if the newMapState viewport is within maxBounds
    if (!(0, _booleanWithin["default"])(viewportBoundsPolygon, maxBoundsPolygon)) {
      // Validate bounds to prevent projection matrix errors with maximum extents
      // This ensures bounds are within valid mercator projection limits
      var validatedBounds = [Math.max(newStateMaxBounds[0], _src.MIN_LONGITUDE), Math.max(newStateMaxBounds[1], _src.MIN_LATITUDE), Math.min(newStateMaxBounds[2], _src.MAX_LONGITUDE), Math.min(newStateMaxBounds[3], _src.MAX_LATITUDE)];
      var _fitBounds = (0, _webMercator.fitBounds)({
          width: newMapState.width,
          height: newMapState.height,
          bounds: [[validatedBounds[0], validatedBounds[1]], [validatedBounds[2], validatedBounds[3]]]
        }),
        latitude = _fitBounds.latitude,
        longitude = _fitBounds.longitude,
        zoom = _fitBounds.zoom;
      newMapState = _objectSpread(_objectSpread({}, newMapState), {}, {
        latitude: latitude,
        longitude: longitude
      }, Number.isFinite(zoom) ? {
        zoom: zoom
      } : {});
    }
    return newMapState;
  }

  // Check if the newMapState viewport is within maxBounds
  if (!(0, _booleanWithin["default"])(viewportBoundsPolygon, maxBoundsPolygon)) {
    newMapState = _objectSpread(_objectSpread({}, newMapState), {}, {
      longitude: state.longitude,
      latitude: state.latitude,
      zoom: state.zoom
    });
  }
  return newMapState;
}
function pickViewportPropsFromMapState(state) {
  return (0, _pick["default"])(state, ['width', 'height', 'zoom', 'pitch', 'bearing', 'latitude', 'longitude', 'dragRotate', 'minZoom', 'maxZoom', 'maxBounds']);
}

/** Select items from object whose value is not undefined */
var definedProps = function definedProps(obj) {
  return Object.entries(obj).reduce(function (accu, _ref2) {
    var _ref3 = (0, _slicedToArray2["default"])(_ref2, 2),
      k = _ref3[0],
      v = _ref3[1];
    return _objectSpread(_objectSpread({}, accu), v !== undefined ? (0, _defineProperty2["default"])({}, k, v) : {});
  }, {});
};
function updateViewport(originalViewport, viewportUpdates) {
  var newViewport = _objectSpread(_objectSpread({}, originalViewport), definedProps(viewportUpdates) || {});

  // Make sure zoom level doesn't go bellow minZoom if defined
  if (newViewport.minZoom && newViewport.zoom && newViewport.zoom < newViewport.minZoom) {
    newViewport.zoom = newViewport.minZoom;
  }
  // Make sure zoom level doesn't go above maxZoom if defined
  if (newViewport.maxZoom && newViewport.zoom && newViewport.zoom > newViewport.maxZoom) {
    newViewport.zoom = newViewport.maxZoom;
  }
  // Limit viewport update based on maxBounds
  if (newViewport.maxBounds && (0, _src.validateBounds)(newViewport.maxBounds)) {
    // @ts-expect-error Type 'Viewport' is missing the following properties from type 'MapState': isSplit, isViewportSynced, isZoomLocked, splitMapViewports
    newViewport = updateViewportBasedOnBounds(originalViewport, newViewport);
  }
  return newViewport;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZ2VvVmlld3BvcnQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9ib29sZWFuV2l0aGluIiwiX2Jib3hQb2x5Z29uIiwiX3dlYk1lcmNhdG9yIiwiX2RlZXBtZXJnZSIsIl9waWNrIiwiX3NyYyIsIm93bktleXMiLCJlIiwiciIsInQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eTIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwibWFwU3RhdGVVcGRhdGVycyIsIklOSVRJQUxfTUFQX1NUQVRFIiwiZXhwb3J0cyIsInBpdGNoIiwiYmVhcmluZyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsImRyYWdSb3RhdGUiLCJ3aWR0aCIsImhlaWdodCIsIm1pblpvb20iLCJ1bmRlZmluZWQiLCJtYXhab29tIiwibWF4Qm91bmRzIiwiaXNTcGxpdCIsImlzVmlld3BvcnRTeW5jZWQiLCJpc1pvb21Mb2NrZWQiLCJzcGxpdE1hcFZpZXdwb3J0cyIsInVwZGF0ZU1hcFVwZGF0ZXIiLCJzdGF0ZSIsImFjdGlvbiIsIl9hY3Rpb24kcGF5bG9hZCIsInBheWxvYWQiLCJpbnB1dFZpZXdwb3J0Iiwidmlld3BvcnQiLCJfYWN0aW9uJHBheWxvYWQkbWFwSW4iLCJtYXBJbmRleCIsInZhbGlkYXRlVmlld1BvcnQiLCJ1cGRhdGVWaWV3cG9ydCIsIm90aGVyVmlld3BvcnRNYXBJbmRleCIsIm1hcCIsImN1cnJlbnRWaWV3cG9ydCIsImkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZpdEJvdW5kc1VwZGF0ZXIiLCJjZW50ZXJBbmRab29tIiwiZ2V0Q2VudGVyQW5kWm9vbUZyb21Cb3VuZHMiLCJuZXdTdGF0ZSIsImNlbnRlciIsInRvZ2dsZVBlcnNwZWN0aXZlVXBkYXRlciIsInJlc2V0TWFwQ29uZmlnVXBkYXRlciIsImluaXRpYWxTdGF0ZSIsInJlY2VpdmVNYXBDb25maWdVcGRhdGVyIiwiX3JlZiIsIl9yZWYkcGF5bG9hZCIsIl9yZWYkcGF5bG9hZCRjb25maWciLCJjb25maWciLCJfcmVmJHBheWxvYWQkb3B0aW9ucyIsIm9wdGlvbnMiLCJfcmVmJHBheWxvYWQkYm91bmRzIiwiYm91bmRzIiwibWFwU3RhdGUiLCJtZXJnZWRTdGF0ZSIsImRlZXBtZXJnZSIsImFycmF5TWVyZ2UiLCJfZGVzdGluYXRpb25BcnJheSIsInNvdXJjZUFycmF5IiwiY2VudGVyTWFwIiwiZ2V0TWFwRGltRm9yU3BsaXRNYXAiLCJ0b2dnbGVTcGxpdE1hcFVwZGF0ZXIiLCJ0b2dnbGVTcGxpdE1hcFZpZXdwb3J0VXBkYXRlciIsIm5ld01hcFN0YXRlIiwibGFzdFVwZGF0ZWRWaWV3cG9ydEluZGV4IiwiZmluZEluZGV4IiwidiIsImxlZnRWaWV3cG9ydCIsInBpY2tWaWV3cG9ydFByb3BzRnJvbU1hcFN0YXRlIiwicmlnaHRWaWV3cG9ydCIsInVwZGF0ZVZpZXdwb3J0QmFzZWRPbkJvdW5kcyIsInZpZXdwb3J0Qm91bmRzIiwiZ2VvVmlld3BvcnQiLCJNQVBCT1hfVElMRV9TSVpFIiwidmlld3BvcnRCb3VuZHNQb2x5Z29uIiwiYmJveFBvbHlnb24iLCJuZXdTdGF0ZU1heEJvdW5kcyIsIm1heEJvdW5kc1BvbHlnb24iLCJoYXNNYXhCb3VuZHNDaGFuZ2VkIiwiZXZlcnkiLCJ2YWwiLCJpZHgiLCJib29sZWFuV2l0aGluIiwidmFsaWRhdGVkQm91bmRzIiwiTWF0aCIsIm1heCIsIk1JTl9MT05HSVRVREUiLCJNSU5fTEFUSVRVREUiLCJtaW4iLCJNQVhfTE9OR0lUVURFIiwiTUFYX0xBVElUVURFIiwiX2ZpdEJvdW5kcyIsImZpdEJvdW5kcyIsInBpY2siLCJkZWZpbmVkUHJvcHMiLCJvYmoiLCJlbnRyaWVzIiwicmVkdWNlIiwiYWNjdSIsIl9yZWYyIiwiX3JlZjMiLCJfc2xpY2VkVG9BcnJheTIiLCJrIiwib3JpZ2luYWxWaWV3cG9ydCIsInZpZXdwb3J0VXBkYXRlcyIsIm5ld1ZpZXdwb3J0IiwidmFsaWRhdGVCb3VuZHMiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvcmVkdWNlcnMvc3JjL21hcC1zdGF0ZS11cGRhdGVycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgZ2VvVmlld3BvcnQgZnJvbSAnQG1hcGJveC9nZW8tdmlld3BvcnQnO1xuaW1wb3J0IGJvb2xlYW5XaXRoaW4gZnJvbSAnQHR1cmYvYm9vbGVhbi13aXRoaW4nO1xuaW1wb3J0IGJib3hQb2x5Z29uIGZyb20gJ0B0dXJmL2Jib3gtcG9seWdvbic7XG5pbXBvcnQge2ZpdEJvdW5kc30gZnJvbSAnQG1hdGguZ2wvd2ViLW1lcmNhdG9yJztcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCBwaWNrIGZyb20gJ2xvZGFzaC9waWNrJztcblxuaW1wb3J0IHtcbiAgZ2V0Q2VudGVyQW5kWm9vbUZyb21Cb3VuZHMsXG4gIHZhbGlkYXRlQm91bmRzLFxuICBNQVBCT1hfVElMRV9TSVpFLFxuICB2YWxpZGF0ZVZpZXdQb3J0LFxuICBNSU5fTE9OR0lUVURFLFxuICBNSU5fTEFUSVRVREUsXG4gIE1BWF9MT05HSVRVREUsXG4gIE1BWF9MQVRJVFVERVxufSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7TWFwU3RhdGVBY3Rpb25zLCBSZWNlaXZlTWFwQ29uZmlnUGF5bG9hZCwgQWN0aW9uVHlwZXN9IGZyb20gJ0BrZXBsZXIuZ2wvYWN0aW9ucyc7XG5pbXBvcnQge01hcFN0YXRlLCBCb3VuZHMsIFZpZXdwb3J0fSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcblxuLyoqXG4gKiBVcGRhdGVycyBmb3IgYG1hcFN0YXRlYCByZWR1Y2VyLiBDYW4gYmUgdXNlZCBpbiB5b3VyIHJvb3QgcmVkdWNlciB0byBkaXJlY3RseSBtb2RpZnkga2VwbGVyLmdsJ3Mgc3RhdGUuXG4gKiBSZWFkIG1vcmUgYWJvdXQgW1VzaW5nIHVwZGF0ZXJzXSguLi9hZHZhbmNlZC11c2FnZS91c2luZy11cGRhdGVycy5tZClcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IGtlcGxlckdsUmVkdWNlciwge21hcFN0YXRlVXBkYXRlcnN9IGZyb20gJ0BrZXBsZXIuZ2wvcmVkdWNlcnMnO1xuICogLy8gUm9vdCBSZWR1Y2VyXG4gKiBjb25zdCByZWR1Y2VycyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gKiAga2VwbGVyR2w6IGtlcGxlckdsUmVkdWNlcixcbiAqICBhcHA6IGFwcFJlZHVjZXJcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNvbXBvc2VkUmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gKiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICogICAgLy8gY2xpY2sgYnV0dG9uIHRvIGNsb3NlIHNpZGUgcGFuZWxcbiAqICAgIGNhc2UgJ0NMSUNLX0JVVFRPTic6XG4gKiAgICAgIHJldHVybiB7XG4gKiAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAga2VwbGVyR2w6IHtcbiAqICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLFxuICogICAgICAgICAgZm9vOiB7XG4gKiAgICAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbC5mb28sXG4gKiAgICAgICAgICAgICBtYXBTdGF0ZTogbWFwU3RhdGVVcGRhdGVycy5maXRCb3VuZHNVcGRhdGVyKFxuICogICAgICAgICAgICAgICBtYXBTdGF0ZSwge3BheWxvYWQ6IFsxMjcuMzQsIDMxLjA5LCAxMjcuNTYsIDMxLjU5XV19XG4gKiAgICAgICAgICAgICApXG4gKiAgICAgICAgICB9XG4gKiAgICAgICAgfVxuICogICAgICB9O1xuICogIH1cbiAqICByZXR1cm4gcmVkdWNlcnMoc3RhdGUsIGFjdGlvbik7XG4gKiB9O1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGNvbXBvc2VkUmVkdWNlcjtcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG1hcFN0YXRlVXBkYXRlcnMgPSBudWxsO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogRGVmYXVsdCBpbml0aWFsIGBtYXBTdGF0ZWBcbiAqIEBtZW1iZXJvZiBtYXBTdGF0ZVVwZGF0ZXJzXG4gKiBAY29uc3RhbnRcbiAqIEBwcm9wZXJ0eSBwaXRjaCBEZWZhdWx0OiBgMGBcbiAqIEBwcm9wZXJ0eSBiZWFyaW5nIERlZmF1bHQ6IGAwYFxuICogQHByb3BlcnR5IGxhdGl0dWRlIERlZmF1bHQ6IGAzNy43NTA0M2BcbiAqIEBwcm9wZXJ0eSBsb25naXR1ZGUgRGVmYXVsdDogYC0xMjIuMzQ2NzlgXG4gKiBAcHJvcGVydHkgem9vbSBEZWZhdWx0OiBgOWBcbiAqIEBwcm9wZXJ0eSBkcmFnUm90YXRlIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwcm9wZXJ0eSB3aWR0aCBEZWZhdWx0OiBgODAwYFxuICogQHByb3BlcnR5IGhlaWdodCBEZWZhdWx0OiBgODAwYFxuICogQHByb3BlcnR5IG1pblpvb206IGB1bmRlZmluZWRgLFxuICogQHByb3BlcnR5IG1heFpvb206IGB1bmRlZmluZWRgLFxuICogQHByb3BlcnR5IG1heEJvdW5kczogYHVuZGVmaW5lZGAsXG4gKiBAcHJvcGVydHkgaXNTcGxpdDogYGZhbHNlYCxcbiAqIEBwcm9wZXJ0eSBpc1ZpZXdwb3J0U3luY2VkOiBgdHJ1ZWAsXG4gKiBAcHJvcGVydHkgaXNab29tTG9ja2VkOiBgZmFsc2VgLFxuICogQHByb3BlcnR5IHNwbGl0TWFwVmlld3BvcnRzOiBgW11gXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBJTklUSUFMX01BUF9TVEFURTogTWFwU3RhdGUgPSB7XG4gIHBpdGNoOiAwLFxuICBiZWFyaW5nOiAwLFxuICBsYXRpdHVkZTogMzcuNzUwNDMsXG4gIGxvbmdpdHVkZTogLTEyMi4zNDY3OSxcbiAgem9vbTogOSxcbiAgZHJhZ1JvdGF0ZTogZmFsc2UsXG4gIHdpZHRoOiA4MDAsXG4gIGhlaWdodDogODAwLFxuICBtaW5ab29tOiB1bmRlZmluZWQsXG4gIG1heFpvb206IHVuZGVmaW5lZCxcbiAgbWF4Qm91bmRzOiB1bmRlZmluZWQsXG4gIGlzU3BsaXQ6IGZhbHNlLFxuICBpc1ZpZXdwb3J0U3luY2VkOiB0cnVlLFxuICBpc1pvb21Mb2NrZWQ6IGZhbHNlLFxuICBzcGxpdE1hcFZpZXdwb3J0czogW11cbn07XG5cbi8qIFVwZGF0ZXJzICovXG4vKipcbiAqIFVwZGF0ZSBtYXAgdmlld3BvcnRcbiAqIEBtZW1iZXJvZiBtYXBTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVNYXBVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3RhdGUsXG4gIGFjdGlvbjogTWFwU3RhdGVBY3Rpb25zLlVwZGF0ZU1hcFVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0YXRlID0+IHtcbiAgY29uc3Qge3ZpZXdwb3J0OiBpbnB1dFZpZXdwb3J0LCBtYXBJbmRleCA9IDB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gIGNvbnN0IHZpZXdwb3J0ID0gdmFsaWRhdGVWaWV3UG9ydChpbnB1dFZpZXdwb3J0KTtcblxuICBpZiAoc3RhdGUuaXNWaWV3cG9ydFN5bmNlZCkge1xuICAgIC8vIFRoZSBgdXBkYXRlVmlld3BvcnRgIGZ1bmN0aW9uIGlzIHR5cGVkIGFzIChWaWV3cG9ydCwgVmlld3BvcnQpIC0+IFZpZXdwb3J0IGJ1dCBoZXJlIHRoZVxuICAgIC8vIGV4cGVjdGVkIHR5cGluZyBpcyAoTWFwU3RhdGUsIFZpZXdwb3J0KSAtPiBNYXBTdGF0ZS5cbiAgICAvLyB0aGlzIGNvdWxkIGJlIGEgcG90ZW50aWFsIGJ1ZyBhcyB3ZSB0cmVhdCBWaWV3cG9ydCBhbmQgTWFwU3RhdGUgYXMgZXF1YWwgc2VlbWluZ2x5XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUeXBlICdWaWV3cG9ydCcgaXMgbWlzc2luZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgZnJvbSB0eXBlICdNYXBTdGF0ZSc6IGlzU3BsaXQsIGlzVmlld3BvcnRTeW5jZWQsIGlzWm9vbUxvY2tlZCwgc3BsaXRNYXBWaWV3cG9ydHNcbiAgICByZXR1cm4gdXBkYXRlVmlld3BvcnQoc3RhdGUsIHZpZXdwb3J0KTtcbiAgfVxuXG4gIGxldCBvdGhlclZpZXdwb3J0TWFwSW5kZXggPSAtMTtcbiAgY29uc3Qgc3BsaXRNYXBWaWV3cG9ydHMgPSBzdGF0ZS5zcGxpdE1hcFZpZXdwb3J0cy5tYXAoKGN1cnJlbnRWaWV3cG9ydCwgaSkgPT4ge1xuICAgIGlmIChpID09PSBtYXBJbmRleCkge1xuICAgICAgLy8gdXBkYXRlIHRoZSBtYXRjaGluZyB2aWV3cG9ydCB3aXRoIHRoZSBuZXdWaWV3cG9ydCBpbmZvIGluIHRoZSBhY3Rpb24gcGF5bG9hZFxuICAgICAgcmV0dXJuIHVwZGF0ZVZpZXdwb3J0KGN1cnJlbnRWaWV3cG9ydCwgdmlld3BvcnQpO1xuICAgIH1cblxuICAgIG90aGVyVmlld3BvcnRNYXBJbmRleCA9IGk7XG4gICAgLy8gbWFrZSBubyBjaGFuZ2VzIHRvIHRoZSBvdGhlciB2aWV3cG9ydCAoeWV0KVxuICAgIHJldHVybiBjdXJyZW50Vmlld3BvcnQ7XG4gIH0pO1xuXG4gIC8vIG1ha2UgY29uZGl0aW9uYWwgdXBkYXRlcyB0byB0aGUgb3RoZXIgdmlld3BvcnQgbm90IG1hdGNoaW5nIHRoaXMgcGF5bG9hZCdzIGBtYXBJbmRleGBcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShvdGhlclZpZXdwb3J0TWFwSW5kZXgpICYmIG90aGVyVmlld3BvcnRNYXBJbmRleCA+IC0xKSB7XG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBhcmUgYSBzcGVjaWFsIGNhc2UgYW5kIGFyZSBhbHdheXMgdXBkYXRlZFxuICAgIHNwbGl0TWFwVmlld3BvcnRzW290aGVyVmlld3BvcnRNYXBJbmRleF0gPSB7XG4gICAgICAuLi5zcGxpdE1hcFZpZXdwb3J0c1tvdGhlclZpZXdwb3J0TWFwSW5kZXhdLFxuICAgICAgd2lkdGg6IHNwbGl0TWFwVmlld3BvcnRzW21hcEluZGV4XS53aWR0aCxcbiAgICAgIGhlaWdodDogc3BsaXRNYXBWaWV3cG9ydHNbbWFwSW5kZXhdLmhlaWdodFxuICAgIH07XG5cbiAgICBpZiAoc3RhdGUuaXNab29tTG9ja2VkKSB7XG4gICAgICAvLyB1cGRhdGUgdGhlIG90aGVyIHZpZXdwb3J0IHdpdGggdGhlIG5ldyB6b29tIGZyb20gdGhlIHNwbGl0IHZpZXdwb3J0IHRoYXQgd2FzIHVwZGF0ZWQgd2l0aCB0aGlzIHBheWxvYWQncyBgbWFwSW5kZXhgXG4gICAgICBzcGxpdE1hcFZpZXdwb3J0c1tvdGhlclZpZXdwb3J0TWFwSW5kZXhdID0ge1xuICAgICAgICAuLi5zcGxpdE1hcFZpZXdwb3J0c1tvdGhlclZpZXdwb3J0TWFwSW5kZXhdLFxuICAgICAgICB6b29tOiBzcGxpdE1hcFZpZXdwb3J0c1ttYXBJbmRleF0uem9vbVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIHVwZGF0ZSB0aGUgdG9wLWxldmVsIG1hcFN0YXRlIHZpZXdwb3J0IHdpdGggdGhlIG1vc3QgcmVjZW50bHkgaW50ZXJhY3RlZC13aXRoIHNwbGl0IHZpZXdwb3J0XG4gICAgLy8gV0hZPyB0aGlzIGF2b2lkcyB6b29tIGFuZCBib3VuZHMgXCJqdW1waW5nXCIgZHVlIHRvIGEgXCJzdGFsZVwiIHRvcC1sZXZlbCBtYXBTdGF0ZSB2aWV3cG9ydCB3aGVuOlxuICAgIC8vICAxLiB0b2dnbGluZyBvZmYgdGhlIHVuc3luY2VkIHZpZXdwb3J0cyBtb2RlIHRvIHN3aXRjaCB0byB0aGUgc3luY2VkIHZpZXdwb3J0cyBtb2RlXG4gICAgLy8gIDIuIHRvZ2dsaW5nIG9uIHRoZSB6b29tIGxvY2sgZHVyaW5nIGFuIHVuc3luY2VkIHZpZXdwb3J0cyBtb2RlXG4gICAgLi4uc3RhdGUsXG4gICAgLi4uc3BsaXRNYXBWaWV3cG9ydHNbbWFwSW5kZXhdLFxuICAgIC8vIHVwZGF0ZSB0aGUgbWFwU3RhdGUgd2l0aCB0aGUgbmV3IGFycmF5IG9mIHNwbGl0IHZpZXdwb3J0c1xuICAgIHNwbGl0TWFwVmlld3BvcnRzXG4gIH07XG59O1xuXG4vKipcbiAqIEZpdCBtYXAgdmlld3BvcnQgdG8gYm91bmRzXG4gKiBAbWVtYmVyb2YgbWFwU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZml0Qm91bmRzVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0YXRlLFxuICBhY3Rpb246IE1hcFN0YXRlQWN0aW9ucy5GaXRCb3VuZHNVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdGF0ZSA9PiB7XG4gIGNvbnN0IGNlbnRlckFuZFpvb20gPSBnZXRDZW50ZXJBbmRab29tRnJvbUJvdW5kcyhhY3Rpb24ucGF5bG9hZCwge1xuICAgIHdpZHRoOiBzdGF0ZS53aWR0aCxcbiAgICBoZWlnaHQ6IHN0YXRlLmhlaWdodFxuICB9KTtcbiAgaWYgKCFjZW50ZXJBbmRab29tKSB7XG4gICAgLy8gYm91bmRzIGlzIGludmFsaWRcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXRpdHVkZTogY2VudGVyQW5kWm9vbS5jZW50ZXJbMV0sXG4gICAgbG9uZ2l0dWRlOiBjZW50ZXJBbmRab29tLmNlbnRlclswXSxcbiAgICAvLyBGb3IgbWFyZ2luYWwgb3IgaW52YWxpZCBib3VuZHMsIHpvb20gbWF5IGJlIE5hTi4gTWFrZSBzdXJlIHRvIHByb3ZpZGUgYSB2YWxpZCB2YWx1ZSBpbiBvcmRlclxuICAgIC8vIHRvIGF2b2lkIGNvcnJ1cHQgc3RhdGUgYW5kIHBvdGVudGlhbCBjcmFzaGVzIGFzIHpvb20gaXMgZXhwZWN0ZWQgdG8gYmUgYSBudW1iZXJcbiAgICAuLi4oTnVtYmVyLmlzRmluaXRlKGNlbnRlckFuZFpvb20uem9vbSkgPyB7em9vbTogY2VudGVyQW5kWm9vbS56b29tfSA6IHt9KVxuICB9O1xuXG4gIC8vIGlmIGZpdHRpbmcgdG8gYm91bmRzIHdoaWxlIHNwbGl0IGFuZCB1bnN5bmNlZFxuICAvLyBjb3B5IHRoZSBuZXcgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgYW5kIHpvb20gdmFsdWVzIHRvIGVhY2ggc3BsaXQgdmlld3BvcnRcbiAgaWYgKG5ld1N0YXRlLnNwbGl0TWFwVmlld3BvcnRzLmxlbmd0aCkge1xuICAgIG5ld1N0YXRlLnNwbGl0TWFwVmlld3BvcnRzID0gbmV3U3RhdGUuc3BsaXRNYXBWaWV3cG9ydHMubWFwKGN1cnJlbnRWaWV3cG9ydCA9PiAoe1xuICAgICAgLi4uY3VycmVudFZpZXdwb3J0LFxuICAgICAgbGF0aXR1ZGU6IG5ld1N0YXRlLmxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlOiBuZXdTdGF0ZS5sb25naXR1ZGUsXG4gICAgICB6b29tOiBuZXdTdGF0ZS56b29tXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgYmV0d2VlbiAzZCBhbmQgMmQgbWFwLlxuICogQG1lbWJlcm9mIG1hcFN0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZVBlcnNwZWN0aXZlVXBkYXRlciA9IChzdGF0ZTogTWFwU3RhdGUpOiBNYXBTdGF0ZSA9PiB7XG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIC4uLntcbiAgICAgIHBpdGNoOiBzdGF0ZS5kcmFnUm90YXRlID8gMCA6IDUwLFxuICAgICAgYmVhcmluZzogc3RhdGUuZHJhZ1JvdGF0ZSA/IDAgOiAyNFxuICAgIH0sXG4gICAgZHJhZ1JvdGF0ZTogIXN0YXRlLmRyYWdSb3RhdGVcbiAgfTtcblxuICAvLyBpZiB0b2dnbGluZyAzZCBhbmQgMmQgd2hpbGUgc3BsaXQgYW5kIHVuc3luY2VkXG4gIC8vIGNvcHkgdGhlIG5ldyBwaXRjaCwgYmVhcmluZywgYW5kIGRyYWdSb3RhdGUgdmFsdWVzIHRvIGVhY2ggc3BsaXQgdmlld3BvcnRcbiAgaWYgKG5ld1N0YXRlLnNwbGl0TWFwVmlld3BvcnRzLmxlbmd0aCkge1xuICAgIG5ld1N0YXRlLnNwbGl0TWFwVmlld3BvcnRzID0gbmV3U3RhdGUuc3BsaXRNYXBWaWV3cG9ydHMubWFwKGN1cnJlbnRWaWV3cG9ydCA9PiAoe1xuICAgICAgLi4uY3VycmVudFZpZXdwb3J0LFxuICAgICAgcGl0Y2g6IG5ld1N0YXRlLnBpdGNoLFxuICAgICAgYmVhcmluZzogbmV3U3RhdGUuYmVhcmluZyxcbiAgICAgIGRyYWdSb3RhdGU6IG5ld1N0YXRlLmRyYWdSb3RhdGVcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG4vKipcbiAqIHJlc2V0IG1hcFN0YXRlIHRvIGluaXRpYWwgU3RhdGVcbiAqIEBtZW1iZXJvZiBtYXBTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZXNldE1hcENvbmZpZ1VwZGF0ZXIgPSAoc3RhdGU6IE1hcFN0YXRlKTogTWFwU3RhdGUgPT4gKHtcbiAgLi4uSU5JVElBTF9NQVBfU1RBVEUsXG4gIC4uLnN0YXRlLmluaXRpYWxTdGF0ZSxcbiAgaW5pdGlhbFN0YXRlOiBzdGF0ZS5pbml0aWFsU3RhdGVcbn0pO1xuXG4vLyBjb25zaWRlciBjYXNlIHdoZXJlIHlvdSBoYXZlIGEgc3BsaXQgbWFwIGFuZCB1c2VyIHdhbnRzIHRvIHJlc2V0XG4vKipcbiAqIFVwZGF0ZSBgbWFwU3RhdGVgIHRvIHByb3BhZ2F0ZSBhIG5ldyBjb25maWdcbiAqIEBtZW1iZXJvZiBtYXBTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZWNlaXZlTWFwQ29uZmlnVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0YXRlLFxuICB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHBheWxvYWQ6IHtjb25maWcgPSB7fSwgb3B0aW9ucyA9IHt9LCBib3VuZHMgPSBudWxsfVxuICB9OiB7XG4gICAgdHlwZT86IHR5cGVvZiBBY3Rpb25UeXBlcy5SRUNFSVZFX01BUF9DT05GSUc7XG4gICAgcGF5bG9hZDogUmVjZWl2ZU1hcENvbmZpZ1BheWxvYWQ7XG4gIH1cbik6IE1hcFN0YXRlID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtQYXJ0aWFsPE1hcFN0YXRlPn1cbiAgICovXG4gIGNvbnN0IG1hcFN0YXRlID0gKGNvbmZpZyB8fCB7fSkubWFwU3RhdGUgfHwge307XG4gIC8vIG1lcmdlZCByZWNlaXZlZCBtYXBTdGF0ZSB3aXRoIHByZXZpb3VzIHN0YXRlXG4gIC8vIHN0YXRlIGFsc28gbWF5IGluY2x1ZGUgcHJvcGVydGllcyB0aGF0IGFyZSBuZXcgdG8gYW4gZXhpc3RpbmcsIHNhdmVkIHByb2plY3QncyBtYXBTdGF0ZVxuXG4gIGxldCBtZXJnZWRTdGF0ZSA9IGRlZXBtZXJnZTxNYXBTdGF0ZT4oc3RhdGUsIG1hcFN0YXRlLCB7XG4gICAgLy8gbm90ZTogZGVlcG1lcmdlIGJ5IGRlZmF1bHQgd2lsbCBtZXJnZSBhcnJheXMgYnkgY29uY2F0ZW5hdGluZyB0aGVtXG4gICAgLy8gYnV0IHdlIG5lZWQgdG8gb3ZlcndyaXRlIGRlc3RpbmF0aW9uIGFycmF5cyB3aXRoIHNvdXJjZSBhcnJheXMsIGlmIHByZXNlbnRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vVGVoU2hyaWtlL2RlZXBtZXJnZSNhcnJheW1lcmdlLWV4YW1wbGUtb3ZlcndyaXRlLXRhcmdldC1hcnJheVxuICAgIGFycmF5TWVyZ2U6IChfZGVzdGluYXRpb25BcnJheSwgc291cmNlQXJyYXkpID0+IHNvdXJjZUFycmF5XG4gIH0pO1xuXG4gIC8vIGlmIGNlbnRlciBtYXBcbiAgLy8gY2VudGVyIG1hcCB3aWxsIG92ZXJyaWRlIG1hcFN0YXRlIGNvbmZpZ1xuICBpZiAob3B0aW9ucy5jZW50ZXJNYXAgJiYgYm91bmRzKSB7XG4gICAgbWVyZ2VkU3RhdGUgPSBmaXRCb3VuZHNVcGRhdGVyKG1lcmdlZFN0YXRlLCB7XG4gICAgICBwYXlsb2FkOiBib3VuZHNcbiAgICB9KTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSB2YWxpZGF0ZSBtYXAgc3RhdGUgYmVmb3JlIHdlIG1lcmdlXG4gIG1lcmdlZFN0YXRlID0gdmFsaWRhdGVWaWV3UG9ydChtZXJnZWRTdGF0ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5tZXJnZWRTdGF0ZSxcbiAgICAvLyB1cGRhdGUgd2lkdGggaWYgYGlzU3BsaXRgIGhhcyBjaGFuZ2VkXG4gICAgLi4uZ2V0TWFwRGltRm9yU3BsaXRNYXAobWVyZ2VkU3RhdGUuaXNTcGxpdCwgc3RhdGUpXG4gIH07XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBiZXR3ZWVuIG9uZSBvciBzcGxpdCBtYXBzXG4gKiBAbWVtYmVyb2YgbWFwU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlU3BsaXRNYXBVcGRhdGVyID0gKHN0YXRlOiBNYXBTdGF0ZSk6IE1hcFN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAuLi5nZXRNYXBEaW1Gb3JTcGxpdE1hcCghc3RhdGUuaXNTcGxpdCwgc3RhdGUpLFxuICBpc1NwbGl0OiAhc3RhdGUuaXNTcGxpdCxcbiAgLi4uKCFzdGF0ZS5pc1NwbGl0ID09PSBmYWxzZVxuICAgID8ge1xuICAgICAgICAvLyBpZiB0b2dnbGluZyB0byBubyBsb25nZXIgc3BsaXQgKHNpbmdsZSBtb2RlKSB0aGVuIHJlc2V0IGEgZmV3IHByb3BlcnRpZXNcbiAgICAgICAgaXNWaWV3cG9ydFN5bmNlZDogdHJ1ZSxcbiAgICAgICAgaXNab29tTG9ja2VkOiBmYWxzZSxcbiAgICAgICAgc3BsaXRNYXBWaWV3cG9ydHM6IFtdXG4gICAgICB9XG4gICAgOiB7fSlcbn0pO1xuXG4vKipcbiAqIFRvZ2dsZSBiZXR3ZWVuIGxvY2tlZCBhbmQgdW5sb2NrZWQgc3BsaXQgdmlld3BvcnRzXG4gKiBAbWVtYmVyb2YgbWFwU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlU3BsaXRNYXBWaWV3cG9ydFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdGF0ZSxcbiAgYWN0aW9uOiBNYXBTdGF0ZUFjdGlvbnMuVG9nZ2xlU3BsaXRNYXBWaWV3cG9ydFVwZGF0ZXJBY3Rpb25cbikgPT4ge1xuICAvLyBuZXcgbWFwIHN0YXRlIGltbWVkaWF0ZWx5IGdldHMgdGhlIG5ldywgb3B0aW9uYWwgcGF5bG9hZCB2YWx1ZXMgZm9yIGlzVmlld3BvcnRTeW5jZWQgYW5kL29yIGlzWm9vbUxvY2tlZFxuICBjb25zdCBuZXdNYXBTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICAuLi4oYWN0aW9uLnBheWxvYWQgfHwge30pXG4gIH07XG5cbiAgaWYgKG5ld01hcFN0YXRlLmlzVmlld3BvcnRTeW5jZWQpIHtcbiAgICAvLyBzd2l0Y2hpbmcgZnJvbSB1bnN5bmNlZCB0byBzeW5jZWQgdmlld3BvcnRzXG4gICAgbmV3TWFwU3RhdGUuc3BsaXRNYXBWaWV3cG9ydHMgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzd2l0Y2hpbmcgZnJvbSBzeW5jZWQgdG8gdW5zeW5jZWQgdmlld3BvcnRzXG4gICAgLy8gb3IgYWxyZWFkeSBpbiB1bnN5bmNlZCBtb2RlIGFuZCB0b2dnbGluZyBsb2NrZWQgem9vbVxuXG4gICAgaWYgKHN0YXRlLmlzWm9vbUxvY2tlZCAmJiAhbmV3TWFwU3RhdGUuaXNab29tTG9ja2VkKSB7XG4gICAgICAvLyBzd2l0Y2hpbmcgb2ZmIGxvY2tlZCB6b29tIHdoaWxlIHVuc3luY2VkXG4gICAgICAvLyBkb24ndCBjb3B5IHRoZSBtYXBTdGF0ZXMgdG8gbGVmdCBhbmQgcmlnaHQgdmlld3BvcnRzIGJlY2F1c2UgdGhlcmUgd2lsbCBiZSB6b29tIFwianVtcGluZ1wiXG4gICAgICByZXR1cm4gbmV3TWFwU3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5pc1pvb21Mb2NrZWQgJiYgbmV3TWFwU3RhdGUuaXNab29tTG9ja2VkKSB7XG4gICAgICAvLyBzd2l0Y2hpbmcgb24gbG9ja2VkIHpvb20gd2hpbGUgdW5zeW5jZWRcbiAgICAgIC8vIG9ubHkgY29weSB6b29tIHZpZXdwb3J0IHByb3BlcnR5IGZyb20gdGhlIG1vc3QgcmVjZW50bHkgaW50ZXJhY3RlZC13aXRoIHZpZXdwb3J0IHRvIHRoZSBvdGhlclxuICAgICAgLy8gVE9ETzogZG8gd2Ugd2FudCB0byBjaGVjayBmb3IgYSBtYXRjaCBhIGRpZmZlcmVudCB3YXksIHN1Y2ggYXMgYSBjb21ibyBvZiBgbGF0aXR1ZGVgIGFuZCBgbG9uZ2l0dWRlYD9cbiAgICAgIGNvbnN0IGxhc3RVcGRhdGVkVmlld3BvcnRJbmRleCA9IG5ld01hcFN0YXRlLnNwbGl0TWFwVmlld3BvcnRzLmZpbmRJbmRleChcbiAgICAgICAgdiA9PiBuZXdNYXBTdGF0ZS56b29tID09PSB2Lnpvb21cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNwbGl0TWFwVmlld3BvcnRzID0gbmV3TWFwU3RhdGUuc3BsaXRNYXBWaWV3cG9ydHMubWFwKChjdXJyZW50Vmlld3BvcnQsIGkpID0+IHtcbiAgICAgICAgaWYgKGkgPT09IGxhc3RVcGRhdGVkVmlld3BvcnRJbmRleCkge1xuICAgICAgICAgIC8vIG5vIHpvb20gdG8gbW9kaWZ5IGhlcmVcbiAgICAgICAgICByZXR1cm4gY3VycmVudFZpZXdwb3J0O1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBvdGhlciB2aWV3cG9ydCBnZXRzIHRoZSBtb3N0IHJlY2VudGx5IGludGVyYWN0ZWQtd2l0aCB2aWV3cG9ydCdzIHpvb21cbiAgICAgICAgLy8gV0hZPyB0aGUgdmlld3BvcnQgdGhlIHVzZXIgd2FzIGxhc3QgaW50ZXJhY3Rpbmcgd2l0aCB3aWxsIHNldCB6b29tIGFjcm9zcyB0aGUgYm9hcmQgZm9yIHNtb290aCBVWFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmN1cnJlbnRWaWV3cG9ydCxcbiAgICAgICAgICB6b29tOiBuZXdNYXBTdGF0ZS5zcGxpdE1hcFZpZXdwb3J0c1tsYXN0VXBkYXRlZFZpZXdwb3J0SW5kZXhdLnpvb21cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICBuZXdNYXBTdGF0ZS5zcGxpdE1hcFZpZXdwb3J0cyA9IHNwbGl0TWFwVmlld3BvcnRzO1xuXG4gICAgICByZXR1cm4gbmV3TWFwU3RhdGU7XG4gICAgfVxuXG4gICAgLy8gaWYgY3VycmVudCB2aWV3cG9ydCBpcyBzeW5jZWQsIGFuZCB3ZSBhcmUgdW5zeW5jaW5nIGl0XG4gICAgLy8gb3IgYWxyZWFkeSBpbiB1bnN5bmNlZCBtb2RlIGFuZCBOT1QgdG9nZ2xpbmcgbG9ja2VkIHpvb21cbiAgICAvLyBtYWtlIGEgZnJlc2ggY29weSBvZiB0aGUgY3VycmVudCB2aWV3cG9ydCBvYmplY3QsIGFzc2lnbiBpdCB0byBzcGxpdE1hcFZpZXdwb3J0c1tdXG4gICAgLy8gcGlja1ZpZXdwb3J0UHJvcHNGcm9tTWFwU3RhdGUgaXMgY2FsbGVkIHR3aWNlIHRvIGF2b2lkIG1lbW9yeSBhbGxvY2F0aW9uIGNvbmZsaWN0c1xuICAgIGNvbnN0IGxlZnRWaWV3cG9ydCA9IHBpY2tWaWV3cG9ydFByb3BzRnJvbU1hcFN0YXRlKG5ld01hcFN0YXRlKTtcbiAgICBjb25zdCByaWdodFZpZXdwb3J0ID0gcGlja1ZpZXdwb3J0UHJvcHNGcm9tTWFwU3RhdGUobmV3TWFwU3RhdGUpO1xuICAgIG5ld01hcFN0YXRlLnNwbGl0TWFwVmlld3BvcnRzID0gW2xlZnRWaWV3cG9ydCwgcmlnaHRWaWV3cG9ydF07XG4gIH1cblxuICAvLyByZXR1cm4gbmV3IHN0YXRlXG4gIHJldHVybiBuZXdNYXBTdGF0ZTtcbn07XG5cbi8vIEhlbHBlcnNcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBEaW1Gb3JTcGxpdE1hcChpc1NwbGl0LCBzdGF0ZSkge1xuICAvLyBjYXNlczpcbiAgLy8gMS4gc3RhdGUgc3BsaXQ6IHRydWUgLSBpc1NwbGl0OiB0cnVlXG4gIC8vIGRvIG5vdGhpbmdcbiAgLy8gMi4gc3RhdGUgc3BsaXQ6IGZhbHNlIC0gaXNTcGxpdDogZmFsc2VcbiAgLy8gZG8gbm90aGluZ1xuICBpZiAoc3RhdGUuaXNTcGxpdCA9PT0gaXNTcGxpdCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IHdpZHRoID1cbiAgICBzdGF0ZS5pc1NwbGl0ICYmICFpc1NwbGl0XG4gICAgICA/IC8vIDMuIHN0YXRlIHNwbGl0OiB0cnVlIC0gaXNTcGxpdDogZmFsc2VcbiAgICAgICAgLy8gZG91YmxlIHdpZHRoXG4gICAgICAgIHN0YXRlLndpZHRoICogMlxuICAgICAgOiAvLyA0LiBzdGF0ZSBzcGxpdDogZmFsc2UgLSBpc1NwbGl0OiB0cnVlXG4gICAgICAgIC8vIHNwbGl0IHdpZHRoXG4gICAgICAgIHN0YXRlLndpZHRoIC8gMjtcblxuICByZXR1cm4ge1xuICAgIHdpZHRoXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZpZXdwb3J0QmFzZWRPbkJvdW5kcyhzdGF0ZTogTWFwU3RhdGUsIG5ld01hcFN0YXRlOiBNYXBTdGF0ZSkge1xuICAvLyBHZXQgdGhlIG5ldyB2aWV3cG9ydCBib3VuZHNcbiAgY29uc3Qgdmlld3BvcnRCb3VuZHMgPSBnZW9WaWV3cG9ydC5ib3VuZHMoXG4gICAgW25ld01hcFN0YXRlLmxvbmdpdHVkZSwgbmV3TWFwU3RhdGUubGF0aXR1ZGVdLFxuICAgIG5ld01hcFN0YXRlLnpvb20sXG4gICAgW25ld01hcFN0YXRlLndpZHRoLCBuZXdNYXBTdGF0ZS5oZWlnaHRdLFxuICAgIE1BUEJPWF9USUxFX1NJWkVcbiAgKTtcbiAgLy8gR2VuZXJhdGUgdHVyZiBQb2x5Z29uIGZyb20gYm91bmRzIGZvciBjb21wYXJpc29uXG4gIGNvbnN0IHZpZXdwb3J0Qm91bmRzUG9seWdvbiA9IGJib3hQb2x5Z29uKHZpZXdwb3J0Qm91bmRzKTtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBuZXdTdGF0ZU1heEJvdW5kczogQm91bmRzID0gbmV3TWFwU3RhdGUubWF4Qm91bmRzO1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG1heEJvdW5kc1BvbHlnb24gPSBiYm94UG9seWdvbihuZXdTdGF0ZU1heEJvdW5kcyk7XG5cbiAgLy8gSWYgbWF4Qm91bmRzIGhhcyBjaGFuZ2VkIHJlc2V0IHRoZSB2aWV3cG9ydCB0byBzbmFwIHRvIGJvdW5kc1xuICBjb25zdCBoYXNNYXhCb3VuZHNDaGFuZ2VkID1cbiAgICAhc3RhdGUubWF4Qm91bmRzIHx8ICFzdGF0ZS5tYXhCb3VuZHMuZXZlcnkoKHZhbCwgaWR4KSA9PiB2YWwgPT09IG5ld1N0YXRlTWF4Qm91bmRzW2lkeF0pO1xuICBpZiAoaGFzTWF4Qm91bmRzQ2hhbmdlZCkge1xuICAgIC8vIENoZWNrIGlmIHRoZSBuZXdNYXBTdGF0ZSB2aWV3cG9ydCBpcyB3aXRoaW4gbWF4Qm91bmRzXG4gICAgaWYgKCFib29sZWFuV2l0aGluKHZpZXdwb3J0Qm91bmRzUG9seWdvbiwgbWF4Qm91bmRzUG9seWdvbikpIHtcbiAgICAgIC8vIFZhbGlkYXRlIGJvdW5kcyB0byBwcmV2ZW50IHByb2plY3Rpb24gbWF0cml4IGVycm9ycyB3aXRoIG1heGltdW0gZXh0ZW50c1xuICAgICAgLy8gVGhpcyBlbnN1cmVzIGJvdW5kcyBhcmUgd2l0aGluIHZhbGlkIG1lcmNhdG9yIHByb2plY3Rpb24gbGltaXRzXG4gICAgICBjb25zdCB2YWxpZGF0ZWRCb3VuZHMgPSBbXG4gICAgICAgIE1hdGgubWF4KG5ld1N0YXRlTWF4Qm91bmRzWzBdLCBNSU5fTE9OR0lUVURFKSxcbiAgICAgICAgTWF0aC5tYXgobmV3U3RhdGVNYXhCb3VuZHNbMV0sIE1JTl9MQVRJVFVERSksXG4gICAgICAgIE1hdGgubWluKG5ld1N0YXRlTWF4Qm91bmRzWzJdLCBNQVhfTE9OR0lUVURFKSxcbiAgICAgICAgTWF0aC5taW4obmV3U3RhdGVNYXhCb3VuZHNbM10sIE1BWF9MQVRJVFVERSlcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tfSA9IGZpdEJvdW5kcyh7XG4gICAgICAgIHdpZHRoOiBuZXdNYXBTdGF0ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBuZXdNYXBTdGF0ZS5oZWlnaHQsXG4gICAgICAgIGJvdW5kczogW1xuICAgICAgICAgIFt2YWxpZGF0ZWRCb3VuZHNbMF0sIHZhbGlkYXRlZEJvdW5kc1sxXV0sXG4gICAgICAgICAgW3ZhbGlkYXRlZEJvdW5kc1syXSwgdmFsaWRhdGVkQm91bmRzWzNdXVxuICAgICAgICBdXG4gICAgICB9KTtcblxuICAgICAgbmV3TWFwU3RhdGUgPSB7XG4gICAgICAgIC4uLm5ld01hcFN0YXRlLFxuICAgICAgICBsYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlLFxuICAgICAgICAvLyBGb3IgbWFyZ2luYWwgb3IgaW52YWxpZCBib3VuZHMsIHpvb20gbWF5IGJlIE5hTi4gTWFrZSBzdXJlIHRvIHByb3ZpZGUgYSB2YWxpZCB2YWx1ZSBpbiBvcmRlclxuICAgICAgICAvLyB0byBhdm9pZCBjb3JydXB0IHN0YXRlIGFuZCBwb3RlbnRpYWwgY3Jhc2hlcyBhcyB6b29tIGlzIGV4cGVjdGVkIHRvIGJlIGEgbnVtYmVyXG4gICAgICAgIC4uLihOdW1iZXIuaXNGaW5pdGUoem9vbSkgPyB7em9vbX0gOiB7fSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXBTdGF0ZTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZSBuZXdNYXBTdGF0ZSB2aWV3cG9ydCBpcyB3aXRoaW4gbWF4Qm91bmRzXG4gIGlmICghYm9vbGVhbldpdGhpbih2aWV3cG9ydEJvdW5kc1BvbHlnb24sIG1heEJvdW5kc1BvbHlnb24pKSB7XG4gICAgbmV3TWFwU3RhdGUgPSB7XG4gICAgICAuLi5uZXdNYXBTdGF0ZSxcbiAgICAgIGxvbmdpdHVkZTogc3RhdGUubG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGU6IHN0YXRlLmxhdGl0dWRlLFxuICAgICAgem9vbTogc3RhdGUuem9vbVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbmV3TWFwU3RhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrVmlld3BvcnRQcm9wc0Zyb21NYXBTdGF0ZShzdGF0ZTogTWFwU3RhdGUpOiBWaWV3cG9ydCB7XG4gIHJldHVybiBwaWNrKHN0YXRlLCBbXG4gICAgJ3dpZHRoJyxcbiAgICAnaGVpZ2h0JyxcbiAgICAnem9vbScsXG4gICAgJ3BpdGNoJyxcbiAgICAnYmVhcmluZycsXG4gICAgJ2xhdGl0dWRlJyxcbiAgICAnbG9uZ2l0dWRlJyxcbiAgICAnZHJhZ1JvdGF0ZScsXG4gICAgJ21pblpvb20nLFxuICAgICdtYXhab29tJyxcbiAgICAnbWF4Qm91bmRzJ1xuICBdKTtcbn1cblxuLyoqIFNlbGVjdCBpdGVtcyBmcm9tIG9iamVjdCB3aG9zZSB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkICovXG5jb25zdCBkZWZpbmVkUHJvcHMgPSBvYmogPT5cbiAgT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoXG4gICAgKGFjY3UsIFtrLCB2XSkgPT4gKHsuLi5hY2N1LCAuLi4odiAhPT0gdW5kZWZpbmVkID8ge1trXTogdn0gOiB7fSl9KSxcbiAgICB7fVxuICApO1xuXG5mdW5jdGlvbiB1cGRhdGVWaWV3cG9ydChvcmlnaW5hbFZpZXdwb3J0OiBWaWV3cG9ydCwgdmlld3BvcnRVcGRhdGVzOiBWaWV3cG9ydCk6IFZpZXdwb3J0IHtcbiAgbGV0IG5ld1ZpZXdwb3J0ID0ge1xuICAgIC4uLm9yaWdpbmFsVmlld3BvcnQsXG4gICAgLi4uKGRlZmluZWRQcm9wcyh2aWV3cG9ydFVwZGF0ZXMpIHx8IHt9KVxuICB9O1xuXG4gIC8vIE1ha2Ugc3VyZSB6b29tIGxldmVsIGRvZXNuJ3QgZ28gYmVsbG93IG1pblpvb20gaWYgZGVmaW5lZFxuICBpZiAobmV3Vmlld3BvcnQubWluWm9vbSAmJiBuZXdWaWV3cG9ydC56b29tICYmIG5ld1ZpZXdwb3J0Lnpvb20gPCBuZXdWaWV3cG9ydC5taW5ab29tKSB7XG4gICAgbmV3Vmlld3BvcnQuem9vbSA9IG5ld1ZpZXdwb3J0Lm1pblpvb207XG4gIH1cbiAgLy8gTWFrZSBzdXJlIHpvb20gbGV2ZWwgZG9lc24ndCBnbyBhYm92ZSBtYXhab29tIGlmIGRlZmluZWRcbiAgaWYgKG5ld1ZpZXdwb3J0Lm1heFpvb20gJiYgbmV3Vmlld3BvcnQuem9vbSAmJiBuZXdWaWV3cG9ydC56b29tID4gbmV3Vmlld3BvcnQubWF4Wm9vbSkge1xuICAgIG5ld1ZpZXdwb3J0Lnpvb20gPSBuZXdWaWV3cG9ydC5tYXhab29tO1xuICB9XG4gIC8vIExpbWl0IHZpZXdwb3J0IHVwZGF0ZSBiYXNlZCBvbiBtYXhCb3VuZHNcbiAgaWYgKG5ld1ZpZXdwb3J0Lm1heEJvdW5kcyAmJiB2YWxpZGF0ZUJvdW5kcyhuZXdWaWV3cG9ydC5tYXhCb3VuZHMpKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUeXBlICdWaWV3cG9ydCcgaXMgbWlzc2luZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgZnJvbSB0eXBlICdNYXBTdGF0ZSc6IGlzU3BsaXQsIGlzVmlld3BvcnRTeW5jZWQsIGlzWm9vbUxvY2tlZCwgc3BsaXRNYXBWaWV3cG9ydHNcbiAgICBuZXdWaWV3cG9ydCA9IHVwZGF0ZVZpZXdwb3J0QmFzZWRPbkJvdW5kcyhvcmlnaW5hbFZpZXdwb3J0LCBuZXdWaWV3cG9ydCk7XG4gIH1cblxuICByZXR1cm4gbmV3Vmlld3BvcnQ7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUdBLElBQUFBLFlBQUEsR0FBQUMsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFDLGNBQUEsR0FBQUYsc0JBQUEsQ0FBQUMs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