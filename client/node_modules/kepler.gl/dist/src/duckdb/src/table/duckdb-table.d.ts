import * as arrow from 'apache-arrow';
import { KeplerTable } from '@kepler.gl/table';
import { DatabaseAdapter, DatabaseConnection } from '@kepler.gl/utils';
import { ProcessorResult } from '../processors/data-processor';
declare type ImportDataToDuckProps = {
    data: ProcessorResult & {
        arrowSchema: arrow.Schema;
    };
    db: DatabaseAdapter;
    c: DatabaseConnection;
};
declare type ImportDataToDuckResult = {
    geoarrowMetadata?: Record<string, string>;
    useNewFields?: boolean;
};
export declare class KeplerGlDuckDbTable extends KeplerTable {
    readonly id: string;
    label: string;
    type: string;
    metadata: Record<string, any>;
    constructor(props: any);
    importRowData({ data, db, c }: ImportDataToDuckProps): Promise<void>;
    importGeoJsonData({ data, db, c }: ImportDataToDuckProps): Promise<ImportDataToDuckResult>;
    importArrowData({ data, c }: ImportDataToDuckProps): Promise<ImportDataToDuckResult>;
    /**
     * Creates a table from data, returns an arrow table with the data
     * @param data
     * @returns {Promise<{fields: Field[], cols: any[]}>}
     */
    protected createTableAndGetArrow(data: any): Promise<{
        fields: any[];
        cols: arrow.Vector[];
    }>;
    importData({ data }: {
        data: ProcessorResult;
    }): Promise<void>;
    update(data: any): Promise<this>;
    static getFileProcessor: (data: any, inputFormat?: string) => {
        processor: any;
        format: any;
    };
    static getInputDataValidator: () => (d: any) => any;
}
/**
 * Try to restore geoarrow metadata lost during DuckDb ingestion.
 * Note that this function can generate wrong geometry types.
 * @param arrowTable Arrow table to update.
 * @param geoarrowMetadata A map with field names that usually used to store geoarrow geometry.
 */
export declare const restoreGeoarrowMetadata: (arrowTable: arrow.Table, geoarrowMetadata: Record<string, string>) => void;
export {};
