/// <reference types="react" />
import { VisState } from '@kepler.gl/schemas';
import { Dispatch } from 'redux';
import { AiAssistantState } from '../reducers';
export declare function setupLLMTools({ visState, aiAssistant, dispatch }: {
    visState: VisState;
    aiAssistant: AiAssistantState;
    dispatch: Dispatch;
}): {
    filterDataset: import("@openassistant/utils").ExtendedTool<import("@openassistant/duckdb").LocalQueryArgs, import("@openassistant/duckdb").LocalQueryResult, import("@openassistant/duckdb").LocalQueryAdditionalData, import("@openassistant/duckdb").LocalQueryContext>;
    genericQuery: import("@openassistant/utils").ExtendedTool<import("@openassistant/duckdb").LocalQueryArgs, import("@openassistant/duckdb").LocalQueryResult, import("@openassistant/duckdb").LocalQueryAdditionalData, import("@openassistant/duckdb").LocalQueryContext>;
    tableTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/duckdb").LocalQueryArgs, import("@openassistant/duckdb").LocalQueryResult, import("@openassistant/duckdb").LocalQueryAdditionalData, import("@openassistant/duckdb").LocalQueryContext>;
    mergeTablesTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/duckdb").MergeTablesArgs, import("@openassistant/duckdb").MergeTablesLllmResult, import("@openassistant/duckdb").MergeTablesAdditionalData, import("@openassistant/duckdb").LocalQueryContext>;
    classifyTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").DataClassifyFunctionArgs, import("@openassistant/geoda").DataClassifyLlmResult, import("@openassistant/geoda").DataClassifyAdditionalData, import("@openassistant/geoda").DataClassifyFunctionContext>;
    weightsTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").SpatialWeightsFunctionArgs, import("@openassistant/geoda").SpatialWeightsLlmResult, import("@openassistant/geoda").SpatialWeightsAdditionalData, import("@openassistant/geoda").SpatialWeightsFunctionContext>;
    globalMoranTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").MoranScatterPlotFunctionArgs, import("@openassistant/geoda").MoranScatterPlotLlmResult, import("@openassistant/geoda").MoranScatterPlotAdditionalData, import("@openassistant/geoda").MoranScatterPlotFunctionContext>;
    regressionTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").SpatialRegressionFunctionArgs, import("@openassistant/geoda").SpatialRegressionLlmResult, import("@openassistant/geoda").SpatialRegressionAdditionalData, import("@openassistant/geoda").SpatialRegressionFunctionContext>;
    lisaTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").LisaFunctionArgs, import("@openassistant/geoda").LisaLlmResult, import("@openassistant/geoda").LisaAdditionalData, import("@openassistant/geoda").LisaFunctionContext>;
    spatialJoinTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").SpatialJoinFunctionArgs, import("@openassistant/geoda").SpatialJoinLlmResult, import("@openassistant/geoda").SpatialJoinAdditionalData, import("@openassistant/geoda").SpatialJoinFunctionContext>;
    spatialFilterTool: {
        context: {
            getValues: (datasetName: string, variableName: string) => Promise<number[]>;
            getGeometries: (datasetName: string) => Promise<import("@geoda/core").SpatialGeometry>;
        };
        onToolCompleted: (toolName: string, result: unknown) => void;
        component: typeof import("@openassistant/tables").SpatialJoinComponent;
        description: string;
        parameters: import("@openassistant/geoda").SpatialJoinFunctionArgs;
        execute: import("@openassistant/utils").ExecuteFunction<import("@openassistant/geoda").SpatialJoinFunctionArgs, import("@openassistant/geoda").SpatialJoinLlmResult, import("@openassistant/geoda").SpatialJoinAdditionalData, import("@openassistant/geoda").SpatialJoinFunctionContext>;
    };
    gridTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").GridFunctionArgs, import("@openassistant/geoda").GridLlmResult, import("@openassistant/geoda").GridAdditionalData, import("@openassistant/geoda").SpatialToolContext>;
    bufferTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").BufferFunctionArgs, import("@openassistant/geoda").BufferLlmResult, import("@openassistant/geoda").BufferAdditionalData, import("@openassistant/geoda").SpatialToolContext>;
    centroidTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").CentroidFunctionArgs, import("@openassistant/geoda").CentroidLlmResult, import("@openassistant/geoda").CentroidAdditionalData, import("@openassistant/geoda").SpatialToolContext>;
    dissolveTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").DissolveFunctionArgs, import("@openassistant/geoda").DissolveLlmResult, import("@openassistant/geoda").DissolveAdditionalData, import("@openassistant/geoda").SpatialToolContext>;
    lengthTool: {
        context: {
            getGeometries: (datasetName: string) => Promise<import("@geoda/core").SpatialGeometry>;
        };
        description: string;
        parameters: import("zod").ZodObject<{
            geojson: import("zod").ZodOptional<import("zod").ZodString>;
            datasetName: import("zod").ZodOptional<import("zod").ZodString>;
            distanceUnit: import("zod").ZodDefault<import("zod").ZodEnum<["KM", "Mile"]>>;
        }, "strip", import("zod").ZodTypeAny, {
            distanceUnit: "KM" | "Mile";
            datasetName?: string | undefined;
            geojson?: string | undefined;
        }, {
            datasetName?: string | undefined;
            geojson?: string | undefined;
            distanceUnit?: "KM" | "Mile" | undefined;
        }>;
        execute: import("@openassistant/utils").ExecuteFunction<import("zod").ZodObject<{
            geojson: import("zod").ZodOptional<import("zod").ZodString>;
            datasetName: import("zod").ZodOptional<import("zod").ZodString>;
            distanceUnit: import("zod").ZodDefault<import("zod").ZodEnum<["KM", "Mile"]>>;
        }, "strip", import("zod").ZodTypeAny, {
            distanceUnit: "KM" | "Mile";
            datasetName?: string | undefined;
            geojson?: string | undefined;
        }, {
            datasetName?: string | undefined;
            geojson?: string | undefined;
            distanceUnit?: "KM" | "Mile" | undefined;
        }>, {
            success: boolean;
            result: string;
            lengths: number[];
            distanceUnit: "KM" | "Mile";
        }, never, {
            getGeometries: () => void;
        }>;
        component?: import("react").ElementType<any, keyof import("react").JSX.IntrinsicElements> | undefined;
        onToolCompleted?: import("@openassistant/utils").OnToolCompleted | undefined;
    };
    areaTool: {
        context: {
            getGeometries: (datasetName: string) => Promise<import("@geoda/core").SpatialGeometry>;
        };
        description: string;
        parameters: import("@openassistant/geoda").AreaFunctionArgs;
        execute: import("@openassistant/utils").ExecuteFunction<import("@openassistant/geoda").AreaFunctionArgs, import("@openassistant/geoda").AreaLlmResult, import("@openassistant/geoda").AreaAdditionalData, import("@openassistant/geoda").SpatialToolContext>;
        component?: import("react").ElementType<any, keyof import("react").JSX.IntrinsicElements> | undefined;
        onToolCompleted?: import("@openassistant/utils").OnToolCompleted | undefined;
    };
    perimeterTool: {
        context: {
            getGeometries: (datasetName: string) => Promise<import("@geoda/core").SpatialGeometry>;
        };
        description: string;
        parameters: import("@openassistant/geoda").PerimeterFunctionArgs;
        execute: import("@openassistant/utils").ExecuteFunction<import("@openassistant/geoda").PerimeterFunctionArgs, import("@openassistant/geoda").PerimeterLlmResult, import("@openassistant/geoda").PerimeterAdditionalData, import("@openassistant/geoda").SpatialToolContext>;
        component?: import("react").ElementType<any, keyof import("react").JSX.IntrinsicElements> | undefined;
        onToolCompleted?: import("@openassistant/utils").OnToolCompleted | undefined;
    };
    getUsStateTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/osm").GetUsStateGeojsonFunctionArgs, import("@openassistant/osm").GetUsStateGeojsonLlmResult, import("@openassistant/osm").GetUsStateGeojsonAdditionalData, object>;
    getUsCountyTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/osm").GetUsCountyGeojsonFunctionArgs, import("@openassistant/osm").GetUsCountyGeojsonLlmResult, import("@openassistant/osm").GetUsCountyGeojsonAdditionalData, object>;
    getUsZipcodeTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/osm").GetUsZipcodeGeojsonFunctionArgs, import("@openassistant/osm").GetUsZipcodeGeojsonLlmResult, import("@openassistant/osm").GetUsZipcodeGeojsonAdditionalData, object>;
    queryUSZipcodes: import("@openassistant/utils").ExtendedTool<import("@openassistant/osm").QueryZipcodeFunctionArgs, import("@openassistant/osm").QueryZipcodeLlmResult, import("@openassistant/osm").QueryZipcodeAdditionalData, object>;
    geocoding: import("@openassistant/utils").ExtendedTool<import("@openassistant/osm").GeocodingFunctionArgs, import("@openassistant/osm").GeocodingLlmResult, import("@openassistant/osm").GeocodingAdditionalData, object>;
    routing: import("@openassistant/utils").ExtendedTool<import("@openassistant/osm").RoutingFunctionArgs, import("@openassistant/osm").RoutingLlmResult, import("@openassistant/osm").RoutingAdditionalData, import("@openassistant/osm").MapboxToolContext>;
    isochrone: import("@openassistant/utils").ExtendedTool<import("@openassistant/osm").IsochroneFunctionArgs, import("@openassistant/osm").IsochroneLlmResult, import("@openassistant/osm").IsochroneAdditionalData, import("@openassistant/osm").MapboxToolContext>;
    roads: {
        context: {
            getGeometries: (datasetName: string) => Promise<import("@geoda/core").SpatialGeometry>;
        };
        onToolCompleted: (toolName: string, result: unknown) => void;
        description: string;
        parameters: import("@openassistant/osm").RoadsFunctionArgs;
        execute: import("@openassistant/utils").ExecuteFunction<import("@openassistant/osm").RoadsFunctionArgs, import("@openassistant/osm").RoadsLlmResult, import("@openassistant/osm").RoadsAdditionalData, import("@openassistant/osm").OsmToolContext>;
        component?: import("react").ElementType<any, keyof import("react").JSX.IntrinsicElements> | undefined;
    };
    standardizeVariable: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").StandardizeVariableToolArgs, import("@openassistant/geoda").StandardizeVariableToolLlmResult, import("@openassistant/geoda").StandardizeVariableToolAdditionalData, import("@openassistant/geoda").StandardizeVariableToolContext>;
    thiessenPolygons: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").ThiessenPolygonsArgs, import("@openassistant/geoda").ThiessenPolygonsLlmResult, import("@openassistant/geoda").ThiessenPolygonsAdditionalData, import("@openassistant/geoda").SpatialToolContext>;
    minimumSpanningTree: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").MinimumSpanningTreeArgs, import("@openassistant/geoda").MinimumSpanningTreeLlmResult, import("@openassistant/geoda").MinimumSpanningTreeAdditionalData, import("@openassistant/geoda").SpatialToolContext>;
    cartogram: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").CartogramFunctionArgs, import("@openassistant/geoda").CartogramLlmResult, import("@openassistant/geoda").CartogramAdditionalData, import("@openassistant/geoda").SpatialToolContext>;
    rate: import("@openassistant/utils").ExtendedTool<import("@openassistant/geoda").RateFunctionArgs, import("@openassistant/geoda").RateLlmResult, import("@openassistant/geoda").RateAdditionalData, import("@openassistant/geoda").RateContext>;
    boxplotTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/plots").BoxplotToolArgs, import("@openassistant/plots").BoxplotLlmResult, import("@openassistant/plots").BoxplotAdditionalData, import("@openassistant/plots").EChartsToolContext>;
    bubbleChartTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/plots").BubbleChartToolArgs, import("@openassistant/plots").BubbleChartLlmResult, import("@openassistant/plots").BubbleChartAdditionalData, import("@openassistant/plots").EChartsToolContext>;
    histogramTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/plots").HistogramToolArgs, import("@openassistant/plots").HistogramLlmResult, import("@openassistant/plots").HistogramAdditionalData, import("@openassistant/plots").EChartsToolContext>;
    pcpTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/plots").PCPFunctionArgs, import("@openassistant/plots").PCPLlmResult, import("@openassistant/plots").PCPAdditionalData, import("@openassistant/plots").EChartsToolContext>;
    scatterplotTool: import("@openassistant/utils").ExtendedTool<import("@openassistant/plots").ScatterplotFunctionArgs, import("@openassistant/plots").ScatterplotLlmResult, import("@openassistant/plots").ScatterplotAdditionalData, import("@openassistant/plots").EChartsToolContext>;
    basemap: import("@openassistant/utils").ExtendedTool<import("zod").ZodObject<{
        styleType: import("zod").ZodEnum<["no_map", "dark-matter", "positron", "voyager", "satellite", "dark", "light", "muted", "muted_night"]>;
    }, "strip", import("zod").ZodTypeAny, {
        styleType: "no_map" | "dark-matter" | "positron" | "voyager" | "satellite" | "dark" | "light" | "muted" | "muted_night";
    }, {
        styleType: "no_map" | "dark-matter" | "positron" | "voyager" | "satellite" | "dark" | "light" | "muted" | "muted_night";
    }>, {
        success: boolean;
        styleType: string;
        details?: string | undefined;
        instruction?: string | undefined;
    }, {
        styleType: string;
    }, never>;
    addLayer: import("@openassistant/utils").ExtendedTool<import("zod").ZodObject<{
        datasetName: import("zod").ZodString;
        latitudeColumn: import("zod").ZodOptional<import("zod").ZodString>;
        longitudeColumn: import("zod").ZodOptional<import("zod").ZodString>;
        layerType: import("zod").ZodEnum<["point", "arc", "line", "grid", "hexagon", "geojson", "cluster", "heatmap", "h3", "trip", "s2"]>;
        colorBy: import("zod").ZodOptional<import("zod").ZodString>;
        colorType: import("zod").ZodOptional<import("zod").ZodEnum<["breaks", "unique"]>>;
        colorMap: import("zod").ZodOptional<import("zod").ZodArray<import("zod").ZodObject<{
            value: import("zod").ZodUnion<[import("zod").ZodString, import("zod").ZodNumber, import("zod").ZodNull]>;
            color: import("zod").ZodString;
        }, import("zod").UnknownKeysParam, import("zod").ZodTypeAny, {
            color: string;
            value: string | number | null;
        }, {
            color: string;
            value: string | number | null;
        }>, "many">>;
    }, import("zod").UnknownKeysParam, import("zod").ZodTypeAny, {
        datasetName: string;
        layerType: "grid" | "h3" | "line" | "geojson" | "point" | "arc" | "hexagon" | "cluster" | "heatmap" | "trip" | "s2";
        latitudeColumn?: string | undefined;
        longitudeColumn?: string | undefined;
        colorBy?: string | undefined;
        colorType?: "breaks" | "unique" | undefined;
        colorMap?: {
            color: string;
            value: string | number | null;
        }[] | undefined;
    }, {
        datasetName: string;
        layerType: "grid" | "h3" | "line" | "geojson" | "point" | "arc" | "hexagon" | "cluster" | "heatmap" | "trip" | "s2";
        latitudeColumn?: string | undefined;
        longitudeColumn?: string | undefined;
        colorBy?: string | undefined;
        colorType?: "breaks" | "unique" | undefined;
        colorMap?: {
            color: string;
            value: string | number | null;
        }[] | undefined;
    }>, {
        success: boolean;
        layer?: string | undefined;
        details?: string | undefined;
        error?: string | undefined;
        instruction?: string | undefined;
    }, {
        layer: object;
        datasetId: string;
    } | undefined, {
        getDatasets: () => import("@kepler.gl/table").Datasets;
    }>;
    updateLayerColor: {
        context: {
            getLayers: () => import("@kepler.gl/layers/dist/base-layer").default[];
        };
        description: string;
        parameters: import("zod").ZodObject<{
            layerId: import("zod").ZodString;
            numberOfColors: import("zod").ZodNumber;
            customColors: import("zod").ZodArray<import("zod").ZodString, "many">;
        }, "strip", import("zod").ZodTypeAny, {
            layerId: string;
            numberOfColors: number;
            customColors: string[];
        }, {
            layerId: string;
            numberOfColors: number;
            customColors: string[];
        }>;
        execute: import("@openassistant/utils").ExecuteFunction<import("zod").ZodObject<{
            layerId: import("zod").ZodString;
            numberOfColors: import("zod").ZodNumber;
            customColors: import("zod").ZodArray<import("zod").ZodString, "many">;
        }, "strip", import("zod").ZodTypeAny, {
            layerId: string;
            numberOfColors: number;
            customColors: string[];
        }, {
            layerId: string;
            numberOfColors: number;
            customColors: string[];
        }>, {
            success: boolean;
            details?: string | undefined;
            error?: string | undefined;
            instruction?: string | undefined;
        }, {
            layerId: string;
            layer: import("@kepler.gl/layers/dist/base-layer").default;
            newConfig: Partial<import("@kepler.gl/types").LayerBaseConfig>;
            channel: string;
            newVisConfig: Partial<import("@kepler.gl/types").LayerVisConfig>;
        }, {
            getLayers: () => never;
            layerVisualChannelConfigChange: () => never;
        }>;
        component?: import("react").ElementType<any, keyof import("react").JSX.IntrinsicElements> | undefined;
        onToolCompleted?: import("@openassistant/utils").OnToolCompleted | undefined;
    };
    loadData: import("@openassistant/utils").ExtendedTool<import("zod").ZodObject<{
        url: import("zod").ZodString;
    }, import("zod").UnknownKeysParam, import("zod").ZodTypeAny, {
        url: string;
    }, {
        url: string;
    }>, {
        success: boolean;
        url: string;
        details?: string | undefined;
        dataInfo?: object | undefined;
        instruction?: string | undefined;
    }, {
        parsedData: import("@kepler.gl/types").ProtoDataset[];
    } | undefined, {
        getLoaders: () => {
            loaders?: import("@loaders.gl/loader-utils").Loader<any, any, import("@loaders.gl/loader-utils").LoaderOptions>[] | undefined;
            loadOptions?: object | undefined;
        };
    }>;
    mapBoundary: {
        context: {
            getMapBoundary: () => {
                nw: [number, number];
                se: [number, number];
            } | undefined;
        };
        description: string;
        parameters: import("zod").ZodObject<{}, "strip", import("zod").ZodTypeAny, {}, {}>;
        execute: import("@openassistant/utils").ExecuteFunction<import("zod").ZodObject<{}, "strip", import("zod").ZodTypeAny, {}, {}>, {
            success: boolean;
            boundary: never;
            error?: undefined;
            instruction?: undefined;
        }, never, {
            getMapBoundary: () => never;
        }>;
        component?: import("react").ElementType<any, keyof import("react").JSX.IntrinsicElements> | undefined;
        onToolCompleted?: import("@openassistant/utils").OnToolCompleted | undefined;
    };
    saveDataToMap: import("@openassistant/utils").ExtendedTool<import("zod").ZodObject<{
        datasetNames: import("zod").ZodArray<import("zod").ZodString, "many">;
    }, "strip", import("zod").ZodTypeAny, {
        datasetNames: string[];
    }, {
        datasetNames: string[];
    }>, {
        success: boolean;
        savedDatasetName: string;
        details: string;
    }, {
        parsedData: import("@kepler.gl/processors").FileCacheItem[];
    }, never>;
};
