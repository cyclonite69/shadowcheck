"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connect = void 0;
var _lib = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/node_modules/react-redux/lib");
var _withLocalSelector = _interopRequireDefault(require("./with-local-selector"));
// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project

// eslint-disable-next-line @typescript-eslint/no-unused-vars
var defaultMapStateToProps = function defaultMapStateToProps(state, _, __) {
  return state;
};
// eslint-disable-next-line @typescript-eslint/no-unused-vars
var defaultMapDispatchToProps = function defaultMapDispatchToProps() {
  return function (dispatch, _, __) {
    return {
      dispatch: dispatch
    };
  };
};
var connect = exports.connect = function connect() {
  var mapStateToProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultMapStateToProps;
  var makeMapDispatchToProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMapDispatchToProps;
  var reduxMergeProps = arguments.length > 2 ? arguments[2] : undefined;
  var options = arguments.length > 3 ? arguments[3] : undefined;
  return function (BaseComponent) {
    var mapDispatchToProps = makeMapDispatchToProps();
    var reduxMapState = function reduxMapState(state, props) {
      return mapStateToProps(props.selector(state), props, state);
    };
    var reduxMapDispatch = function reduxMapDispatch(dispatch, props) {
      return mapDispatchToProps(props.dispatch, props, dispatch);
    };
    var ReduxComponent = (0, _lib.connect)(reduxMapState, reduxMapDispatch, reduxMergeProps, options)(BaseComponent);

    // save selector to context so it can be accessed by its children
    return (0, _withLocalSelector["default"])(ReduxComponent);
  };
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfbGliIiwicmVxdWlyZSIsIl93aXRoTG9jYWxTZWxlY3RvciIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJkZWZhdWx0TWFwU3RhdGVUb1Byb3BzIiwic3RhdGUiLCJfIiwiX18iLCJkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzIiwiZGlzcGF0Y2giLCJjb25uZWN0IiwiZXhwb3J0cyIsIm1hcFN0YXRlVG9Qcm9wcyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIm1ha2VNYXBEaXNwYXRjaFRvUHJvcHMiLCJyZWR1eE1lcmdlUHJvcHMiLCJvcHRpb25zIiwiQmFzZUNvbXBvbmVudCIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsInJlZHV4TWFwU3RhdGUiLCJwcm9wcyIsInNlbGVjdG9yIiwicmVkdXhNYXBEaXNwYXRjaCIsIlJlZHV4Q29tcG9uZW50IiwicmVkdXhDb25uZWN0Iiwid2l0aExvY2FsU2VsZWN0b3IiXSwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9zcmMvY29ubmVjdC9rZXBsZXJnbC1jb25uZWN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCB7SlNYRWxlbWVudENvbnN0cnVjdG9yfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge2Nvbm5lY3QgYXMgcmVkdXhDb25uZWN0LCBHZXRQcm9wcywgTWF0Y2hpbmd9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB3aXRoTG9jYWxTZWxlY3RvciBmcm9tICcuL3dpdGgtbG9jYWwtc2VsZWN0b3InO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5jb25zdCBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlLCBfLCBfXykgPT4gc3RhdGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5jb25zdCBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzID0gKCkgPT4gKGRpc3BhdGNoLCBfLCBfXykgPT4gKHtkaXNwYXRjaH0pO1xuXG5leHBvcnQgY29uc3QgY29ubmVjdCA9XG4gIDxUIGV4dGVuZHMgSlNYRWxlbWVudENvbnN0cnVjdG9yPE1hdGNoaW5nPGFueSwgR2V0UHJvcHM8VD4+Pj4oXG4gICAgbWFwU3RhdGVUb1Byb3BzID0gZGVmYXVsdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICBtYWtlTWFwRGlzcGF0Y2hUb1Byb3BzID0gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICByZWR1eE1lcmdlUHJvcHM/LFxuICAgIG9wdGlvbnM/XG4gICkgPT5cbiAgKEJhc2VDb21wb25lbnQ6IFQpID0+IHtcbiAgICBjb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBtYWtlTWFwRGlzcGF0Y2hUb1Byb3BzKCk7XG4gICAgY29uc3QgcmVkdXhNYXBTdGF0ZSA9IChzdGF0ZSwgcHJvcHMpID0+IG1hcFN0YXRlVG9Qcm9wcyhwcm9wcy5zZWxlY3RvcihzdGF0ZSksIHByb3BzLCBzdGF0ZSk7XG5cbiAgICBjb25zdCByZWR1eE1hcERpc3BhdGNoID0gKGRpc3BhdGNoLCBwcm9wcykgPT5cbiAgICAgIG1hcERpc3BhdGNoVG9Qcm9wcyhwcm9wcy5kaXNwYXRjaCwgcHJvcHMsIGRpc3BhdGNoKTtcblxuICAgIGNvbnN0IFJlZHV4Q29tcG9uZW50ID0gcmVkdXhDb25uZWN0KFxuICAgICAgcmVkdXhNYXBTdGF0ZSxcbiAgICAgIHJlZHV4TWFwRGlzcGF0Y2gsXG4gICAgICByZWR1eE1lcmdlUHJvcHMsXG4gICAgICBvcHRpb25zXG4gICAgKShCYXNlQ29tcG9uZW50KTtcblxuICAgIC8vIHNhdmUgc2VsZWN0b3IgdG8gY29udGV4dCBzbyBpdCBjYW4gYmUgYWNjZXNzZWQgYnkgaXRzIGNoaWxkcmVuXG4gICAgcmV0dXJuIHdpdGhMb2NhbFNlbGVjdG9yKFJlZHV4Q29tcG9uZW50KTtcbiAgfTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUlBLElBQUFBLElBQUEsR0FBQUMsT0FBQTtBQUNBLElBQUFDLGtCQUFBLEdBQUFDLHNCQUFBLENBQUFGLE9BQUE7QUFMQTtBQUNBOztBQU1BO0FBQ0EsSUFBTUcsc0JBQXNCLEdBQUcsU0FBekJBLHNCQUFzQkEsQ0FBSUMsS0FBSyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7RUFBQSxPQUFLRixLQUFLO0FBQUE7QUFDdEQ7QUFDQSxJQUFNRyx5QkFBeUIsR0FBRyxTQUE1QkEseUJBQXlCQSxDQUFBO0VBQUEsT0FBUyxVQUFDQyxRQUFRLEVBQUVILENBQUMsRUFBRUMsRUFBRTtJQUFBLE9BQU07TUFBQ0UsUUFBUSxFQUFSQTtJQUFRLENBQUM7RUFBQSxDQUFDO0FBQUE7QUFFbEUsSUFBTUMsT0FBTyxHQUFBQyxPQUFBLENBQUFELE9BQUEsR0FDbEIsU0FEV0EsT0FBT0EsQ0FBQTtFQUFBLElBRWhCRSxlQUFlLEdBQUFDLFNBQUEsQ0FBQUMsTUFBQSxRQUFBRCxTQUFBLFFBQUFFLFNBQUEsR0FBQUYsU0FBQSxNQUFHVCxzQkFBc0I7RUFBQSxJQUN4Q1ksc0JBQXNCLEdBQUFILFNBQUEsQ0FBQUMsTUFBQSxRQUFBRCxTQUFBLFFBQUFFLFNBQUEsR0FBQUYsU0FBQSxNQUFHTCx5QkFBeUI7RUFBQSxJQUNsRFMsZUFBZ0IsR0FBQUosU0FBQSxDQUFBQyxNQUFBLE9BQUFELFNBQUEsTUFBQUUsU0FBQTtFQUFBLElBQ2hCRyxPQUFRLEdBQUFMLFNBQUEsQ0FBQUMsTUFBQSxPQUFBRCxTQUFBLE1BQUFFLFNBQUE7RUFBQSxPQUVWLFVBQUNJLGFBQWdCLEVBQUs7SUFDcEIsSUFBTUMsa0JBQWtCLEdBQUdKLHNCQUFzQixDQUFDLENBQUM7SUFDbkQsSUFBTUssYUFBYSxHQUFHLFNBQWhCQSxhQUFhQSxDQUFJaEIsS0FBSyxFQUFFaUIsS0FBSztNQUFBLE9BQUtWLGVBQWUsQ0FBQ1UsS0FBSyxDQUFDQyxRQUFRLENBQUNsQixLQUFLLENBQUMsRUFBRWlCLEtBQUssRUFBRWpCLEtBQUssQ0FBQztJQUFBO0lBRTVGLElBQU1tQixnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQWdCQSxDQUFJZixRQUFRLEVBQUVhLEtBQUs7TUFBQSxPQUN2Q0Ysa0JBQWtCLENBQUNFLEtBQUssQ0FBQ2IsUUFBUSxFQUFFYSxLQUFLLEVBQUViLFFBQVEsQ0FBQztJQUFBO0lBRXJELElBQU1nQixjQUFjLEdBQUcsSUFBQUMsWUFBWSxFQUNqQ0wsYUFBYSxFQUNiRyxnQkFBZ0IsRUFDaEJQLGVBQWUsRUFDZkMsT0FDRixDQUFDLENBQUNDLGFBQWEsQ0FBQzs7SUFFaEI7SUFDQSxPQUFPLElBQUFRLDZCQUFpQixFQUFDRixjQUFjLENBQUM7RUFDMUMsQ0FBQztBQUFBIiwiaWdub3JlTGlzdCI6W119