"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VIS_STATE_MERGERS = void 0;
exports.createLayerFromConfig = createLayerFromConfig;
exports.insertLayerAtRightOrder = insertLayerAtRightOrder;
exports.isSavedLayerConfigV1 = isSavedLayerConfigV1;
exports.mergeAnimationConfig = mergeAnimationConfig;
exports.mergeDatasetsByOrder = mergeDatasetsByOrder;
exports.mergeEditor = mergeEditor;
exports.mergeEffects = mergeEffects;
exports.mergeFilters = mergeFilters;
exports.mergeInteractionTooltipConfig = mergeInteractionTooltipConfig;
exports.mergeInteractions = mergeInteractions;
exports.mergeLayerBlending = mergeLayerBlending;
exports.mergeLayers = mergeLayers;
exports.mergeOverlayBlending = mergeOverlayBlending;
exports.mergeSplitMaps = mergeSplitMaps;
exports.parseLayerConfig = parseLayerConfig;
exports.replaceFilterDatasetIds = replaceFilterDatasetIds;
exports.serializeEffect = serializeEffect;
exports.serializeFilter = serializeFilter;
exports.serializeLayer = serializeLayer;
exports.serializeVisState = serializeVisState;
exports.validateColumn = validateColumn;
exports.validateLayerWithData = validateLayerWithData;
exports.validateLayersByDatasets = validateLayersByDatasets;
exports.validateSavedLayerColumns = validateSavedLayerColumns;
exports.validateSavedTextLabel = validateSavedTextLabel;
exports.validateSavedVisualChannels = validateSavedVisualChannels;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _uniq = _interopRequireDefault(require("lodash/uniq"));
var _pick = _interopRequireDefault(require("lodash/pick"));
var _flattenDeep = _interopRequireDefault(require("lodash/flattenDeep"));
var _deepmerge = _interopRequireDefault(require("deepmerge"));
var _utils = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/utils/src");
var _effects = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/effects/src");
var _commonUtils = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/common-utils/src");
var _constants = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/constants/src");
var _schemas = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/schemas/src");
var _table = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/table/src");
var _layerUtils = require("./layer-utils");
var _excluded = ["enabled"];
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0,
        F = function F() {};
      return {
        s: F,
        n: function n() {
          return _n >= r.length ? {
            done: !0
          } : {
            done: !1,
            value: r[_n++]
          };
        },
        e: function e(r) {
          throw r;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o,
    a = !0,
    u = !1;
  return {
    s: function s() {
      t = t.call(r);
    },
    n: function n() {
      var r = t.next();
      return a = r.done, r;
    },
    e: function e(r) {
      u = !0, o = r;
    },
    f: function f() {
      try {
        a || null == t["return"] || t["return"]();
      } finally {
        if (u) throw o;
      }
    }
  };
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      (0, _defineProperty2["default"])(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
} // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
/**
 * Merge loaded filters with current state, if no fields or data are loaded
 * save it for later
 *
 */
function mergeFilters(state, filtersToMerge, fromConfig) {
  var preserveFilterOrder = fromConfig ? filtersToMerge === null || filtersToMerge === void 0 ? void 0 : filtersToMerge.map(function (l) {
    return l.id;
  }) : state.preserveFilterOrder;
  if (!Array.isArray(filtersToMerge) || !filtersToMerge.length) {
    return state;
  }
  var _validateFiltersUpdat = (0, _utils.validateFiltersUpdateDatasets)(state, filtersToMerge),
    validated = _validateFiltersUpdat.validated,
    failed = _validateFiltersUpdat.failed,
    updatedDatasets = _validateFiltersUpdat.updatedDatasets;
  var updatedFilters = insertItemBasedOnPreservedOrder(state.filters, validated, preserveFilterOrder);

  // merge filter with existing
  updatedFilters = (0, _table.resetFilterGpuMode)(updatedFilters);
  updatedFilters = (0, _table.assignGpuChannels)(updatedFilters);
  // filter data
  var datasetsToFilter = (0, _uniq["default"])((0, _flattenDeep["default"])(validated.map(function (f) {
    return f.dataId;
  })));
  var filtered = (0, _utils.applyFiltersToDatasets)(datasetsToFilter, updatedDatasets, updatedFilters, state.layers);
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: updatedFilters,
    datasets: filtered,
    preserveFilterOrder: preserveFilterOrder,
    filterToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.filterToBeMerged), (0, _toConsumableArray2["default"])(failed))
  });
}

// replace dataId in saved Filter
function replaceFilterDatasetIds(savedFilter, dataId, dataIdToUse) {
  var replaced = [];
  savedFilter.forEach(function (filter) {
    if (filter.dataId.includes(dataId)) {
      var _filter$plotType;
      var newDataId = filter.dataId.map(function (d) {
        return d === dataId ? dataIdToUse : d;
      });
      var plotType;
      // TODO: more generic approach to save plotType.colorsByDataId
      if ((_filter$plotType = filter.plotType) !== null && _filter$plotType !== void 0 && (_filter$plotType = _filter$plotType.colorsByDataId) !== null && _filter$plotType !== void 0 && _filter$plotType[dataId]) {
        var _filter$plotType2;
        // replace colorByDataId in filter.plotType
        var _ref = ((_filter$plotType2 = filter.plotType) === null || _filter$plotType2 === void 0 ? void 0 : _filter$plotType2.colorsByDataId) || {},
          color = _ref[dataId],
          rest = (0, _objectWithoutProperties2["default"])(_ref, [dataId].map(_toPropertyKey));
        plotType = _objectSpread(_objectSpread({}, filter.plotType), {}, {
          colorsByDataId: _objectSpread(_objectSpread({}, rest), {}, (0, _defineProperty2["default"])({}, dataIdToUse, color))
        });
      }
      replaced.push(_objectSpread(_objectSpread({}, filter), {}, {
        dataId: newDataId
      }, plotType ? {
        plotType: plotType
      } : {}));
    }
  });
  return replaced.length ? replaced : null;
}
function isSavedLayerConfigV1(layerConfig) {
  // exported layer configuration contains visualChannels property
  return layerConfig === null || layerConfig === void 0 ? void 0 : layerConfig.visualChannels;
}
function parseLayerConfig(schema, layerConfig) {
  var _schema$parseSavedCon;
  // assume the layer config is current version
  var savedConfig = {
    version: _schemas.CURRENT_VERSION,
    config: {
      visState: {
        layers: [layerConfig],
        layerOrder: [layerConfig.id]
      }
    }
  };
  return (_schema$parseSavedCon = schema.parseSavedConfig(savedConfig)) === null || _schema$parseSavedCon === void 0 || (_schema$parseSavedCon = _schema$parseSavedCon.visState) === null || _schema$parseSavedCon === void 0 || (_schema$parseSavedCon = _schema$parseSavedCon.layers) === null || _schema$parseSavedCon === void 0 ? void 0 : _schema$parseSavedCon[0];
}
function insertItemBasedOnPreservedOrder(currentItems, items) {
  var preservedOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var defaultStart = arguments.length > 3 ? arguments[3] : undefined;
  var newItems = (0, _toConsumableArray2["default"])(currentItems);
  var _iterator = _createForOfIteratorHelper(items),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;
      var expectedIdx = preservedOrder.indexOf(item.id);
      // insertAt the end by default
      var insertAt = defaultStart ? 0 : newItems.length;
      if (expectedIdx > 0) {
        // look for layer to insert after
        var i = expectedIdx + 1;
        var preceedIdx = -1;
        var _loop = function _loop() {
          // keep looking for preceed layer that is already loaded
          var preceedItemId = preservedOrder[i - 1];
          preceedIdx = newItems.findIndex(function (d) {
            return d.id === preceedItemId;
          });
        };
        while (i-- > 0 && preceedIdx < 0) {
          _loop();
        }
        if (preceedIdx > -1) {
          // if found
          insertAt = preceedIdx + 1;
        }
      }
      newItems = (0, _utils.arrayInsert)(newItems, insertAt, item);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return newItems;
}
function createLayerFromConfig(state, layerConfig) {
  // check if the layer config is parsed
  var parsedLayerConfig = isSavedLayerConfigV1(layerConfig) ? parseLayerConfig(state.schema, layerConfig) : layerConfig;
  if (!parsedLayerConfig) {
    return null;
  }
  // first validate config against dataset
  var _validateLayersByData = validateLayersByDatasets(state.datasets, state.layerClasses, [parsedLayerConfig], {
      allowEmptyColumn: true
    }),
    validated = _validateLayersByData.validated,
    failed = _validateLayersByData.failed;
  if (failed !== null && failed !== void 0 && failed.length || !validated.length) {
    // failed
    return null;
  }
  var newLayer = validated[0];
  newLayer.updateLayerDomain(state.datasets);
  return newLayer;
}

/**
 * Get loaded filter from state
 */
function serializeFilter(newFilter, schema) {
  var _serializedVisState$f;
  var serializedVisState = serializeVisState({
    filters: [newFilter]
  }, schema);
  return serializedVisState === null || serializedVisState === void 0 || (_serializedVisState$f = serializedVisState.filters) === null || _serializedVisState$f === void 0 ? void 0 : _serializedVisState$f[0];
}

/**
 * Get loaded layer from state
 */
function serializeLayer(newLayer, schema) {
  var _serializedVisState$l;
  var serializedVisState = serializeVisState({
    layers: [newLayer],
    layerOrder: [newLayer.id]
  }, schema);
  return serializedVisState === null || serializedVisState === void 0 || (_serializedVisState$l = serializedVisState.layers) === null || _serializedVisState$l === void 0 ? void 0 : _serializedVisState$l[0];
}

/**
 * Get loaded effect from state
 */
function serializeEffect(newEffect, schema) {
  var _serializedVisState$e;
  var serializedVisState = serializeVisState({
    effects: [newEffect],
    effectOrder: [newEffect.id]
  }, schema);
  return serializedVisState === null || serializedVisState === void 0 || (_serializedVisState$e = serializedVisState.effects) === null || _serializedVisState$e === void 0 ? void 0 : _serializedVisState$e[0];
}

/**
 * Get vis state config
 */
function serializeVisState(visState, schema) {
  var _schema$parseSavedCon2;
  var savedState = schema.getConfigToSave({
    visState: visState
  });
  return savedState ? (_schema$parseSavedCon2 = schema.parseSavedConfig(savedState)) === null || _schema$parseSavedCon2 === void 0 ? void 0 : _schema$parseSavedCon2.visState : undefined;
}
/**
 * Merge layers from de-serialized state, if no fields or data are loaded
 * save it for later
 *
 */
function mergeLayers(state) {
  var layersToMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var fromConfig = arguments.length > 2 ? arguments[2] : undefined;
  var preserveLayerOrder = fromConfig ? (0, _layerUtils.getLayerOrderFromLayers)(layersToMerge) : state.preserveLayerOrder;
  if (!Array.isArray(layersToMerge) || !layersToMerge.length) {
    return state;
  }
  // don't merge layer if dataset is being merged
  var unmerged = [];
  var toMerge = [];
  layersToMerge.forEach(function (l) {
    var _l$config;
    if (l !== null && l !== void 0 && (_l$config = l.config) !== null && _l$config !== void 0 && _l$config.dataId && state.isMergingDatasets[l.config.dataId]) {
      unmerged.push(l);
    } else {
      toMerge.push(l);
    }
  });
  var _validateLayersByData2 = validateLayersByDatasets(state.datasets, state.layerClasses, toMerge),
    mergedLayer = _validateLayersByData2.validated,
    failed = _validateLayersByData2.failed;
  unmerged.push.apply(unmerged, (0, _toConsumableArray2["default"])(failed));
  // put new layers in front of current layers
  var _insertLayerAtRightOr = insertLayerAtRightOrder(state.layers, mergedLayer, state.layerOrder, preserveLayerOrder),
    newLayerOrder = _insertLayerAtRightOr.newLayerOrder,
    newLayers = _insertLayerAtRightOr.newLayers;
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    layerOrder: newLayerOrder,
    preserveLayerOrder: preserveLayerOrder,
    layerToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.layerToBeMerged), unmerged)
  });
}
function insertLayerAtRightOrder(currentLayers, layersToInsert, currentOrder) {
  var preservedOrder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  if (!(layersToInsert !== null && layersToInsert !== void 0 && layersToInsert.length)) {
    return {
      newLayers: currentLayers,
      newLayerOrder: currentOrder
    };
  }
  // perservedOrder ['a', 'b', 'c'];
  // layerOrder ['a', 'b', 'c']
  var currentLayerQueue = currentOrder.map(function (id) {
    return (0, _utils.findById)(id)(currentLayers);
  }).filter(function (layer) {
    return Boolean(layer);
  });
  var newLayers = currentLayers.concat(layersToInsert);
  var newLayerOrderQueue = insertItemBasedOnPreservedOrder(currentLayerQueue, layersToInsert, preservedOrder, true);

  // reconstruct layerOrder after insert
  var newLayerOrder = (0, _layerUtils.getLayerOrderFromLayers)(newLayerOrderQueue);
  return {
    newLayerOrder: newLayerOrder,
    newLayers: newLayers
  };
}

/**
 * Merge interactions with saved config
 *
 */
function mergeInteractions(state, interactionToBeMerged) {
  var merged = {};
  var unmerged = {};
  if (interactionToBeMerged) {
    Object.keys(interactionToBeMerged).forEach(function (key) {
      if (!state.interactionConfig[key]) {
        return;
      }
      var currentConfig = key === 'tooltip' || key === 'brush' ? state.interactionConfig[key].config : null;
      var _ref2 = interactionToBeMerged[key] || {},
        enabled = _ref2.enabled,
        configSaved = (0, _objectWithoutProperties2["default"])(_ref2, _excluded);
      var configToMerge = configSaved;
      if (key === 'tooltip') {
        var _mergeInteractionTool = mergeInteractionTooltipConfig(state, configSaved),
          mergedTooltip = _mergeInteractionTool.mergedTooltip,
          unmergedTooltip = _mergeInteractionTool.unmergedTooltip;

        // merge new dataset tooltips with original dataset tooltips
        configToMerge = {
          fieldsToShow: _objectSpread(_objectSpread({}, currentConfig.fieldsToShow), mergedTooltip)
        };
        if (Object.keys(unmergedTooltip).length) {
          // @ts-expect-error
          unmerged.tooltip = {
            fieldsToShow: unmergedTooltip,
            enabled: Boolean(enabled)
          };
        }
      }
      merged[key] = _objectSpread(_objectSpread({}, state.interactionConfig[key]), {}, {
        enabled: Boolean(enabled)
      }, currentConfig ? {
        config: (0, _pick["default"])(_objectSpread(_objectSpread({}, currentConfig), configToMerge), Object.keys(currentConfig))
      } : {});
    });
  }
  var nextState = _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: _objectSpread(_objectSpread({}, state.interactionConfig), merged),
    interactionToBeMerged: savedUnmergedInteraction(state, unmerged)
  });
  return nextState;
}
function combineInteractionConfigs(configs) {
  var combined = _objectSpread({}, configs[0]);
  // handle each property key of an `InteractionConfig`, e.g. tooltip, geocoder, brush, coordinate
  // by combining values for each among all passed in configs
  var _loop2 = function _loop2(key) {
    var toBeCombinedProps = configs.map(function (c) {
      return c[key];
    });

    // all of these have an enabled boolean
    combined[key] = {
      // are any of the configs' enabled values true?
      enabled: toBeCombinedProps.some(function (p) {
        return p === null || p === void 0 ? void 0 : p.enabled;
      })
    };
    if (key === 'tooltip') {
      // are any of the configs' compareMode values true?
      combined[key].compareMode = toBeCombinedProps.some(function (p) {
        return p === null || p === void 0 ? void 0 : p.compareMode;
      });

      // return the compare type mode, it will be either absolute or relative
      combined[key].compareType = getValueWithHighestOccurrence(toBeCombinedProps.map(function (p) {
        return p.compareType;
      }));

      // combine fieldsToShow among all dataset ids
      combined[key].fieldsToShow = toBeCombinedProps.map(function (p) {
        return p.fieldsToShow;
      }).reduce(function (acc, nextFieldsToShow) {
        var _loop3 = function _loop3(nextDataIdKey) {
          var nextTooltipFields = nextFieldsToShow[nextDataIdKey];
          if (!acc[nextDataIdKey]) {
            // if the dataset id is not present in the accumulator
            // then add it with its tooltip fields
            acc[nextDataIdKey] = nextTooltipFields;
          } else {
            // otherwise the dataset id is already present in the accumulator
            // so only add the next tooltip fields for this dataset's array if they are not already present,
            // using the tooltipField.name property for uniqueness
            nextTooltipFields.forEach(function (nextTF) {
              if (!acc[nextDataIdKey].find(function (_ref3) {
                var name = _ref3.name;
                return nextTF.name === name;
              })) {
                acc[nextDataIdKey].push(nextTF);
              }
            });
          }
        };
        for (var nextDataIdKey in nextFieldsToShow) {
          _loop3(nextDataIdKey);
        }
        return acc;
      }, {});
    }
    if (key === 'brush') {
      var _aggregate;
      // keep the biggest brush size
      combined[key].size = (_aggregate = (0, _utils.aggregate)(toBeCombinedProps, _constants.AGGREGATION_TYPES.maximum, function (p) {
        return p.size;
      })) !== null && _aggregate !== void 0 ? _aggregate : null;
    }
  };
  for (var key in combined) {
    _loop2(key);
  }
  return combined;
}
function savedUnmergedInteraction(state, unmerged) {
  var _unmerged$tooltip, _unmerged$tooltip2, _state$interactionToB, _unmerged$tooltip3;
  if (!(unmerged !== null && unmerged !== void 0 && (_unmerged$tooltip = unmerged.tooltip) !== null && _unmerged$tooltip !== void 0 && _unmerged$tooltip.fieldsToShow)) {
    return state.interactionToBeMerged;
  }
  return {
    tooltip: _objectSpread(_objectSpread(_objectSpread({}, state.interactionToBeMerged.tooltip), typeof (unmerged === null || unmerged === void 0 || (_unmerged$tooltip2 = unmerged.tooltip) === null || _unmerged$tooltip2 === void 0 ? void 0 : _unmerged$tooltip2.enabled) === 'boolean' ? {
      enabled: unmerged.tooltip.enabled
    } : {}), {}, {
      fieldsToShow: _objectSpread(_objectSpread({}, (_state$interactionToB = state.interactionToBeMerged) === null || _state$interactionToB === void 0 || (_state$interactionToB = _state$interactionToB.tooltip) === null || _state$interactionToB === void 0 ? void 0 : _state$interactionToB.fieldsToShow), unmerged === null || unmerged === void 0 || (_unmerged$tooltip3 = unmerged.tooltip) === null || _unmerged$tooltip3 === void 0 ? void 0 : _unmerged$tooltip3.fieldsToShow)
    })
  };
}
function replaceInteractionDatasetIds(interactionConfig, dataId, dataIdToReplace) {
  var _interactionConfig$to;
  if (interactionConfig !== null && interactionConfig !== void 0 && (_interactionConfig$to = interactionConfig.tooltip) !== null && _interactionConfig$to !== void 0 && _interactionConfig$to.fieldsToShow[dataId]) {
    var _interactionConfig$to2;
    return _objectSpread(_objectSpread({}, interactionConfig), {}, {
      tooltip: _objectSpread(_objectSpread({}, interactionConfig.tooltip), {}, {
        fieldsToShow: (0, _defineProperty2["default"])({}, dataIdToReplace, interactionConfig === null || interactionConfig === void 0 || (_interactionConfig$to2 = interactionConfig.tooltip) === null || _interactionConfig$to2 === void 0 ? void 0 : _interactionConfig$to2.fieldsToShow[dataId])
      })
    });
  }
  return null;
}

/**
 * Merge splitMaps config with current visStete.
 * 1. if current map is split, but splitMap DOESNOT contain maps
 *    : don't merge anything
 * 2. if current map is NOT split, but splitMaps contain maps
 *    : add to splitMaps, and add current layers to splitMaps
 */
function mergeSplitMaps(state) {
  var splitMaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var merged = (0, _toConsumableArray2["default"])(state.splitMaps);
  var unmerged = [];
  splitMaps.forEach(function (sm, i) {
    var entries = Object.entries(sm.layers);
    if (entries.length > 0) {
      entries.forEach(function (_ref4) {
        var _ref5 = (0, _slicedToArray2["default"])(_ref4, 2),
          id = _ref5[0],
          value = _ref5[1];
        // check if layer exists
        var pushTo = state.layers.find(function (l) {
          return l.id === id;
        }) ? merged : unmerged;

        // create map panel if current map is not split
        pushTo[i] = pushTo[i] || _objectSpread(_objectSpread({}, sm), {}, {
          layers: pushTo === merged ? (0, _utils.getInitialMapLayersForSplitMap)(state.layers) : []
        });
        pushTo[i].layers = _objectSpread(_objectSpread({}, pushTo[i].layers), {}, (0, _defineProperty2["default"])({}, id, value));
      });
    } else {
      // We are merging if there are no layers in both split map
      merged.push(sm);
    }
  });
  return _objectSpread(_objectSpread({}, state), {}, {
    splitMaps: merged,
    splitMapsToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.splitMapsToBeMerged), unmerged)
  });
}

/**
 * Merge effects with saved config
 */
function mergeEffects(state, effects, fromConfig) {
  var newEffects = [].concat((0, _toConsumableArray2["default"])(state.effects), (0, _toConsumableArray2["default"])((effects || []).map(function (effect) {
    return fromConfig ? (0, _effects.createEffect)(_deepmerge["default"].all([effect, {
      // collapse all panels when loading effects
      isConfigActive: false
    }])) : effect;
  }).filter(function (effect) {
    return Boolean(effect && effect.isValidToSave());
  })));
  return _objectSpread(_objectSpread({}, state), {}, {
    effects: newEffects,
    effectOrder: newEffects.map(function (effect) {
      return effect.id;
    })
  });
}

/**
 * Merge interactionConfig.tooltip with saved config,
 * validate fieldsToShow
 *
 * @param state
 * @param tooltipConfig
 * @return - {mergedTooltip: {}, unmergedTooltip: {}}
 */
function mergeInteractionTooltipConfig(state) {
  var tooltipConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var unmergedTooltip = {};
  var mergedTooltip = {};
  if (!tooltipConfig || !tooltipConfig.fieldsToShow || !Object.keys(tooltipConfig.fieldsToShow).length) {
    return {
      mergedTooltip: mergedTooltip,
      unmergedTooltip: unmergedTooltip
    };
  }
  var _loop4 = function _loop4() {
    if (!state.datasets[dataId] || state.isMergingDatasets[dataId]) {
      // is not yet loaded
      unmergedTooltip[dataId] = tooltipConfig.fieldsToShow[dataId];
    } else {
      // if dataset is loaded
      var allFields = state.datasets[dataId].fields.map(function (d) {
        return d.name;
      });
      var foundFieldsToShow = tooltipConfig.fieldsToShow[dataId].filter(function (field) {
        return allFields.includes(field.name);
      });
      mergedTooltip[dataId] = foundFieldsToShow;
    }
  };
  for (var dataId in tooltipConfig.fieldsToShow) {
    _loop4();
  }
  return {
    mergedTooltip: mergedTooltip,
    unmergedTooltip: unmergedTooltip
  };
}
/**
 * Merge layerBlending with saved
 *
 */
function mergeLayerBlending(state, layerBlending) {
  if (layerBlending && _constants.LAYER_BLENDINGS[layerBlending]) {
    return _objectSpread(_objectSpread({}, state), {}, {
      layerBlending: layerBlending
    });
  }
  return state;
}

/**
 * Combines multiple layer blending configs into a single string
 * by returning the one with the highest occurrence
 */
function combineLayerBlendingConfigs(configs) {
  // return the mode of the layer blending type
  return getValueWithHighestOccurrence(configs);
}

/**
 * Merge overlayBlending with saved
 */
function mergeOverlayBlending(state, overlayBlending) {
  if (overlayBlending && _constants.OVERLAY_BLENDINGS[overlayBlending]) {
    return _objectSpread(_objectSpread({}, state), {}, {
      overlayBlending: overlayBlending
    });
  }
  return state;
}

/**
 * Combines multiple overlay blending configs into a single string
 * by returning the one with the highest occurrence
 **/
function combineOverlayBlendingConfigs(configs) {
  // return the mode of the overlay blending type
  return getValueWithHighestOccurrence(configs);
}

/**
 * Merge animation config
 */
function mergeAnimationConfig(state, animation) {
  if (animation && animation.currentTime) {
    return _objectSpread(_objectSpread({}, state), {}, {
      animationConfig: _objectSpread(_objectSpread(_objectSpread({}, state.animationConfig), animation), {}, {
        domain: null
      })
    });
  }
  return state;
}
function combineAnimationConfigs(configs) {
  var _aggregate2, _aggregate3;
  // get the smallest values of currentTime and speed among all configs
  return {
    currentTime: (_aggregate2 = (0, _utils.aggregate)(configs, _constants.AGGREGATION_TYPES.minimum, function (c) {
      return c.currentTime;
    })) !== null && _aggregate2 !== void 0 ? _aggregate2 : null,
    speed: (_aggregate3 = (0, _utils.aggregate)(configs, _constants.AGGREGATION_TYPES.minimum, function (c) {
      return c.speed;
    })) !== null && _aggregate3 !== void 0 ? _aggregate3 : null
  };
}

/**
 * Validate saved layer columns with new data,
 * update fieldIdx based on new fields
 *
 * @param fields
 * @param savedCols
 * @param emptyCols
 * @param options
 * @return - validated columns or null
 */

function validateSavedLayerColumns(fields) {
  var savedCols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var emptyCols = arguments.length > 2 ? arguments[2] : undefined;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // Prepare columns for the validator
  var columns = {};
  var _loop5 = function _loop5() {
    var key = _Object$keys[_i];
    columns[key] = _objectSpread({}, emptyCols[key]);
    var saved = savedCols[key];
    if (saved) {
      var fieldIdx = fields.findIndex(function (_ref6) {
        var name = _ref6.name;
        return name === saved;
      });
      if (fieldIdx > -1) {
        // update found columns
        columns[key].fieldIdx = fieldIdx;
        columns[key].value = saved;
      }
    }
  };
  for (var _i = 0, _Object$keys = Object.keys(emptyCols); _i < _Object$keys.length; _i++) {
    _loop5();
  }

  // find actual column fieldIdx, in case it has changed
  var allColFound = Object.keys(columns).every(function (key) {
    return validateColumn(columns[key], columns, fields);
  });
  var rv = allColFound ? columns : null;
  if (options.throwOnError) {
    var requiredColumns = Object.keys(emptyCols).filter(function (k) {
      return !emptyCols[k].optional;
    });
    var missingColumns = requiredColumns.filter(function (k) {
      return !(columns !== null && columns !== void 0 && columns[k].value);
    });
    if (missingColumns.length) {
      throw new Error("Layer has missing or invalid columns: ".concat(missingColumns.join(', ')));
    }
    var configColumns = Object.keys(savedCols);
    var invalidColumns = configColumns.filter(function (k) {
      var _columns$k;
      return !(columns !== null && columns !== void 0 && (_columns$k = columns[k]) !== null && _columns$k !== void 0 && _columns$k.value);
    });
    if (invalidColumns.length) {
      throw new Error("Layer has invalid columns: ".concat(invalidColumns.join(', ')));
    }
  }
  return rv;
}

/**
 * Validate layer column
 */
function validateColumn(column, columns, allFields) {
  if (column.optional || column.value) {
    return true;
  }
  if (column.validator) {
    return column.validator(column, columns, allFields);
  }
  return false;
}

/**
 * Validate saved text label config with new data
 * refer to vis-state-schema.js TextLabelSchemaV1
 *
 * @param {Array<Object>} fields
 * @param {Object} savedTextLabel
 * @param {Object} options
 * @return {Object} - validated textlabel
 */
function validateSavedTextLabel(fields, _ref7, savedTextLabel) {
  var _ref8 = (0, _slicedToArray2["default"])(_ref7, 1),
    layerTextLabel = _ref8[0];
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var savedTextLabels = Array.isArray(savedTextLabel) ? savedTextLabel : [savedTextLabel];

  // validate field
  return savedTextLabels.map(function (textLabel) {
    var field = textLabel.field ? fields.find(function (fd) {
      return Object.keys(textLabel.field).every(function (key) {
        return textLabel.field[key] === fd[key];
      });
    }) : null;
    if (field === undefined && options.throwOnError) {
      throw new Error("Layer has invalid text label field: ".concat(JSON.stringify(textLabel.field)));
    }
    return Object.keys(layerTextLabel).reduce(function (accu, key) {
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, key === 'field' ? field : textLabel[key] || layerTextLabel[key]));
    }, {});
  });
}

/**
 * Validate saved visual channels config with new data,
 * refer to vis-state-schema.js VisualChannelSchemaV1
 */
function validateSavedVisualChannels(fields, newLayer, savedLayer) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  Object.values(newLayer.visualChannels).forEach(function (_ref9) {
    var field = _ref9.field,
      scale = _ref9.scale,
      key = _ref9.key;
    var foundField;
    if (savedLayer.config) {
      if (savedLayer.config[field]) {
        foundField = fields.find(function (fd) {
          return savedLayer.config && fd.name === savedLayer.config[field].name;
        });
      }
      var foundChannel = _objectSpread(_objectSpread({}, foundField ? (0, _defineProperty2["default"])({}, field, foundField) : {}), savedLayer.config[scale] ? (0, _defineProperty2["default"])({}, scale, savedLayer.config[scale]) : {});
      if (Object.keys(foundChannel).length) {
        newLayer.updateLayerConfig(foundChannel);
      }
      newLayer.validateVisualChannel(key);
      if (options.throwOnError) {
        var _savedLayer$config, _newLayer$config$fiel;
        var fieldName = (_savedLayer$config = savedLayer.config) === null || _savedLayer$config === void 0 || (_savedLayer$config = _savedLayer$config[field]) === null || _savedLayer$config === void 0 ? void 0 : _savedLayer$config.name;
        if (fieldName && fieldName !== ((_newLayer$config$fiel = newLayer.config[field]) === null || _newLayer$config$fiel === void 0 ? void 0 : _newLayer$config$fiel.name)) {
          throw new Error("Layer has invalid visual channel field: ".concat(field));
        }
      }
    }
  });
  return newLayer;
}
function validateLayersByDatasets(datasets, layerClasses) {
  var layers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var options = arguments.length > 3 ? arguments[3] : undefined;
  var validated = [];
  var failed = [];
  layers.forEach(function (layer) {
    var _layer$config;
    var validateLayer = null;
    if (layer !== null && layer !== void 0 && (_layer$config = layer.config) !== null && _layer$config !== void 0 && _layer$config.dataId) {
      if (datasets[layer.config.dataId]) {
        // datasets are already loaded
        validateLayer = validateLayerWithData(datasets[layer.config.dataId], layer, layerClasses, options);
      }
    }
    if (validateLayer) {
      validated.push(validateLayer);
    } else {
      // datasets not yet loaded
      failed.push(layer);
    }
  });
  return {
    validated: validated,
    failed: failed
  };
}

/**
 * Get required columns for validation based on column mode
 */
function _getColumnConfigForValidation(newLayer) {
  // find column fieldIdx
  var columnConfig = newLayer.getLayerColumns();
  // if columnMode is defined, find column mode config
  var colModeConfig = newLayer.config.columnMode ? (newLayer.supportedColumnModes || []).find(function (colMode) {
    return colMode.key === newLayer.config.columnMode;
  }) : null;
  if (colModeConfig) {
    // only validate columns in column mode
    columnConfig = [].concat((0, _toConsumableArray2["default"])(colModeConfig.requiredColumns || []), (0, _toConsumableArray2["default"])(colModeConfig.optionalColumns || [])).reduce(function (accu, key) {
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, columnConfig[key]));
    }, {});
  }
  return columnConfig;
}

/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 */
// eslint-disable-next-line complexity
function validateLayerWithData(dataset, savedLayer, layerClasses) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var fields = dataset.fields,
    dataId = dataset.id;
  var type = savedLayer.type;
  var throwOnError = options.throwOnError;
  // layer doesnt have a valid type
  if (!type || !Object.prototype.hasOwnProperty.call(layerClasses, type) || !savedLayer.config) {
    if (throwOnError) {
      throw new Error("Layer has invalid type \"".concat(type, "\" or config is missing"));
    }
    return null;
  }
  var newLayer = new layerClasses[type]({
    id: savedLayer.id,
    dataId: dataId,
    label: savedLayer.config.label,
    color: savedLayer.config.color,
    isVisible: savedLayer.config.isVisible,
    hidden: savedLayer.config.hidden,
    columnMode: savedLayer.config.columnMode,
    highlightColor: savedLayer.config.highlightColor
  });
  var columnConfig = _getColumnConfigForValidation(newLayer);
  if (Object.keys(columnConfig)) {
    var columns = validateSavedLayerColumns(fields, savedLayer.config.columns, columnConfig, options);
    if (columns) {
      newLayer.updateLayerConfig({
        columns: _objectSpread(_objectSpread({}, newLayer.config.columns), columns)
      });
    } else if (!options.allowEmptyColumn) {
      return null;
    }
  }
  var textLabel = savedLayer.config.textLabel && newLayer.config.textLabel ? validateSavedTextLabel(fields, newLayer.config.textLabel, savedLayer.config.textLabel, options) : newLayer.config.textLabel;

  // copy visConfig over to emptyLayer to make sure it has all the props
  var copiedVisConfig = newLayer.copyLayerConfig(newLayer.config.visConfig, savedLayer.config.visConfig || {}, {
    shallowCopy: ['colorRange', 'strokeColorRange']
  });

  // call layer methods to validate visConfig when switching dataset
  var visConfig = newLayer.validateVisConfig ? newLayer.validateVisConfig(dataset, copiedVisConfig) : copiedVisConfig;
  newLayer.updateLayerConfig({
    visConfig: visConfig,
    textLabel: textLabel
  });

  // visual channel field is saved to be {name, type}
  // find visual channel field by matching both name and type
  // refer to vis-state-schema.js VisualChannelSchemaV1
  newLayer = validateSavedVisualChannels(fields, newLayer, savedLayer, options);
  if (throwOnError) {
    if (!newLayer.isValidToSave()) {
      throw new Error("Layer is not valid to save: ".concat(newLayer.id));
    }
  }
  return newLayer;
}
function mergeEditor(state, savedEditor) {
  var _savedEditor$visible;
  if (!savedEditor) {
    return state;
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      features: [].concat((0, _toConsumableArray2["default"])(state.editor.features), (0, _toConsumableArray2["default"])(savedEditor.features || [])),
      // if savedEditor.visible is undefined keep state.editor.visible
      visible: (_savedEditor$visible = savedEditor.visible) !== null && _savedEditor$visible !== void 0 ? _savedEditor$visible : state.editor.visible
    })
  });
}
function combineEditorConfigs(configs) {
  return configs.reduce(function (acc, nextConfig) {
    return _objectSpread(_objectSpread({}, acc), {}, {
      features: [].concat((0, _toConsumableArray2["default"])(acc.features), (0, _toConsumableArray2["default"])(nextConfig.features || []))
    });
  }, {
    // start with:
    // - empty array for features accumulation
    // - and are any of the configs' visible values true?
    features: [],
    visible: configs.some(function (c) {
      return c === null || c === void 0 ? void 0 : c.visible;
    })
  });
}

/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 */
function mergeDatasetsByOrder(state, newDataEntries) {
  var merged = _objectSpread(_objectSpread({}, state.datasets), newDataEntries);
  if (Array.isArray(state.preserveDatasetOrder)) {
    // preserveDatasetOrder  might not include the  new datasets
    var newDatasetIds = Object.keys(merged).filter(function (id) {
      var _state$preserveDatase;
      return !((_state$preserveDatase = state.preserveDatasetOrder) !== null && _state$preserveDatase !== void 0 && _state$preserveDatase.includes(id));
    });
    return [].concat((0, _toConsumableArray2["default"])(state.preserveDatasetOrder), (0, _toConsumableArray2["default"])(newDatasetIds)).reduce(function (accu, dataId) {
      return _objectSpread(_objectSpread({}, accu), merged[dataId] ? (0, _defineProperty2["default"])({}, dataId, merged[dataId]) : {});
    }, {});
  }
  return merged;
}

/**
 * Simliar purpose to aggregation utils `getMode` function,
 * but returns the mode in the same value type without coercing to a string.
 * It ignores `undefined` or `null` values, but returns `null` if no mode could be calculated.
 */
function getValueWithHighestOccurrence(arr) {
  var _ref13;
  var tallys = new Map();
  arr.forEach(function (value) {
    if ((0, _commonUtils.notNullorUndefined)(value)) {
      if (!tallys.has(value)) {
        tallys.set(value, 1);
      } else {
        tallys.set(value, tallys.get(value) + 1);
      }
    }
  });
  // return the value with the highest total occurrence count
  if (tallys.size === 0) {
    return null;
  }
  return (_ref13 = (0, _toConsumableArray2["default"])(tallys.entries())) === null || _ref13 === void 0 ? void 0 : _ref13.reduce(function (acc, next) {
    return next[1] > acc[1] ? next : acc;
  })[0];
}
var VIS_STATE_MERGERS = exports.VIS_STATE_MERGERS = [{
  merge: mergeLayers,
  prop: 'layers',
  toMergeProp: 'layerToBeMerged',
  preserveOrder: 'preserveLayerOrder'
}, {
  merge: mergeFilters,
  prop: 'filters',
  toMergeProp: 'filterToBeMerged',
  preserveOrder: 'preserveFilterOrder',
  replaceParentDatasetIds: replaceFilterDatasetIds
}, {
  merge: mergeEffects,
  prop: 'effects'
}, {
  merge: mergeInteractions,
  prop: 'interactionConfig',
  toMergeProp: 'interactionToBeMerged',
  replaceParentDatasetIds: replaceInteractionDatasetIds,
  saveUnmerged: savedUnmergedInteraction,
  combineConfigs: combineInteractionConfigs
}, {
  merge: mergeLayerBlending,
  prop: 'layerBlending',
  combineConfigs: combineLayerBlendingConfigs
}, {
  merge: mergeOverlayBlending,
  prop: 'overlayBlending',
  combineConfigs: combineOverlayBlendingConfigs
}, {
  merge: mergeSplitMaps,
  prop: 'splitMaps',
  toMergeProp: 'splitMapsToBeMerged'
}, {
  merge: mergeAnimationConfig,
  prop: 'animationConfig',
  combineConfigs: combineAnimationConfigs
}, {
  merge: mergeEditor,
  prop: 'editor',
  combineConfigs: combineEditorConfigs
}];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfdW5pcSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3BpY2siLCJfZmxhdHRlbkRlZXAiLCJfZGVlcG1lcmdlIiwiX3V0aWxzIiwiX2VmZmVjdHMiLCJfY29tbW9uVXRpbHMiLCJfY29uc3RhbnRzIiwiX3NjaGVtYXMiLCJfdGFibGUiLCJfbGF5ZXJVdGlscyIsIl9leGNsdWRlZCIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiciIsImUiLCJ0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBcnJheSIsImlzQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJsZW5ndGgiLCJfbiIsIkYiLCJzIiwibiIsImRvbmUiLCJ2YWx1ZSIsImYiLCJUeXBlRXJyb3IiLCJvIiwiYSIsInUiLCJjYWxsIiwibmV4dCIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwiX3RvUHJvcGVydHlLZXkiLCJpIiwiX3RvUHJpbWl0aXZlIiwiX3R5cGVvZiIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwib3duS2V5cyIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm1lcmdlRmlsdGVycyIsInN0YXRlIiwiZmlsdGVyc1RvTWVyZ2UiLCJmcm9tQ29uZmlnIiwicHJlc2VydmVGaWx0ZXJPcmRlciIsIm1hcCIsImwiLCJpZCIsIl92YWxpZGF0ZUZpbHRlcnNVcGRhdCIsInZhbGlkYXRlRmlsdGVyc1VwZGF0ZURhdGFzZXRzIiwidmFsaWRhdGVkIiwiZmFpbGVkIiwidXBkYXRlZERhdGFzZXRzIiwidXBkYXRlZEZpbHRlcnMiLCJpbnNlcnRJdGVtQmFzZWRPblByZXNlcnZlZE9yZGVyIiwiZmlsdGVycyIsInJlc2V0RmlsdGVyR3B1TW9kZSIsImFzc2lnbkdwdUNoYW5uZWxzIiwiZGF0YXNldHNUb0ZpbHRlciIsImRhdGFJZCIsImZpbHRlcmVkIiwiYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyIsImxheWVycyIsImRhdGFzZXRzIiwiZmlsdGVyVG9CZU1lcmdlZCIsImNvbmNhdCIsIl90b0NvbnN1bWFibGVBcnJheTIiLCJyZXBsYWNlRmlsdGVyRGF0YXNldElkcyIsInNhdmVkRmlsdGVyIiwiZGF0YUlkVG9Vc2UiLCJyZXBsYWNlZCIsImluY2x1ZGVzIiwiX2ZpbHRlciRwbG90VHlwZSIsIm5ld0RhdGFJZCIsImQiLCJwbG90VHlwZSIsImNvbG9yc0J5RGF0YUlkIiwiX2ZpbHRlciRwbG90VHlwZTIiLCJfcmVmIiwiY29sb3IiLCJyZXN0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMiIsImlzU2F2ZWRMYXllckNvbmZpZ1YxIiwibGF5ZXJDb25maWciLCJ2aXN1YWxDaGFubmVscyIsInBhcnNlTGF5ZXJDb25maWciLCJzY2hlbWEiLCJfc2NoZW1hJHBhcnNlU2F2ZWRDb24iLCJzYXZlZENvbmZpZyIsInZlcnNpb24iLCJDVVJSRU5UX1ZFUlNJT04iLCJjb25maWciLCJ2aXNTdGF0ZSIsImxheWVyT3JkZXIiLCJwYXJzZVNhdmVkQ29uZmlnIiwiY3VycmVudEl0ZW1zIiwiaXRlbXMiLCJwcmVzZXJ2ZWRPcmRlciIsInVuZGVmaW5lZCIsImRlZmF1bHRTdGFydCIsIm5ld0l0ZW1zIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJpdGVtIiwiZXhwZWN0ZWRJZHgiLCJpbmRleE9mIiwiaW5zZXJ0QXQiLCJwcmVjZWVkSWR4IiwiX2xvb3AiLCJwcmVjZWVkSXRlbUlkIiwiZmluZEluZGV4IiwiYXJyYXlJbnNlcnQiLCJlcnIiLCJjcmVhdGVMYXllckZyb21Db25maWciLCJwYXJzZWRMYXllckNvbmZpZyIsIl92YWxpZGF0ZUxheWVyc0J5RGF0YSIsInZhbGlkYXRlTGF5ZXJzQnlEYXRhc2V0cyIsImxheWVyQ2xhc3NlcyIsImFsbG93RW1wdHlDb2x1bW4iLCJuZXdMYXllciIsInVwZGF0ZUxheWVyRG9tYWluIiwic2VyaWFsaXplRmlsdGVyIiwibmV3RmlsdGVyIiwiX3NlcmlhbGl6ZWRWaXNTdGF0ZSRmIiwic2VyaWFsaXplZFZpc1N0YXRlIiwic2VyaWFsaXplVmlzU3RhdGUiLCJzZXJpYWxpemVMYXllciIsIl9zZXJpYWxpemVkVmlzU3RhdGUkbCIsInNlcmlhbGl6ZUVmZmVjdCIsIm5ld0VmZmVjdCIsIl9zZXJpYWxpemVkVmlzU3RhdGUkZSIsImVmZmVjdHMiLCJlZmZlY3RPcmRlciIsIl9zY2hlbWEkcGFyc2VTYXZlZENvbjIiLCJzYXZlZFN0YXRlIiwiZ2V0Q29uZmlnVG9TYXZlIiwibWVyZ2VMYXllcnMiLCJsYXllcnNUb01lcmdlIiwicHJlc2VydmVMYXllck9yZGVyIiwiZ2V0TGF5ZXJPcmRlckZyb21MYXllcnMiLCJ1bm1lcmdlZCIsInRvTWVyZ2UiLCJfbCRjb25maWciLCJpc01lcmdpbmdEYXRhc2V0cyIsIl92YWxpZGF0ZUxheWVyc0J5RGF0YTIiLCJtZXJnZWRMYXllciIsIl9pbnNlcnRMYXllckF0UmlnaHRPciIsImluc2VydExheWVyQXRSaWdodE9yZGVyIiwibmV3TGF5ZXJPcmRlciIsIm5ld0xheWVycyIsImxheWVyVG9CZU1lcmdlZCIsImN1cnJlbnRMYXllcnMiLCJsYXllcnNUb0luc2VydCIsImN1cnJlbnRPcmRlciIsImN1cnJlbnRMYXllclF1ZXVlIiwiZmluZEJ5SWQiLCJsYXllciIsIkJvb2xlYW4iLCJuZXdMYXllck9yZGVyUXVldWUiLCJtZXJnZUludGVyYWN0aW9ucyIsImludGVyYWN0aW9uVG9CZU1lcmdlZCIsIm1lcmdlZCIsImtleSIsImludGVyYWN0aW9uQ29uZmlnIiwiY3VycmVudENvbmZpZyIsIl9yZWYyIiwiZW5hYmxlZCIsImNvbmZpZ1NhdmVkIiwiY29uZmlnVG9NZXJnZSIsIl9tZXJnZUludGVyYWN0aW9uVG9vbCIsIm1lcmdlSW50ZXJhY3Rpb25Ub29sdGlwQ29uZmlnIiwibWVyZ2VkVG9vbHRpcCIsInVubWVyZ2VkVG9vbHRpcCIsImZpZWxkc1RvU2hvdyIsInRvb2x0aXAiLCJuZXh0U3RhdGUiLCJzYXZlZFVubWVyZ2VkSW50ZXJhY3Rpb24iLCJjb21iaW5lSW50ZXJhY3Rpb25Db25maWdzIiwiY29uZmlncyIsImNvbWJpbmVkIiwiX2xvb3AyIiwidG9CZUNvbWJpbmVkUHJvcHMiLCJjIiwic29tZSIsInAiLCJjb21wYXJlTW9kZSIsImNvbXBhcmVUeXBlIiwiZ2V0VmFsdWVXaXRoSGlnaGVzdE9jY3VycmVuY2UiLCJyZWR1Y2UiLCJhY2MiLCJuZXh0RmllbGRzVG9TaG93IiwiX2xvb3AzIiwibmV4dERhdGFJZEtleSIsIm5leHRUb29sdGlwRmllbGRzIiwibmV4dFRGIiwiZmluZCIsIl9yZWYzIiwiX2FnZ3JlZ2F0ZSIsInNpemUiLCJhZ2dyZWdhdGUiLCJBR0dSRUdBVElPTl9UWVBFUyIsIm1heGltdW0iLCJfdW5tZXJnZWQkdG9vbHRpcCIsIl91bm1lcmdlZCR0b29sdGlwMiIsIl9zdGF0ZSRpbnRlcmFjdGlvblRvQiIsIl91bm1lcmdlZCR0b29sdGlwMyIsInJlcGxhY2VJbnRlcmFjdGlvbkRhdGFzZXRJZHMiLCJkYXRhSWRUb1JlcGxhY2UiLCJfaW50ZXJhY3Rpb25Db25maWckdG8iLCJfaW50ZXJhY3Rpb25Db25maWckdG8yIiwibWVyZ2VTcGxpdE1hcHMiLCJzcGxpdE1hcHMiLCJzbSIsImVudHJpZXMiLCJfcmVmNCIsIl9yZWY1IiwiX3NsaWNlZFRvQXJyYXkyIiwicHVzaFRvIiwiZ2V0SW5pdGlhbE1hcExheWVyc0ZvclNwbGl0TWFwIiwic3BsaXRNYXBzVG9CZU1lcmdlZCIsIm1lcmdlRWZmZWN0cyIsIm5ld0VmZmVjdHMiLCJlZmZlY3QiLCJjcmVhdGVFZmZlY3QiLCJhbGwiLCJpc0NvbmZpZ0FjdGl2ZSIsImlzVmFsaWRUb1NhdmUiLCJ0b29sdGlwQ29uZmlnIiwiX2xvb3A0IiwiYWxsRmllbGRzIiwiZmllbGRzIiwiZm91bmRGaWVsZHNUb1Nob3ciLCJmaWVsZCIsIm1lcmdlTGF5ZXJCbGVuZGluZyIsImxheWVyQmxlbmRpbmciLCJMQVlFUl9CTEVORElOR1MiLCJjb21iaW5lTGF5ZXJCbGVuZGluZ0NvbmZpZ3MiLCJtZXJnZU92ZXJsYXlCbGVuZGluZyIsIm92ZXJsYXlCbGVuZGluZyIsIk9WRVJMQVlfQkxFTkRJTkdTIiwiY29tYmluZU92ZXJsYXlCbGVuZGluZ0NvbmZpZ3MiLCJtZXJnZUFuaW1hdGlvbkNvbmZpZyIsImFuaW1hdGlvbiIsImN1cnJlbnRUaW1lIiwiYW5pbWF0aW9uQ29uZmlnIiwiZG9tYWluIiwiY29tYmluZUFuaW1hdGlvbkNvbmZpZ3MiLCJfYWdncmVnYXRlMiIsIl9hZ2dyZWdhdGUzIiwibWluaW11bSIsInNwZWVkIiwidmFsaWRhdGVTYXZlZExheWVyQ29sdW1ucyIsInNhdmVkQ29scyIsImVtcHR5Q29scyIsIm9wdGlvbnMiLCJjb2x1bW5zIiwiX2xvb3A1IiwiX09iamVjdCRrZXlzIiwiX2kiLCJzYXZlZCIsImZpZWxkSWR4IiwiX3JlZjYiLCJhbGxDb2xGb3VuZCIsImV2ZXJ5IiwidmFsaWRhdGVDb2x1bW4iLCJydiIsInRocm93T25FcnJvciIsInJlcXVpcmVkQ29sdW1ucyIsImsiLCJvcHRpb25hbCIsIm1pc3NpbmdDb2x1bW5zIiwiRXJyb3IiLCJqb2luIiwiY29uZmlnQ29sdW1ucyIsImludmFsaWRDb2x1bW5zIiwiX2NvbHVtbnMkayIsImNvbHVtbiIsInZhbGlkYXRvciIsInZhbGlkYXRlU2F2ZWRUZXh0TGFiZWwiLCJfcmVmNyIsInNhdmVkVGV4dExhYmVsIiwiX3JlZjgiLCJsYXllclRleHRMYWJlbCIsInNhdmVkVGV4dExhYmVscyIsInRleHRMYWJlbCIsImZkIiwiSlNPTiIsInN0cmluZ2lmeSIsImFjY3UiLCJ2YWxpZGF0ZVNhdmVkVmlzdWFsQ2hhbm5lbHMiLCJzYXZlZExheWVyIiwidmFsdWVzIiwiX3JlZjkiLCJzY2FsZSIsImZvdW5kRmllbGQiLCJmb3VuZENoYW5uZWwiLCJ1cGRhdGVMYXllckNvbmZpZyIsInZhbGlkYXRlVmlzdWFsQ2hhbm5lbCIsIl9zYXZlZExheWVyJGNvbmZpZyIsIl9uZXdMYXllciRjb25maWckZmllbCIsImZpZWxkTmFtZSIsIl9sYXllciRjb25maWciLCJ2YWxpZGF0ZUxheWVyIiwidmFsaWRhdGVMYXllcldpdGhEYXRhIiwiX2dldENvbHVtbkNvbmZpZ0ZvclZhbGlkYXRpb24iLCJjb2x1bW5Db25maWciLCJnZXRMYXllckNvbHVtbnMiLCJjb2xNb2RlQ29uZmlnIiwiY29sdW1uTW9kZSIsInN1cHBvcnRlZENvbHVtbk1vZGVzIiwiY29sTW9kZSIsIm9wdGlvbmFsQ29sdW1ucyIsImRhdGFzZXQiLCJ0eXBlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJsYWJlbCIsImlzVmlzaWJsZSIsImhpZGRlbiIsImhpZ2hsaWdodENvbG9yIiwiY29waWVkVmlzQ29uZmlnIiwiY29weUxheWVyQ29uZmlnIiwidmlzQ29uZmlnIiwic2hhbGxvd0NvcHkiLCJ2YWxpZGF0ZVZpc0NvbmZpZyIsIm1lcmdlRWRpdG9yIiwic2F2ZWRFZGl0b3IiLCJfc2F2ZWRFZGl0b3IkdmlzaWJsZSIsImVkaXRvciIsImZlYXR1cmVzIiwidmlzaWJsZSIsImNvbWJpbmVFZGl0b3JDb25maWdzIiwibmV4dENvbmZpZyIsIm1lcmdlRGF0YXNldHNCeU9yZGVyIiwibmV3RGF0YUVudHJpZXMiLCJwcmVzZXJ2ZURhdGFzZXRPcmRlciIsIm5ld0RhdGFzZXRJZHMiLCJfc3RhdGUkcHJlc2VydmVEYXRhc2UiLCJhcnIiLCJfcmVmMTMiLCJ0YWxseXMiLCJNYXAiLCJub3ROdWxsb3JVbmRlZmluZWQiLCJoYXMiLCJzZXQiLCJnZXQiLCJWSVNfU1RBVEVfTUVSR0VSUyIsImV4cG9ydHMiLCJtZXJnZSIsInByb3AiLCJ0b01lcmdlUHJvcCIsInByZXNlcnZlT3JkZXIiLCJyZXBsYWNlUGFyZW50RGF0YXNldElkcyIsInNhdmVVbm1lcmdlZCIsImNvbWJpbmVDb25maWdzIl0sInNvdXJjZXMiOlsiLi4vc3JjL3Zpcy1zdGF0ZS1tZXJnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IHVuaXEgZnJvbSAnbG9kYXNoL3VuaXEnO1xuaW1wb3J0IHBpY2sgZnJvbSAnbG9kYXNoL3BpY2snO1xuaW1wb3J0IGZsYXR0ZW5EZWVwIGZyb20gJ2xvZGFzaC9mbGF0dGVuRGVlcCc7XG5pbXBvcnQgZGVlcG1lcmdlIGZyb20gJ2RlZXBtZXJnZSc7XG5pbXBvcnQge1xuICBhcnJheUluc2VydCxcbiAgZ2V0SW5pdGlhbE1hcExheWVyc0ZvclNwbGl0TWFwLFxuICBhcHBseUZpbHRlcnNUb0RhdGFzZXRzLFxuICB2YWxpZGF0ZUZpbHRlcnNVcGRhdGVEYXRhc2V0cyxcbiAgZmluZEJ5SWQsXG4gIGFnZ3JlZ2F0ZVxufSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnQGtlcGxlci5nbC9sYXllcnMnO1xuaW1wb3J0IHtjcmVhdGVFZmZlY3R9IGZyb20gJ0BrZXBsZXIuZ2wvZWZmZWN0cyc7XG5pbXBvcnQge25vdE51bGxvclVuZGVmaW5lZH0gZnJvbSAnQGtlcGxlci5nbC9jb21tb24tdXRpbHMnO1xuaW1wb3J0IHtBR0dSRUdBVElPTl9UWVBFUywgTEFZRVJfQkxFTkRJTkdTLCBPVkVSTEFZX0JMRU5ESU5HU30gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtDVVJSRU5UX1ZFUlNJT04sIFZpc1N0YXRlLCBWaXNTdGF0ZU1lcmdlcnMsIEtlcGxlckdMU2NoZW1hQ2xhc3N9IGZyb20gJ0BrZXBsZXIuZ2wvc2NoZW1hcyc7XG5cbmltcG9ydCB7XG4gIFBhcnNlZExheWVyLFxuICBQYXJzZWRWaXNTdGF0ZSxcbiAgU2F2ZWRJbnRlcmFjdGlvbkNvbmZpZyxcbiAgVG9vbHRpcEluZm8sXG4gIFNhdmVkRWRpdG9yLFxuICBQYXJzZWRDb25maWcsXG4gIEZpbHRlcixcbiAgRWZmZWN0IGFzIEVmZmVjdFR5cGUsXG4gIFBhcnNlZEVmZmVjdCxcbiAgTGF5ZXJDb2x1bW5zLFxuICBMYXllckNvbHVtbixcbiAgUGFyc2VkRmlsdGVyLFxuICBOZXN0ZWRQYXJ0aWFsLFxuICBTYXZlZEFuaW1hdGlvbkNvbmZpZ1xufSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7S2VwbGVyVGFibGUsIERhdGFzZXRzLCBhc3NpZ25HcHVDaGFubmVscywgcmVzZXRGaWx0ZXJHcHVNb2RlfSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcblxuaW1wb3J0IHtnZXRMYXllck9yZGVyRnJvbUxheWVyc30gZnJvbSAnLi9sYXllci11dGlscyc7XG5cbi8qKlxuICogTWVyZ2UgbG9hZGVkIGZpbHRlcnMgd2l0aCBjdXJyZW50IHN0YXRlLCBpZiBubyBmaWVsZHMgb3IgZGF0YSBhcmUgbG9hZGVkXG4gKiBzYXZlIGl0IGZvciBsYXRlclxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRmlsdGVyczxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgZmlsdGVyc1RvTWVyZ2U6IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2ZpbHRlcnMnXSxcbiAgZnJvbUNvbmZpZz86IGJvb2xlYW5cbik6IFMge1xuICBjb25zdCBwcmVzZXJ2ZUZpbHRlck9yZGVyID0gZnJvbUNvbmZpZ1xuICAgID8gZmlsdGVyc1RvTWVyZ2U/Lm1hcChsID0+IGwuaWQpXG4gICAgOiBzdGF0ZS5wcmVzZXJ2ZUZpbHRlck9yZGVyO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShmaWx0ZXJzVG9NZXJnZSkgfHwgIWZpbHRlcnNUb01lcmdlLmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHt2YWxpZGF0ZWQsIGZhaWxlZCwgdXBkYXRlZERhdGFzZXRzfSA9IHZhbGlkYXRlRmlsdGVyc1VwZGF0ZURhdGFzZXRzKHN0YXRlLCBmaWx0ZXJzVG9NZXJnZSk7XG4gIGxldCB1cGRhdGVkRmlsdGVycyA9IGluc2VydEl0ZW1CYXNlZE9uUHJlc2VydmVkT3JkZXIoXG4gICAgc3RhdGUuZmlsdGVycyxcbiAgICB2YWxpZGF0ZWQsXG4gICAgcHJlc2VydmVGaWx0ZXJPcmRlclxuICApO1xuXG4gIC8vIG1lcmdlIGZpbHRlciB3aXRoIGV4aXN0aW5nXG4gIHVwZGF0ZWRGaWx0ZXJzID0gcmVzZXRGaWx0ZXJHcHVNb2RlKHVwZGF0ZWRGaWx0ZXJzKTtcbiAgdXBkYXRlZEZpbHRlcnMgPSBhc3NpZ25HcHVDaGFubmVscyh1cGRhdGVkRmlsdGVycyk7XG4gIC8vIGZpbHRlciBkYXRhXG4gIGNvbnN0IGRhdGFzZXRzVG9GaWx0ZXIgPSB1bmlxKGZsYXR0ZW5EZWVwKHZhbGlkYXRlZC5tYXAoZiA9PiBmLmRhdGFJZCkpKTtcblxuICBjb25zdCBmaWx0ZXJlZCA9IGFwcGx5RmlsdGVyc1RvRGF0YXNldHMoXG4gICAgZGF0YXNldHNUb0ZpbHRlcixcbiAgICB1cGRhdGVkRGF0YXNldHMsXG4gICAgdXBkYXRlZEZpbHRlcnMsXG4gICAgc3RhdGUubGF5ZXJzXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiB1cGRhdGVkRmlsdGVycyxcbiAgICBkYXRhc2V0czogZmlsdGVyZWQsXG4gICAgcHJlc2VydmVGaWx0ZXJPcmRlcixcbiAgICBmaWx0ZXJUb0JlTWVyZ2VkOiBbLi4uc3RhdGUuZmlsdGVyVG9CZU1lcmdlZCwgLi4uZmFpbGVkXVxuICB9O1xufVxuXG4vLyByZXBsYWNlIGRhdGFJZCBpbiBzYXZlZCBGaWx0ZXJcbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlRmlsdGVyRGF0YXNldElkcyhcbiAgc2F2ZWRGaWx0ZXI6IEZpbHRlcltdLFxuICBkYXRhSWQ6IHN0cmluZyxcbiAgZGF0YUlkVG9Vc2U6IHN0cmluZ1xuKSB7XG4gIGNvbnN0IHJlcGxhY2VkOiBGaWx0ZXJbXSA9IFtdO1xuICBzYXZlZEZpbHRlci5mb3JFYWNoKGZpbHRlciA9PiB7XG4gICAgaWYgKGZpbHRlci5kYXRhSWQuaW5jbHVkZXMoZGF0YUlkKSkge1xuICAgICAgY29uc3QgbmV3RGF0YUlkID0gZmlsdGVyLmRhdGFJZC5tYXAoZCA9PiAoZCA9PT0gZGF0YUlkID8gZGF0YUlkVG9Vc2UgOiBkKSk7XG4gICAgICBsZXQgcGxvdFR5cGU7XG4gICAgICAvLyBUT0RPOiBtb3JlIGdlbmVyaWMgYXBwcm9hY2ggdG8gc2F2ZSBwbG90VHlwZS5jb2xvcnNCeURhdGFJZFxuICAgICAgaWYgKGZpbHRlci5wbG90VHlwZT8uY29sb3JzQnlEYXRhSWQ/LltkYXRhSWRdKSB7XG4gICAgICAgIC8vIHJlcGxhY2UgY29sb3JCeURhdGFJZCBpbiBmaWx0ZXIucGxvdFR5cGVcbiAgICAgICAgY29uc3Qge1tkYXRhSWRdOiBjb2xvciwgLi4ucmVzdH0gPSBmaWx0ZXIucGxvdFR5cGU/LmNvbG9yc0J5RGF0YUlkIHx8IHt9O1xuICAgICAgICBwbG90VHlwZSA9IHtcbiAgICAgICAgICAuLi5maWx0ZXIucGxvdFR5cGUsXG4gICAgICAgICAgY29sb3JzQnlEYXRhSWQ6IHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBbZGF0YUlkVG9Vc2VdOiBjb2xvclxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJlcGxhY2VkLnB1c2goe1xuICAgICAgICAuLi5maWx0ZXIsXG4gICAgICAgIGRhdGFJZDogbmV3RGF0YUlkLFxuICAgICAgICAuLi4ocGxvdFR5cGUgPyB7cGxvdFR5cGV9IDoge30pXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVwbGFjZWQubGVuZ3RoID8gcmVwbGFjZWQgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYXZlZExheWVyQ29uZmlnVjEobGF5ZXJDb25maWc6IGFueSk6IGJvb2xlYW4ge1xuICAvLyBleHBvcnRlZCBsYXllciBjb25maWd1cmF0aW9uIGNvbnRhaW5zIHZpc3VhbENoYW5uZWxzIHByb3BlcnR5XG4gIHJldHVybiBsYXllckNvbmZpZz8udmlzdWFsQ2hhbm5lbHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxheWVyQ29uZmlnKFxuICBzY2hlbWE6IEtlcGxlckdMU2NoZW1hQ2xhc3MsXG4gIGxheWVyQ29uZmlnOiBhbnlcbik6IFBhcnNlZExheWVyIHwgdW5kZWZpbmVkIHtcbiAgLy8gYXNzdW1lIHRoZSBsYXllciBjb25maWcgaXMgY3VycmVudCB2ZXJzaW9uXG4gIGNvbnN0IHNhdmVkQ29uZmlnID0ge1xuICAgIHZlcnNpb246IENVUlJFTlRfVkVSU0lPTixcbiAgICBjb25maWc6IHtcbiAgICAgIHZpc1N0YXRlOiB7bGF5ZXJzOiBbbGF5ZXJDb25maWddLCBsYXllck9yZGVyOiBbbGF5ZXJDb25maWcuaWRdfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2NoZW1hLnBhcnNlU2F2ZWRDb25maWcoc2F2ZWRDb25maWcpPy52aXNTdGF0ZT8ubGF5ZXJzPy5bMF07XG59XG5cbmZ1bmN0aW9uIGluc2VydEl0ZW1CYXNlZE9uUHJlc2VydmVkT3JkZXIoXG4gIGN1cnJlbnRJdGVtczogRmlsdGVyW10sXG4gIGl0ZW1zOiBGaWx0ZXJbXSxcbiAgcHJlc2VydmVkT3JkZXI6IGFueVtdID0gW10sXG4gIGRlZmF1bHRTdGFydD86IGJvb2xlYW5cbikge1xuICBsZXQgbmV3SXRlbXMgPSBbLi4uY3VycmVudEl0ZW1zXTtcblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICBjb25zdCBleHBlY3RlZElkeCA9IHByZXNlcnZlZE9yZGVyLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgLy8gaW5zZXJ0QXQgdGhlIGVuZCBieSBkZWZhdWx0XG4gICAgbGV0IGluc2VydEF0ID0gZGVmYXVsdFN0YXJ0ID8gMCA6IG5ld0l0ZW1zLmxlbmd0aDtcbiAgICBpZiAoZXhwZWN0ZWRJZHggPiAwKSB7XG4gICAgICAvLyBsb29rIGZvciBsYXllciB0byBpbnNlcnQgYWZ0ZXJcbiAgICAgIGxldCBpID0gZXhwZWN0ZWRJZHggKyAxO1xuICAgICAgbGV0IHByZWNlZWRJZHggPSAtMTtcbiAgICAgIHdoaWxlIChpLS0gPiAwICYmIHByZWNlZWRJZHggPCAwKSB7XG4gICAgICAgIC8vIGtlZXAgbG9va2luZyBmb3IgcHJlY2VlZCBsYXllciB0aGF0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGNvbnN0IHByZWNlZWRJdGVtSWQgPSBwcmVzZXJ2ZWRPcmRlcltpIC0gMV07XG4gICAgICAgIHByZWNlZWRJZHggPSBuZXdJdGVtcy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBwcmVjZWVkSXRlbUlkKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVjZWVkSWR4ID4gLTEpIHtcbiAgICAgICAgLy8gaWYgZm91bmRcbiAgICAgICAgaW5zZXJ0QXQgPSBwcmVjZWVkSWR4ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgbmV3SXRlbXMgPSBhcnJheUluc2VydChuZXdJdGVtcywgaW5zZXJ0QXQsIGl0ZW0pO1xuICB9XG4gIHJldHVybiBuZXdJdGVtcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxheWVyRnJvbUNvbmZpZyhzdGF0ZTogVmlzU3RhdGUsIGxheWVyQ29uZmlnOiBhbnkpOiBMYXllciB8IG51bGwge1xuICAvLyBjaGVjayBpZiB0aGUgbGF5ZXIgY29uZmlnIGlzIHBhcnNlZFxuICBjb25zdCBwYXJzZWRMYXllckNvbmZpZyA9IGlzU2F2ZWRMYXllckNvbmZpZ1YxKGxheWVyQ29uZmlnKVxuICAgID8gcGFyc2VMYXllckNvbmZpZyhzdGF0ZS5zY2hlbWEsIGxheWVyQ29uZmlnKVxuICAgIDogbGF5ZXJDb25maWc7XG5cbiAgaWYgKCFwYXJzZWRMYXllckNvbmZpZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGZpcnN0IHZhbGlkYXRlIGNvbmZpZyBhZ2FpbnN0IGRhdGFzZXRcbiAgY29uc3Qge3ZhbGlkYXRlZCwgZmFpbGVkfSA9IHZhbGlkYXRlTGF5ZXJzQnlEYXRhc2V0cyhcbiAgICBzdGF0ZS5kYXRhc2V0cyxcbiAgICBzdGF0ZS5sYXllckNsYXNzZXMsXG4gICAgW3BhcnNlZExheWVyQ29uZmlnXSxcbiAgICB7YWxsb3dFbXB0eUNvbHVtbjogdHJ1ZX1cbiAgKTtcblxuICBpZiAoZmFpbGVkPy5sZW5ndGggfHwgIXZhbGlkYXRlZC5sZW5ndGgpIHtcbiAgICAvLyBmYWlsZWRcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG5ld0xheWVyID0gdmFsaWRhdGVkWzBdO1xuICBuZXdMYXllci51cGRhdGVMYXllckRvbWFpbihzdGF0ZS5kYXRhc2V0cyk7XG4gIHJldHVybiBuZXdMYXllcjtcbn1cblxuLyoqXG4gKiBHZXQgbG9hZGVkIGZpbHRlciBmcm9tIHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVGaWx0ZXIoXG4gIG5ld0ZpbHRlcjogRmlsdGVyLFxuICBzY2hlbWE6IEtlcGxlckdMU2NoZW1hQ2xhc3Ncbik6IFBhcnNlZEZpbHRlciB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHNlcmlhbGl6ZWRWaXNTdGF0ZSA9IHNlcmlhbGl6ZVZpc1N0YXRlKHtmaWx0ZXJzOiBbbmV3RmlsdGVyXX0sIHNjaGVtYSk7XG4gIHJldHVybiBzZXJpYWxpemVkVmlzU3RhdGU/LmZpbHRlcnM/LlswXTtcbn1cblxuLyoqXG4gKiBHZXQgbG9hZGVkIGxheWVyIGZyb20gc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUxheWVyKFxuICBuZXdMYXllcjogTGF5ZXIsXG4gIHNjaGVtYTogS2VwbGVyR0xTY2hlbWFDbGFzc1xuKTogUGFyc2VkTGF5ZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCBzZXJpYWxpemVkVmlzU3RhdGUgPSBzZXJpYWxpemVWaXNTdGF0ZShcbiAgICB7bGF5ZXJzOiBbbmV3TGF5ZXJdLCBsYXllck9yZGVyOiBbbmV3TGF5ZXIuaWRdfSxcbiAgICBzY2hlbWFcbiAgKTtcbiAgcmV0dXJuIHNlcmlhbGl6ZWRWaXNTdGF0ZT8ubGF5ZXJzPy5bMF07XG59XG5cbi8qKlxuICogR2V0IGxvYWRlZCBlZmZlY3QgZnJvbSBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplRWZmZWN0KFxuICBuZXdFZmZlY3Q6IEVmZmVjdFR5cGUsXG4gIHNjaGVtYTogS2VwbGVyR0xTY2hlbWFDbGFzc1xuKTogUGFyc2VkRWZmZWN0IHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc2VyaWFsaXplZFZpc1N0YXRlID0gc2VyaWFsaXplVmlzU3RhdGUoXG4gICAge2VmZmVjdHM6IFtuZXdFZmZlY3RdLCBlZmZlY3RPcmRlcjogW25ld0VmZmVjdC5pZF19LFxuICAgIHNjaGVtYVxuICApO1xuICByZXR1cm4gc2VyaWFsaXplZFZpc1N0YXRlPy5lZmZlY3RzPy5bMF07XG59XG5cbi8qKlxuICogR2V0IHZpcyBzdGF0ZSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVZpc1N0YXRlKFxuICB2aXNTdGF0ZTogUGFydGlhbDxWaXNTdGF0ZT4sXG4gIHNjaGVtYTogS2VwbGVyR0xTY2hlbWFDbGFzc1xuKTogUGFyc2VkVmlzU3RhdGUgfCB1bmRlZmluZWQge1xuICBjb25zdCBzYXZlZFN0YXRlID0gc2NoZW1hLmdldENvbmZpZ1RvU2F2ZSh7XG4gICAgdmlzU3RhdGVcbiAgfSk7XG4gIHJldHVybiBzYXZlZFN0YXRlID8gc2NoZW1hLnBhcnNlU2F2ZWRDb25maWcoc2F2ZWRTdGF0ZSk/LnZpc1N0YXRlIDogdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBNZXJnZSBsYXllcnMgZnJvbSBkZS1zZXJpYWxpemVkIHN0YXRlLCBpZiBubyBmaWVsZHMgb3IgZGF0YSBhcmUgbG9hZGVkXG4gKiBzYXZlIGl0IGZvciBsYXRlclxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTGF5ZXJzPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBsYXllcnNUb01lcmdlOiBOb25OdWxsYWJsZTxQYXJzZWRDb25maWdbJ3Zpc1N0YXRlJ10+WydsYXllcnMnXSA9IFtdLFxuICBmcm9tQ29uZmlnPzogYm9vbGVhblxuKTogUyB7XG4gIGNvbnN0IHByZXNlcnZlTGF5ZXJPcmRlciA9IGZyb21Db25maWdcbiAgICA/IGdldExheWVyT3JkZXJGcm9tTGF5ZXJzKGxheWVyc1RvTWVyZ2UpXG4gICAgOiBzdGF0ZS5wcmVzZXJ2ZUxheWVyT3JkZXI7XG4gIGlmICghQXJyYXkuaXNBcnJheShsYXllcnNUb01lcmdlKSB8fCAhbGF5ZXJzVG9NZXJnZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgLy8gZG9uJ3QgbWVyZ2UgbGF5ZXIgaWYgZGF0YXNldCBpcyBiZWluZyBtZXJnZWRcbiAgY29uc3QgdW5tZXJnZWQ6IFBhcnNlZExheWVyW10gPSBbXTtcbiAgY29uc3QgdG9NZXJnZTogUGFyc2VkTGF5ZXJbXSA9IFtdO1xuICBsYXllcnNUb01lcmdlLmZvckVhY2goKGw6IFBhcnNlZExheWVyKSA9PiB7XG4gICAgaWYgKGw/LmNvbmZpZz8uZGF0YUlkICYmIHN0YXRlLmlzTWVyZ2luZ0RhdGFzZXRzW2wuY29uZmlnLmRhdGFJZF0pIHtcbiAgICAgIHVubWVyZ2VkLnB1c2gobCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvTWVyZ2UucHVzaChsKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHt2YWxpZGF0ZWQ6IG1lcmdlZExheWVyLCBmYWlsZWR9ID0gdmFsaWRhdGVMYXllcnNCeURhdGFzZXRzKFxuICAgIHN0YXRlLmRhdGFzZXRzLFxuICAgIHN0YXRlLmxheWVyQ2xhc3NlcyxcbiAgICB0b01lcmdlXG4gICk7XG4gIHVubWVyZ2VkLnB1c2goLi4uZmFpbGVkKTtcbiAgLy8gcHV0IG5ldyBsYXllcnMgaW4gZnJvbnQgb2YgY3VycmVudCBsYXllcnNcbiAgY29uc3Qge25ld0xheWVyT3JkZXIsIG5ld0xheWVyc30gPSBpbnNlcnRMYXllckF0UmlnaHRPcmRlcihcbiAgICBzdGF0ZS5sYXllcnMsXG4gICAgbWVyZ2VkTGF5ZXIsXG4gICAgc3RhdGUubGF5ZXJPcmRlcixcbiAgICBwcmVzZXJ2ZUxheWVyT3JkZXJcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogbmV3TGF5ZXJzLFxuICAgIGxheWVyT3JkZXI6IG5ld0xheWVyT3JkZXIsXG4gICAgcHJlc2VydmVMYXllck9yZGVyLFxuICAgIGxheWVyVG9CZU1lcmdlZDogWy4uLnN0YXRlLmxheWVyVG9CZU1lcmdlZCwgLi4udW5tZXJnZWRdXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRMYXllckF0UmlnaHRPcmRlcihcbiAgY3VycmVudExheWVycyxcbiAgbGF5ZXJzVG9JbnNlcnQsXG4gIGN1cnJlbnRPcmRlcixcbiAgcHJlc2VydmVkT3JkZXI6IHN0cmluZ1tdID0gW11cbikge1xuICBpZiAoIWxheWVyc1RvSW5zZXJ0Py5sZW5ndGgpIHtcbiAgICByZXR1cm4ge25ld0xheWVyczogY3VycmVudExheWVycywgbmV3TGF5ZXJPcmRlcjogY3VycmVudE9yZGVyfTtcbiAgfVxuICAvLyBwZXJzZXJ2ZWRPcmRlciBbJ2EnLCAnYicsICdjJ107XG4gIC8vIGxheWVyT3JkZXIgWydhJywgJ2InLCAnYyddXG4gIGNvbnN0IGN1cnJlbnRMYXllclF1ZXVlID0gY3VycmVudE9yZGVyXG4gICAgLm1hcChpZCA9PiBmaW5kQnlJZChpZCkoY3VycmVudExheWVycykpXG4gICAgLmZpbHRlcihsYXllciA9PiBCb29sZWFuKGxheWVyKSk7XG4gIGNvbnN0IG5ld0xheWVycyA9IGN1cnJlbnRMYXllcnMuY29uY2F0KGxheWVyc1RvSW5zZXJ0KTtcbiAgY29uc3QgbmV3TGF5ZXJPcmRlclF1ZXVlID0gaW5zZXJ0SXRlbUJhc2VkT25QcmVzZXJ2ZWRPcmRlcihcbiAgICBjdXJyZW50TGF5ZXJRdWV1ZSxcbiAgICBsYXllcnNUb0luc2VydCxcbiAgICBwcmVzZXJ2ZWRPcmRlcixcbiAgICB0cnVlXG4gICk7XG5cbiAgLy8gcmVjb25zdHJ1Y3QgbGF5ZXJPcmRlciBhZnRlciBpbnNlcnRcbiAgY29uc3QgbmV3TGF5ZXJPcmRlciA9IGdldExheWVyT3JkZXJGcm9tTGF5ZXJzKG5ld0xheWVyT3JkZXJRdWV1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuZXdMYXllck9yZGVyLFxuICAgIG5ld0xheWVyc1xuICB9O1xufVxuXG4vKipcbiAqIE1lcmdlIGludGVyYWN0aW9ucyB3aXRoIHNhdmVkIGNvbmZpZ1xuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSW50ZXJhY3Rpb25zPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBpbnRlcmFjdGlvblRvQmVNZXJnZWQ6IFBhcnRpYWw8U2F2ZWRJbnRlcmFjdGlvbkNvbmZpZz4gfCB1bmRlZmluZWRcbik6IFMge1xuICBjb25zdCBtZXJnZWQ6IE5lc3RlZFBhcnRpYWw8U2F2ZWRJbnRlcmFjdGlvbkNvbmZpZz4gPSB7fTtcbiAgY29uc3QgdW5tZXJnZWQ6IFBhcnRpYWw8U2F2ZWRJbnRlcmFjdGlvbkNvbmZpZz4gPSB7fTtcblxuICBpZiAoaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkKSB7XG4gICAgKE9iamVjdC5rZXlzKGludGVyYWN0aW9uVG9CZU1lcmdlZCkgYXMgQXJyYXk8a2V5b2YgU2F2ZWRJbnRlcmFjdGlvbkNvbmZpZz4pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICghc3RhdGUuaW50ZXJhY3Rpb25Db25maWdba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRDb25maWcgPVxuICAgICAgICBrZXkgPT09ICd0b29sdGlwJyB8fCBrZXkgPT09ICdicnVzaCcgPyBzdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZ1trZXldLmNvbmZpZyA6IG51bGw7XG5cbiAgICAgIGNvbnN0IHtlbmFibGVkLCAuLi5jb25maWdTYXZlZH0gPSBpbnRlcmFjdGlvblRvQmVNZXJnZWRba2V5XSB8fCB7fTtcblxuICAgICAgbGV0IGNvbmZpZ1RvTWVyZ2UgPSBjb25maWdTYXZlZDtcblxuICAgICAgaWYgKGtleSA9PT0gJ3Rvb2x0aXAnKSB7XG4gICAgICAgIGNvbnN0IHttZXJnZWRUb29sdGlwLCB1bm1lcmdlZFRvb2x0aXB9ID0gbWVyZ2VJbnRlcmFjdGlvblRvb2x0aXBDb25maWcoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgY29uZmlnU2F2ZWQgYXMgU2F2ZWRJbnRlcmFjdGlvbkNvbmZpZ1sndG9vbHRpcCddXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gbWVyZ2UgbmV3IGRhdGFzZXQgdG9vbHRpcHMgd2l0aCBvcmlnaW5hbCBkYXRhc2V0IHRvb2x0aXBzXG4gICAgICAgIGNvbmZpZ1RvTWVyZ2UgPSB7XG4gICAgICAgICAgZmllbGRzVG9TaG93OiB7XG4gICAgICAgICAgICAuLi4oY3VycmVudENvbmZpZyBhcyBUb29sdGlwSW5mb1snY29uZmlnJ10pLmZpZWxkc1RvU2hvdyxcbiAgICAgICAgICAgIC4uLm1lcmdlZFRvb2x0aXBcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHVubWVyZ2VkVG9vbHRpcCkubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIHVubWVyZ2VkLnRvb2x0aXAgPSB7ZmllbGRzVG9TaG93OiB1bm1lcmdlZFRvb2x0aXAsIGVuYWJsZWQ6IEJvb2xlYW4oZW5hYmxlZCl9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lcmdlZFtrZXldID0ge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZ1trZXldLFxuICAgICAgICBlbmFibGVkOiBCb29sZWFuKGVuYWJsZWQpLFxuICAgICAgICAuLi4oY3VycmVudENvbmZpZ1xuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBjb25maWc6IHBpY2soXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLi4uY3VycmVudENvbmZpZyxcbiAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZ1RvTWVyZ2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGN1cnJlbnRDb25maWcpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHt9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG5leHRTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBpbnRlcmFjdGlvbkNvbmZpZzoge1xuICAgICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICAuLi5tZXJnZWRcbiAgICB9LFxuICAgIGludGVyYWN0aW9uVG9CZU1lcmdlZDogc2F2ZWRVbm1lcmdlZEludGVyYWN0aW9uKHN0YXRlLCB1bm1lcmdlZClcbiAgfTtcbiAgcmV0dXJuIG5leHRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29tYmluZUludGVyYWN0aW9uQ29uZmlncyhjb25maWdzOiBTYXZlZEludGVyYWN0aW9uQ29uZmlnW10pOiBTYXZlZEludGVyYWN0aW9uQ29uZmlnIHtcbiAgY29uc3QgY29tYmluZWQgPSB7Li4uY29uZmlnc1swXX07XG4gIC8vIGhhbmRsZSBlYWNoIHByb3BlcnR5IGtleSBvZiBhbiBgSW50ZXJhY3Rpb25Db25maWdgLCBlLmcuIHRvb2x0aXAsIGdlb2NvZGVyLCBicnVzaCwgY29vcmRpbmF0ZVxuICAvLyBieSBjb21iaW5pbmcgdmFsdWVzIGZvciBlYWNoIGFtb25nIGFsbCBwYXNzZWQgaW4gY29uZmlnc1xuXG4gIGZvciAoY29uc3Qga2V5IGluIGNvbWJpbmVkKSB7XG4gICAgY29uc3QgdG9CZUNvbWJpbmVkUHJvcHMgPSBjb25maWdzLm1hcChjID0+IGNba2V5XSk7XG5cbiAgICAvLyBhbGwgb2YgdGhlc2UgaGF2ZSBhbiBlbmFibGVkIGJvb2xlYW5cbiAgICBjb21iaW5lZFtrZXldID0ge1xuICAgICAgLy8gYXJlIGFueSBvZiB0aGUgY29uZmlncycgZW5hYmxlZCB2YWx1ZXMgdHJ1ZT9cbiAgICAgIGVuYWJsZWQ6IHRvQmVDb21iaW5lZFByb3BzLnNvbWUocCA9PiBwPy5lbmFibGVkKVxuICAgIH07XG5cbiAgICBpZiAoa2V5ID09PSAndG9vbHRpcCcpIHtcbiAgICAgIC8vIGFyZSBhbnkgb2YgdGhlIGNvbmZpZ3MnIGNvbXBhcmVNb2RlIHZhbHVlcyB0cnVlP1xuICAgICAgY29tYmluZWRba2V5XS5jb21wYXJlTW9kZSA9IHRvQmVDb21iaW5lZFByb3BzLnNvbWUocCA9PiBwPy5jb21wYXJlTW9kZSk7XG5cbiAgICAgIC8vIHJldHVybiB0aGUgY29tcGFyZSB0eXBlIG1vZGUsIGl0IHdpbGwgYmUgZWl0aGVyIGFic29sdXRlIG9yIHJlbGF0aXZlXG4gICAgICBjb21iaW5lZFtrZXldLmNvbXBhcmVUeXBlID0gZ2V0VmFsdWVXaXRoSGlnaGVzdE9jY3VycmVuY2UoXG4gICAgICAgIHRvQmVDb21iaW5lZFByb3BzLm1hcChwID0+IHAuY29tcGFyZVR5cGUpXG4gICAgICApO1xuXG4gICAgICAvLyBjb21iaW5lIGZpZWxkc1RvU2hvdyBhbW9uZyBhbGwgZGF0YXNldCBpZHNcbiAgICAgIGNvbWJpbmVkW2tleV0uZmllbGRzVG9TaG93ID0gdG9CZUNvbWJpbmVkUHJvcHNcbiAgICAgICAgLm1hcChwID0+IHAuZmllbGRzVG9TaG93KVxuICAgICAgICAucmVkdWNlKChhY2MsIG5leHRGaWVsZHNUb1Nob3cpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5leHREYXRhSWRLZXkgaW4gbmV4dEZpZWxkc1RvU2hvdykge1xuICAgICAgICAgICAgY29uc3QgbmV4dFRvb2x0aXBGaWVsZHMgPSBuZXh0RmllbGRzVG9TaG93W25leHREYXRhSWRLZXldO1xuICAgICAgICAgICAgaWYgKCFhY2NbbmV4dERhdGFJZEtleV0pIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlIGRhdGFzZXQgaWQgaXMgbm90IHByZXNlbnQgaW4gdGhlIGFjY3VtdWxhdG9yXG4gICAgICAgICAgICAgIC8vIHRoZW4gYWRkIGl0IHdpdGggaXRzIHRvb2x0aXAgZmllbGRzXG4gICAgICAgICAgICAgIGFjY1tuZXh0RGF0YUlkS2V5XSA9IG5leHRUb29sdGlwRmllbGRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBkYXRhc2V0IGlkIGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgYWNjdW11bGF0b3JcbiAgICAgICAgICAgICAgLy8gc28gb25seSBhZGQgdGhlIG5leHQgdG9vbHRpcCBmaWVsZHMgZm9yIHRoaXMgZGF0YXNldCdzIGFycmF5IGlmIHRoZXkgYXJlIG5vdCBhbHJlYWR5IHByZXNlbnQsXG4gICAgICAgICAgICAgIC8vIHVzaW5nIHRoZSB0b29sdGlwRmllbGQubmFtZSBwcm9wZXJ0eSBmb3IgdW5pcXVlbmVzc1xuICAgICAgICAgICAgICBuZXh0VG9vbHRpcEZpZWxkcy5mb3JFYWNoKG5leHRURiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NbbmV4dERhdGFJZEtleV0uZmluZCgoe25hbWV9KSA9PiBuZXh0VEYubmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIGFjY1tuZXh0RGF0YUlkS2V5XS5wdXNoKG5leHRURik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdicnVzaCcpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGJpZ2dlc3QgYnJ1c2ggc2l6ZVxuICAgICAgY29tYmluZWRba2V5XS5zaXplID1cbiAgICAgICAgYWdncmVnYXRlKHRvQmVDb21iaW5lZFByb3BzLCBBR0dSRUdBVElPTl9UWVBFUy5tYXhpbXVtLCBwID0+IHAuc2l6ZSkgPz8gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tYmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNhdmVkVW5tZXJnZWRJbnRlcmFjdGlvbjxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgdW5tZXJnZWQ6IFBhcnRpYWw8U2F2ZWRJbnRlcmFjdGlvbkNvbmZpZz5cbikge1xuICBpZiAoIXVubWVyZ2VkPy50b29sdGlwPy5maWVsZHNUb1Nob3cpIHtcbiAgICByZXR1cm4gc3RhdGUuaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkLnRvb2x0aXAsXG4gICAgICAuLi4odHlwZW9mIHVubWVyZ2VkPy50b29sdGlwPy5lbmFibGVkID09PSAnYm9vbGVhbidcbiAgICAgICAgPyB7ZW5hYmxlZDogdW5tZXJnZWQudG9vbHRpcC5lbmFibGVkfVxuICAgICAgICA6IHt9KSxcbiAgICAgIGZpZWxkc1RvU2hvdzoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvblRvQmVNZXJnZWQ/LnRvb2x0aXA/LmZpZWxkc1RvU2hvdyxcbiAgICAgICAgLi4udW5tZXJnZWQ/LnRvb2x0aXA/LmZpZWxkc1RvU2hvd1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUludGVyYWN0aW9uRGF0YXNldElkcyhpbnRlcmFjdGlvbkNvbmZpZywgZGF0YUlkOiBzdHJpbmcsIGRhdGFJZFRvUmVwbGFjZTogc3RyaW5nKSB7XG4gIGlmIChpbnRlcmFjdGlvbkNvbmZpZz8udG9vbHRpcD8uZmllbGRzVG9TaG93W2RhdGFJZF0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIC4uLmludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAsXG4gICAgICAgIGZpZWxkc1RvU2hvdzoge1xuICAgICAgICAgIFtkYXRhSWRUb1JlcGxhY2VdOiBpbnRlcmFjdGlvbkNvbmZpZz8udG9vbHRpcD8uZmllbGRzVG9TaG93W2RhdGFJZF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogTWVyZ2Ugc3BsaXRNYXBzIGNvbmZpZyB3aXRoIGN1cnJlbnQgdmlzU3RldGUuXG4gKiAxLiBpZiBjdXJyZW50IG1hcCBpcyBzcGxpdCwgYnV0IHNwbGl0TWFwIERPRVNOT1QgY29udGFpbiBtYXBzXG4gKiAgICA6IGRvbid0IG1lcmdlIGFueXRoaW5nXG4gKiAyLiBpZiBjdXJyZW50IG1hcCBpcyBOT1Qgc3BsaXQsIGJ1dCBzcGxpdE1hcHMgY29udGFpbiBtYXBzXG4gKiAgICA6IGFkZCB0byBzcGxpdE1hcHMsIGFuZCBhZGQgY3VycmVudCBsYXllcnMgdG8gc3BsaXRNYXBzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVNwbGl0TWFwczxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgc3BsaXRNYXBzOiBOb25OdWxsYWJsZTxQYXJzZWRDb25maWdbJ3Zpc1N0YXRlJ10+WydzcGxpdE1hcHMnXSA9IFtdXG4pOiBTIHtcbiAgY29uc3QgbWVyZ2VkID0gWy4uLnN0YXRlLnNwbGl0TWFwc107XG4gIGNvbnN0IHVubWVyZ2VkID0gW107XG4gIHNwbGl0TWFwcy5mb3JFYWNoKChzbSwgaSkgPT4ge1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhzbS5sYXllcnMpO1xuICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGVudHJpZXMuZm9yRWFjaCgoW2lkLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgbGF5ZXIgZXhpc3RzXG4gICAgICAgIGNvbnN0IHB1c2hUbyA9IHN0YXRlLmxheWVycy5maW5kKGwgPT4gbC5pZCA9PT0gaWQpID8gbWVyZ2VkIDogdW5tZXJnZWQ7XG5cbiAgICAgICAgLy8gY3JlYXRlIG1hcCBwYW5lbCBpZiBjdXJyZW50IG1hcCBpcyBub3Qgc3BsaXRcbiAgICAgICAgcHVzaFRvW2ldID0gcHVzaFRvW2ldIHx8IHtcbiAgICAgICAgICAvLyBrZWVwIGlkXG4gICAgICAgICAgLi4uc20sXG4gICAgICAgICAgbGF5ZXJzOiBwdXNoVG8gPT09IG1lcmdlZCA/IGdldEluaXRpYWxNYXBMYXllcnNGb3JTcGxpdE1hcChzdGF0ZS5sYXllcnMpIDogW11cbiAgICAgICAgfTtcbiAgICAgICAgcHVzaFRvW2ldLmxheWVycyA9IHtcbiAgICAgICAgICAuLi5wdXNoVG9baV0ubGF5ZXJzLFxuICAgICAgICAgIFtpZF06IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgYXJlIG1lcmdpbmcgaWYgdGhlcmUgYXJlIG5vIGxheWVycyBpbiBib3RoIHNwbGl0IG1hcFxuICAgICAgbWVyZ2VkLnB1c2goc20pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBzcGxpdE1hcHM6IG1lcmdlZCxcbiAgICBzcGxpdE1hcHNUb0JlTWVyZ2VkOiBbLi4uc3RhdGUuc3BsaXRNYXBzVG9CZU1lcmdlZCwgLi4udW5tZXJnZWRdXG4gIH07XG59XG5cbi8qKlxuICogTWVyZ2UgZWZmZWN0cyB3aXRoIHNhdmVkIGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VFZmZlY3RzPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBlZmZlY3RzOiBOb25OdWxsYWJsZTxQYXJzZWRDb25maWdbJ3Zpc1N0YXRlJ10+WydlZmZlY3RzJ10sXG4gIGZyb21Db25maWc/OiBib29sZWFuXG4pOiBTIHtcbiAgY29uc3QgbmV3RWZmZWN0cyA9IFtcbiAgICAuLi5zdGF0ZS5lZmZlY3RzLFxuICAgIC4uLihlZmZlY3RzIHx8IFtdKVxuICAgICAgLm1hcChlZmZlY3QgPT4ge1xuICAgICAgICByZXR1cm4gZnJvbUNvbmZpZ1xuICAgICAgICAgID8gY3JlYXRlRWZmZWN0KFxuICAgICAgICAgICAgICBkZWVwbWVyZ2UuYWxsKFtcbiAgICAgICAgICAgICAgICBlZmZlY3QsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLy8gY29sbGFwc2UgYWxsIHBhbmVscyB3aGVuIGxvYWRpbmcgZWZmZWN0c1xuICAgICAgICAgICAgICAgICAgaXNDb25maWdBY3RpdmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogKGVmZmVjdCBhcyBFZmZlY3RUeXBlKTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKGVmZmVjdCA9PiB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGVmZmVjdCAmJiBlZmZlY3QuaXNWYWxpZFRvU2F2ZSgpKTtcbiAgICAgIH0pXG4gIF07XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWZmZWN0czogbmV3RWZmZWN0cyxcbiAgICBlZmZlY3RPcmRlcjogbmV3RWZmZWN0cy5tYXAoZWZmZWN0ID0+IGVmZmVjdC5pZClcbiAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZSBpbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwIHdpdGggc2F2ZWQgY29uZmlnLFxuICogdmFsaWRhdGUgZmllbGRzVG9TaG93XG4gKlxuICogQHBhcmFtIHN0YXRlXG4gKiBAcGFyYW0gdG9vbHRpcENvbmZpZ1xuICogQHJldHVybiAtIHttZXJnZWRUb29sdGlwOiB7fSwgdW5tZXJnZWRUb29sdGlwOiB7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSW50ZXJhY3Rpb25Ub29sdGlwQ29uZmlnKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHRvb2x0aXBDb25maWc6IFBpY2s8VG9vbHRpcEluZm9bJ2NvbmZpZyddLCAnZmllbGRzVG9TaG93Jz4gfCBudWxsID0gbnVsbFxuKSB7XG4gIGNvbnN0IHVubWVyZ2VkVG9vbHRpcDogVG9vbHRpcEluZm9bJ2NvbmZpZyddWydmaWVsZHNUb1Nob3cnXSA9IHt9O1xuICBjb25zdCBtZXJnZWRUb29sdGlwOiBUb29sdGlwSW5mb1snY29uZmlnJ11bJ2ZpZWxkc1RvU2hvdyddID0ge307XG5cbiAgaWYgKFxuICAgICF0b29sdGlwQ29uZmlnIHx8XG4gICAgIXRvb2x0aXBDb25maWcuZmllbGRzVG9TaG93IHx8XG4gICAgIU9iamVjdC5rZXlzKHRvb2x0aXBDb25maWcuZmllbGRzVG9TaG93KS5sZW5ndGhcbiAgKSB7XG4gICAgcmV0dXJuIHttZXJnZWRUb29sdGlwLCB1bm1lcmdlZFRvb2x0aXB9O1xuICB9XG5cbiAgZm9yIChjb25zdCBkYXRhSWQgaW4gdG9vbHRpcENvbmZpZy5maWVsZHNUb1Nob3cpIHtcbiAgICBpZiAoIXN0YXRlLmRhdGFzZXRzW2RhdGFJZF0gfHwgc3RhdGUuaXNNZXJnaW5nRGF0YXNldHNbZGF0YUlkXSkge1xuICAgICAgLy8gaXMgbm90IHlldCBsb2FkZWRcbiAgICAgIHVubWVyZ2VkVG9vbHRpcFtkYXRhSWRdID0gdG9vbHRpcENvbmZpZy5maWVsZHNUb1Nob3dbZGF0YUlkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgZGF0YXNldCBpcyBsb2FkZWRcbiAgICAgIGNvbnN0IGFsbEZpZWxkcyA9IHN0YXRlLmRhdGFzZXRzW2RhdGFJZF0uZmllbGRzLm1hcChkID0+IGQubmFtZSk7XG4gICAgICBjb25zdCBmb3VuZEZpZWxkc1RvU2hvdyA9IHRvb2x0aXBDb25maWcuZmllbGRzVG9TaG93W2RhdGFJZF0uZmlsdGVyKGZpZWxkID0+XG4gICAgICAgIGFsbEZpZWxkcy5pbmNsdWRlcyhmaWVsZC5uYW1lKVxuICAgICAgKTtcblxuICAgICAgbWVyZ2VkVG9vbHRpcFtkYXRhSWRdID0gZm91bmRGaWVsZHNUb1Nob3c7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHttZXJnZWRUb29sdGlwLCB1bm1lcmdlZFRvb2x0aXB9O1xufVxuLyoqXG4gKiBNZXJnZSBsYXllckJsZW5kaW5nIHdpdGggc2F2ZWRcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUxheWVyQmxlbmRpbmc8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIGxheWVyQmxlbmRpbmc6IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2xheWVyQmxlbmRpbmcnXVxuKTogUyB7XG4gIGlmIChsYXllckJsZW5kaW5nICYmIExBWUVSX0JMRU5ESU5HU1tsYXllckJsZW5kaW5nXSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGxheWVyQmxlbmRpbmdcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIGxheWVyIGJsZW5kaW5nIGNvbmZpZ3MgaW50byBhIHNpbmdsZSBzdHJpbmdcbiAqIGJ5IHJldHVybmluZyB0aGUgb25lIHdpdGggdGhlIGhpZ2hlc3Qgb2NjdXJyZW5jZVxuICovXG5mdW5jdGlvbiBjb21iaW5lTGF5ZXJCbGVuZGluZ0NvbmZpZ3MoY29uZmlnczogc3RyaW5nW10pOiBzdHJpbmcgfCBudWxsIHtcbiAgLy8gcmV0dXJuIHRoZSBtb2RlIG9mIHRoZSBsYXllciBibGVuZGluZyB0eXBlXG4gIHJldHVybiBnZXRWYWx1ZVdpdGhIaWdoZXN0T2NjdXJyZW5jZShjb25maWdzKTtcbn1cblxuLyoqXG4gKiBNZXJnZSBvdmVybGF5QmxlbmRpbmcgd2l0aCBzYXZlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPdmVybGF5QmxlbmRpbmc8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIG92ZXJsYXlCbGVuZGluZzogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnb3ZlcmxheUJsZW5kaW5nJ11cbik6IFMge1xuICBpZiAob3ZlcmxheUJsZW5kaW5nICYmIE9WRVJMQVlfQkxFTkRJTkdTW292ZXJsYXlCbGVuZGluZ10pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBvdmVybGF5QmxlbmRpbmdcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIG92ZXJsYXkgYmxlbmRpbmcgY29uZmlncyBpbnRvIGEgc2luZ2xlIHN0cmluZ1xuICogYnkgcmV0dXJuaW5nIHRoZSBvbmUgd2l0aCB0aGUgaGlnaGVzdCBvY2N1cnJlbmNlXG4gKiovXG5mdW5jdGlvbiBjb21iaW5lT3ZlcmxheUJsZW5kaW5nQ29uZmlncyhjb25maWdzOiBzdHJpbmdbXSk6IHN0cmluZyB8IG51bGwge1xuICAvLyByZXR1cm4gdGhlIG1vZGUgb2YgdGhlIG92ZXJsYXkgYmxlbmRpbmcgdHlwZVxuICByZXR1cm4gZ2V0VmFsdWVXaXRoSGlnaGVzdE9jY3VycmVuY2UoY29uZmlncyk7XG59XG5cbi8qKlxuICogTWVyZ2UgYW5pbWF0aW9uIGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBbmltYXRpb25Db25maWc8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIGFuaW1hdGlvbjogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnYW5pbWF0aW9uQ29uZmlnJ11cbik6IFMge1xuICBpZiAoYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5jdXJyZW50VGltZSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgICAgICAuLi5zdGF0ZS5hbmltYXRpb25Db25maWcsXG4gICAgICAgIC4uLmFuaW1hdGlvbixcbiAgICAgICAgZG9tYWluOiBudWxsXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29tYmluZUFuaW1hdGlvbkNvbmZpZ3MoY29uZmlnczogU2F2ZWRBbmltYXRpb25Db25maWdbXSk6IFNhdmVkQW5pbWF0aW9uQ29uZmlnIHtcbiAgLy8gZ2V0IHRoZSBzbWFsbGVzdCB2YWx1ZXMgb2YgY3VycmVudFRpbWUgYW5kIHNwZWVkIGFtb25nIGFsbCBjb25maWdzXG4gIHJldHVybiB7XG4gICAgY3VycmVudFRpbWU6IGFnZ3JlZ2F0ZShjb25maWdzLCBBR0dSRUdBVElPTl9UWVBFUy5taW5pbXVtLCBjID0+IGMuY3VycmVudFRpbWUpID8/IG51bGwsXG4gICAgc3BlZWQ6IGFnZ3JlZ2F0ZShjb25maWdzLCBBR0dSRUdBVElPTl9UWVBFUy5taW5pbXVtLCBjID0+IGMuc3BlZWQpID8/IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBzYXZlZCBsYXllciBjb2x1bW5zIHdpdGggbmV3IGRhdGEsXG4gKiB1cGRhdGUgZmllbGRJZHggYmFzZWQgb24gbmV3IGZpZWxkc1xuICpcbiAqIEBwYXJhbSBmaWVsZHNcbiAqIEBwYXJhbSBzYXZlZENvbHNcbiAqIEBwYXJhbSBlbXB0eUNvbHNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJuIC0gdmFsaWRhdGVkIGNvbHVtbnMgb3IgbnVsbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNhdmVkTGF5ZXJDb2x1bW5zKFxuICBmaWVsZHM6IEtlcGxlclRhYmxlWydmaWVsZHMnXSxcbiAgc2F2ZWRDb2xzOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nO1xuICB9ID0ge30sXG4gIGVtcHR5Q29sczogTGF5ZXJDb2x1bW5zLFxuICBvcHRpb25zOiB7dGhyb3dPbkVycm9yPzogYm9vbGVhbn0gPSB7fVxuKSB7XG4gIC8vIFByZXBhcmUgY29sdW1ucyBmb3IgdGhlIHZhbGlkYXRvclxuICBjb25zdCBjb2x1bW5zOiB0eXBlb2YgZW1wdHlDb2xzID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGVtcHR5Q29scykpIHtcbiAgICBjb2x1bW5zW2tleV0gPSB7Li4uZW1wdHlDb2xzW2tleV19O1xuXG4gICAgY29uc3Qgc2F2ZWQgPSBzYXZlZENvbHNba2V5XTtcbiAgICBpZiAoc2F2ZWQpIHtcbiAgICAgIGNvbnN0IGZpZWxkSWR4ID0gZmllbGRzLmZpbmRJbmRleCgoe25hbWV9KSA9PiBuYW1lID09PSBzYXZlZCk7XG5cbiAgICAgIGlmIChmaWVsZElkeCA+IC0xKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBmb3VuZCBjb2x1bW5zXG4gICAgICAgIGNvbHVtbnNba2V5XS5maWVsZElkeCA9IGZpZWxkSWR4O1xuICAgICAgICBjb2x1bW5zW2tleV0udmFsdWUgPSBzYXZlZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIGFjdHVhbCBjb2x1bW4gZmllbGRJZHgsIGluIGNhc2UgaXQgaGFzIGNoYW5nZWRcbiAgY29uc3QgYWxsQ29sRm91bmQgPSBPYmplY3Qua2V5cyhjb2x1bW5zKS5ldmVyeShrZXkgPT5cbiAgICB2YWxpZGF0ZUNvbHVtbihjb2x1bW5zW2tleV0sIGNvbHVtbnMsIGZpZWxkcylcbiAgKTtcblxuICBjb25zdCBydiA9IGFsbENvbEZvdW5kID8gY29sdW1ucyA6IG51bGw7XG4gIGlmIChvcHRpb25zLnRocm93T25FcnJvcikge1xuICAgIGNvbnN0IHJlcXVpcmVkQ29sdW1ucyA9IE9iamVjdC5rZXlzKGVtcHR5Q29scykuZmlsdGVyKGsgPT4gIWVtcHR5Q29sc1trXS5vcHRpb25hbCk7XG4gICAgY29uc3QgbWlzc2luZ0NvbHVtbnMgPSByZXF1aXJlZENvbHVtbnMuZmlsdGVyKGsgPT4gIWNvbHVtbnM/LltrXS52YWx1ZSk7XG4gICAgaWYgKG1pc3NpbmdDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciBoYXMgbWlzc2luZyBvciBpbnZhbGlkIGNvbHVtbnM6ICR7bWlzc2luZ0NvbHVtbnMuam9pbignLCAnKX1gKTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnQ29sdW1ucyA9IE9iamVjdC5rZXlzKHNhdmVkQ29scyk7XG4gICAgY29uc3QgaW52YWxpZENvbHVtbnMgPSBjb25maWdDb2x1bW5zLmZpbHRlcihrID0+ICFjb2x1bW5zPy5ba10/LnZhbHVlKTtcbiAgICBpZiAoaW52YWxpZENvbHVtbnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExheWVyIGhhcyBpbnZhbGlkIGNvbHVtbnM6ICR7aW52YWxpZENvbHVtbnMuam9pbignLCAnKX1gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnY7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgbGF5ZXIgY29sdW1uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbHVtbihcbiAgY29sdW1uOiBMYXllckNvbHVtbiAmIHt2YWxpZGF0b3I/OiB0eXBlb2YgdmFsaWRhdGVDb2x1bW59LFxuICBjb2x1bW5zOiBMYXllckNvbHVtbnMsXG4gIGFsbEZpZWxkczogS2VwbGVyVGFibGVbJ2ZpZWxkcyddXG4pOiBib29sZWFuIHtcbiAgaWYgKGNvbHVtbi5vcHRpb25hbCB8fCBjb2x1bW4udmFsdWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY29sdW1uLnZhbGlkYXRvcikge1xuICAgIHJldHVybiBjb2x1bW4udmFsaWRhdG9yKGNvbHVtbiwgY29sdW1ucywgYWxsRmllbGRzKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc2F2ZWQgdGV4dCBsYWJlbCBjb25maWcgd2l0aCBuZXcgZGF0YVxuICogcmVmZXIgdG8gdmlzLXN0YXRlLXNjaGVtYS5qcyBUZXh0TGFiZWxTY2hlbWFWMVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZmllbGRzXG4gKiBAcGFyYW0ge09iamVjdH0gc2F2ZWRUZXh0TGFiZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gdmFsaWRhdGVkIHRleHRsYWJlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTYXZlZFRleHRMYWJlbChcbiAgZmllbGRzLFxuICBbbGF5ZXJUZXh0TGFiZWxdLFxuICBzYXZlZFRleHRMYWJlbCxcbiAgb3B0aW9uczoge3Rocm93T25FcnJvcj86IGJvb2xlYW59ID0ge31cbikge1xuICBjb25zdCBzYXZlZFRleHRMYWJlbHMgPSBBcnJheS5pc0FycmF5KHNhdmVkVGV4dExhYmVsKSA/IHNhdmVkVGV4dExhYmVsIDogW3NhdmVkVGV4dExhYmVsXTtcblxuICAvLyB2YWxpZGF0ZSBmaWVsZFxuICByZXR1cm4gc2F2ZWRUZXh0TGFiZWxzLm1hcCh0ZXh0TGFiZWwgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gdGV4dExhYmVsLmZpZWxkXG4gICAgICA/IGZpZWxkcy5maW5kKGZkID0+XG4gICAgICAgICAgT2JqZWN0LmtleXModGV4dExhYmVsLmZpZWxkKS5ldmVyeShrZXkgPT4gdGV4dExhYmVsLmZpZWxkW2tleV0gPT09IGZkW2tleV0pXG4gICAgICAgIClcbiAgICAgIDogbnVsbDtcblxuICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGhyb3dPbkVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExheWVyIGhhcyBpbnZhbGlkIHRleHQgbGFiZWwgZmllbGQ6ICR7SlNPTi5zdHJpbmdpZnkodGV4dExhYmVsLmZpZWxkKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGF5ZXJUZXh0TGFiZWwpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiBrZXkgPT09ICdmaWVsZCcgPyBmaWVsZCA6IHRleHRMYWJlbFtrZXldIHx8IGxheWVyVGV4dExhYmVsW2tleV1cbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9KTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBzYXZlZCB2aXN1YWwgY2hhbm5lbHMgY29uZmlnIHdpdGggbmV3IGRhdGEsXG4gKiByZWZlciB0byB2aXMtc3RhdGUtc2NoZW1hLmpzIFZpc3VhbENoYW5uZWxTY2hlbWFWMVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTYXZlZFZpc3VhbENoYW5uZWxzKFxuICBmaWVsZHM6IEtlcGxlclRhYmxlWydmaWVsZHMnXSxcbiAgbmV3TGF5ZXI6IExheWVyLFxuICBzYXZlZExheWVyOiBQYXJzZWRMYXllcixcbiAgb3B0aW9uczoge3Rocm93T25FcnJvcj86IGJvb2xlYW59ID0ge31cbik6IG51bGwgfCBMYXllciB7XG4gIE9iamVjdC52YWx1ZXMobmV3TGF5ZXIudmlzdWFsQ2hhbm5lbHMpLmZvckVhY2goKHtmaWVsZCwgc2NhbGUsIGtleX0pID0+IHtcbiAgICBsZXQgZm91bmRGaWVsZDtcbiAgICBpZiAoc2F2ZWRMYXllci5jb25maWcpIHtcbiAgICAgIGlmIChzYXZlZExheWVyLmNvbmZpZ1tmaWVsZF0pIHtcbiAgICAgICAgZm91bmRGaWVsZCA9IGZpZWxkcy5maW5kKFxuICAgICAgICAgIGZkID0+IHNhdmVkTGF5ZXIuY29uZmlnICYmIGZkLm5hbWUgPT09IHNhdmVkTGF5ZXIuY29uZmlnW2ZpZWxkXS5uYW1lXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvdW5kQ2hhbm5lbCA9IHtcbiAgICAgICAgLi4uKGZvdW5kRmllbGQgPyB7W2ZpZWxkXTogZm91bmRGaWVsZH0gOiB7fSksXG4gICAgICAgIC4uLihzYXZlZExheWVyLmNvbmZpZ1tzY2FsZV0gPyB7W3NjYWxlXTogc2F2ZWRMYXllci5jb25maWdbc2NhbGVdfSA6IHt9KVxuICAgICAgfTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhmb3VuZENoYW5uZWwpLmxlbmd0aCkge1xuICAgICAgICBuZXdMYXllci51cGRhdGVMYXllckNvbmZpZyhmb3VuZENoYW5uZWwpO1xuICAgICAgfVxuXG4gICAgICBuZXdMYXllci52YWxpZGF0ZVZpc3VhbENoYW5uZWwoa2V5KTtcbiAgICAgIGlmIChvcHRpb25zLnRocm93T25FcnJvcikge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBzYXZlZExheWVyLmNvbmZpZz8uW2ZpZWxkXT8ubmFtZTtcbiAgICAgICAgaWYgKGZpZWxkTmFtZSAmJiBmaWVsZE5hbWUgIT09IG5ld0xheWVyLmNvbmZpZ1tmaWVsZF0/Lm5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExheWVyIGhhcyBpbnZhbGlkIHZpc3VhbCBjaGFubmVsIGZpZWxkOiAke2ZpZWxkfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld0xheWVyO1xufVxuXG50eXBlIFZhbGlkYXRlTGF5ZXJPcHRpb24gPSB7XG4gIGFsbG93RW1wdHlDb2x1bW4/OiBib29sZWFuO1xuICB0aHJvd09uRXJyb3I/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTGF5ZXJzQnlEYXRhc2V0cyhcbiAgZGF0YXNldHM6IERhdGFzZXRzLFxuICBsYXllckNsYXNzZXM6IFZpc1N0YXRlWydsYXllckNsYXNzZXMnXSxcbiAgbGF5ZXJzOiBOb25OdWxsYWJsZTxQYXJzZWRDb25maWdbJ3Zpc1N0YXRlJ10+WydsYXllcnMnXSA9IFtdLFxuICBvcHRpb25zPzogVmFsaWRhdGVMYXllck9wdGlvblxuKSB7XG4gIGNvbnN0IHZhbGlkYXRlZDogTGF5ZXJbXSA9IFtdO1xuICBjb25zdCBmYWlsZWQ6IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2xheWVycyddID0gW107XG5cbiAgbGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgIGxldCB2YWxpZGF0ZUxheWVyOiBMYXllciB8IG51bGwgPSBudWxsO1xuXG4gICAgaWYgKGxheWVyPy5jb25maWc/LmRhdGFJZCkge1xuICAgICAgaWYgKGRhdGFzZXRzW2xheWVyLmNvbmZpZy5kYXRhSWRdKSB7XG4gICAgICAgIC8vIGRhdGFzZXRzIGFyZSBhbHJlYWR5IGxvYWRlZFxuICAgICAgICB2YWxpZGF0ZUxheWVyID0gdmFsaWRhdGVMYXllcldpdGhEYXRhKFxuICAgICAgICAgIGRhdGFzZXRzW2xheWVyLmNvbmZpZy5kYXRhSWRdLFxuICAgICAgICAgIGxheWVyLFxuICAgICAgICAgIGxheWVyQ2xhc3NlcyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbGlkYXRlTGF5ZXIpIHtcbiAgICAgIHZhbGlkYXRlZC5wdXNoKHZhbGlkYXRlTGF5ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkYXRhc2V0cyBub3QgeWV0IGxvYWRlZFxuICAgICAgZmFpbGVkLnB1c2gobGF5ZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHt2YWxpZGF0ZWQsIGZhaWxlZH07XG59XG5cbi8qKlxuICogR2V0IHJlcXVpcmVkIGNvbHVtbnMgZm9yIHZhbGlkYXRpb24gYmFzZWQgb24gY29sdW1uIG1vZGVcbiAqL1xuZnVuY3Rpb24gX2dldENvbHVtbkNvbmZpZ0ZvclZhbGlkYXRpb24obmV3TGF5ZXIpIHtcbiAgLy8gZmluZCBjb2x1bW4gZmllbGRJZHhcbiAgbGV0IGNvbHVtbkNvbmZpZyA9IG5ld0xheWVyLmdldExheWVyQ29sdW1ucygpO1xuICAvLyBpZiBjb2x1bW5Nb2RlIGlzIGRlZmluZWQsIGZpbmQgY29sdW1uIG1vZGUgY29uZmlnXG4gIGNvbnN0IGNvbE1vZGVDb25maWcgPSBuZXdMYXllci5jb25maWcuY29sdW1uTW9kZVxuICAgID8gKG5ld0xheWVyLnN1cHBvcnRlZENvbHVtbk1vZGVzIHx8IFtdKS5maW5kKFxuICAgICAgICBjb2xNb2RlID0+IGNvbE1vZGUua2V5ID09PSBuZXdMYXllci5jb25maWcuY29sdW1uTW9kZVxuICAgICAgKVxuICAgIDogbnVsbDtcblxuICBpZiAoY29sTW9kZUNvbmZpZykge1xuICAgIC8vIG9ubHkgdmFsaWRhdGUgY29sdW1ucyBpbiBjb2x1bW4gbW9kZVxuICAgIGNvbHVtbkNvbmZpZyA9IFtcbiAgICAgIC4uLihjb2xNb2RlQ29uZmlnLnJlcXVpcmVkQ29sdW1ucyB8fCBbXSksXG4gICAgICAuLi4oY29sTW9kZUNvbmZpZy5vcHRpb25hbENvbHVtbnMgfHwgW10pXG4gICAgXS5yZWR1Y2UoXG4gICAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICBba2V5XTogY29sdW1uQ29uZmlnW2tleV1cbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbHVtbkNvbmZpZztcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBzYXZlZCBsYXllciBjb25maWcgd2l0aCBuZXcgZGF0YSxcbiAqIHVwZGF0ZSBmaWVsZElkeCBiYXNlZCBvbiBuZXcgZmllbGRzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMYXllcldpdGhEYXRhKFxuICBkYXRhc2V0OiBLZXBsZXJUYWJsZSxcbiAgc2F2ZWRMYXllcjogUGFyc2VkTGF5ZXIsXG4gIGxheWVyQ2xhc3NlczogVmlzU3RhdGVbJ2xheWVyQ2xhc3NlcyddLFxuICBvcHRpb25zOiBWYWxpZGF0ZUxheWVyT3B0aW9uID0ge31cbik6IExheWVyIHwgbnVsbCB7XG4gIGNvbnN0IHtmaWVsZHMsIGlkOiBkYXRhSWR9ID0gZGF0YXNldDtcbiAgY29uc3Qge3R5cGV9ID0gc2F2ZWRMYXllcjtcbiAgY29uc3Qge3Rocm93T25FcnJvcn0gPSBvcHRpb25zO1xuICAvLyBsYXllciBkb2VzbnQgaGF2ZSBhIHZhbGlkIHR5cGVcbiAgaWYgKCF0eXBlIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGF5ZXJDbGFzc2VzLCB0eXBlKSB8fCAhc2F2ZWRMYXllci5jb25maWcpIHtcbiAgICBpZiAodGhyb3dPbkVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExheWVyIGhhcyBpbnZhbGlkIHR5cGUgXCIke3R5cGV9XCIgb3IgY29uZmlnIGlzIG1pc3NpbmdgKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgbmV3TGF5ZXIgPSBuZXcgbGF5ZXJDbGFzc2VzW3R5cGVdKHtcbiAgICBpZDogc2F2ZWRMYXllci5pZCxcbiAgICBkYXRhSWQsXG4gICAgbGFiZWw6IHNhdmVkTGF5ZXIuY29uZmlnLmxhYmVsLFxuICAgIGNvbG9yOiBzYXZlZExheWVyLmNvbmZpZy5jb2xvcixcbiAgICBpc1Zpc2libGU6IHNhdmVkTGF5ZXIuY29uZmlnLmlzVmlzaWJsZSxcbiAgICBoaWRkZW46IHNhdmVkTGF5ZXIuY29uZmlnLmhpZGRlbixcbiAgICBjb2x1bW5Nb2RlOiBzYXZlZExheWVyLmNvbmZpZy5jb2x1bW5Nb2RlLFxuICAgIGhpZ2hsaWdodENvbG9yOiBzYXZlZExheWVyLmNvbmZpZy5oaWdobGlnaHRDb2xvclxuICB9KTtcblxuICBjb25zdCBjb2x1bW5Db25maWcgPSBfZ2V0Q29sdW1uQ29uZmlnRm9yVmFsaWRhdGlvbihuZXdMYXllcik7XG5cbiAgaWYgKE9iamVjdC5rZXlzKGNvbHVtbkNvbmZpZykpIHtcbiAgICBjb25zdCBjb2x1bW5zID0gdmFsaWRhdGVTYXZlZExheWVyQ29sdW1ucyhcbiAgICAgIGZpZWxkcyxcbiAgICAgIHNhdmVkTGF5ZXIuY29uZmlnLmNvbHVtbnMsXG4gICAgICBjb2x1bW5Db25maWcsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoY29sdW1ucykge1xuICAgICAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgICAgICBjb2x1bW5zOiB7XG4gICAgICAgICAgLi4ubmV3TGF5ZXIuY29uZmlnLmNvbHVtbnMsXG4gICAgICAgICAgLi4uY29sdW1uc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmFsbG93RW1wdHlDb2x1bW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRleHRMYWJlbCA9XG4gICAgc2F2ZWRMYXllci5jb25maWcudGV4dExhYmVsICYmIG5ld0xheWVyLmNvbmZpZy50ZXh0TGFiZWxcbiAgICAgID8gdmFsaWRhdGVTYXZlZFRleHRMYWJlbChcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgbmV3TGF5ZXIuY29uZmlnLnRleHRMYWJlbCxcbiAgICAgICAgICBzYXZlZExheWVyLmNvbmZpZy50ZXh0TGFiZWwsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApXG4gICAgICA6IG5ld0xheWVyLmNvbmZpZy50ZXh0TGFiZWw7XG5cbiAgLy8gY29weSB2aXNDb25maWcgb3ZlciB0byBlbXB0eUxheWVyIHRvIG1ha2Ugc3VyZSBpdCBoYXMgYWxsIHRoZSBwcm9wc1xuICBjb25zdCBjb3BpZWRWaXNDb25maWcgPSBuZXdMYXllci5jb3B5TGF5ZXJDb25maWcoXG4gICAgbmV3TGF5ZXIuY29uZmlnLnZpc0NvbmZpZyxcbiAgICBzYXZlZExheWVyLmNvbmZpZy52aXNDb25maWcgfHwge30sXG4gICAge1xuICAgICAgc2hhbGxvd0NvcHk6IFsnY29sb3JSYW5nZScsICdzdHJva2VDb2xvclJhbmdlJ11cbiAgICB9XG4gICk7XG5cbiAgLy8gY2FsbCBsYXllciBtZXRob2RzIHRvIHZhbGlkYXRlIHZpc0NvbmZpZyB3aGVuIHN3aXRjaGluZyBkYXRhc2V0XG4gIGNvbnN0IHZpc0NvbmZpZyA9IG5ld0xheWVyLnZhbGlkYXRlVmlzQ29uZmlnXG4gICAgPyBuZXdMYXllci52YWxpZGF0ZVZpc0NvbmZpZyhkYXRhc2V0LCBjb3BpZWRWaXNDb25maWcpXG4gICAgOiBjb3BpZWRWaXNDb25maWc7XG5cbiAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgIHZpc0NvbmZpZyxcbiAgICB0ZXh0TGFiZWxcbiAgfSk7XG5cbiAgLy8gdmlzdWFsIGNoYW5uZWwgZmllbGQgaXMgc2F2ZWQgdG8gYmUge25hbWUsIHR5cGV9XG4gIC8vIGZpbmQgdmlzdWFsIGNoYW5uZWwgZmllbGQgYnkgbWF0Y2hpbmcgYm90aCBuYW1lIGFuZCB0eXBlXG4gIC8vIHJlZmVyIHRvIHZpcy1zdGF0ZS1zY2hlbWEuanMgVmlzdWFsQ2hhbm5lbFNjaGVtYVYxXG4gIG5ld0xheWVyID0gdmFsaWRhdGVTYXZlZFZpc3VhbENoYW5uZWxzKGZpZWxkcywgbmV3TGF5ZXIsIHNhdmVkTGF5ZXIsIG9wdGlvbnMpO1xuXG4gIGlmICh0aHJvd09uRXJyb3IpIHtcbiAgICBpZiAoIW5ld0xheWVyLmlzVmFsaWRUb1NhdmUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciBpcyBub3QgdmFsaWQgdG8gc2F2ZTogJHtuZXdMYXllci5pZH1gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3TGF5ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUVkaXRvcjxTIGV4dGVuZHMgVmlzU3RhdGU+KHN0YXRlOiBTLCBzYXZlZEVkaXRvcjogU2F2ZWRFZGl0b3IpIHtcbiAgaWYgKCFzYXZlZEVkaXRvcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjoge1xuICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgZmVhdHVyZXM6IFsuLi5zdGF0ZS5lZGl0b3IuZmVhdHVyZXMsIC4uLihzYXZlZEVkaXRvci5mZWF0dXJlcyB8fCBbXSldLFxuICAgICAgLy8gaWYgc2F2ZWRFZGl0b3IudmlzaWJsZSBpcyB1bmRlZmluZWQga2VlcCBzdGF0ZS5lZGl0b3IudmlzaWJsZVxuICAgICAgdmlzaWJsZTogc2F2ZWRFZGl0b3IudmlzaWJsZSA/PyBzdGF0ZS5lZGl0b3IudmlzaWJsZVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tYmluZUVkaXRvckNvbmZpZ3MoY29uZmlnczogU2F2ZWRFZGl0b3JbXSk6IFNhdmVkRWRpdG9yIHtcbiAgcmV0dXJuIGNvbmZpZ3MucmVkdWNlKFxuICAgIChhY2MsIG5leHRDb25maWcpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgZmVhdHVyZXM6IFsuLi5hY2MuZmVhdHVyZXMsIC4uLihuZXh0Q29uZmlnLmZlYXR1cmVzIHx8IFtdKV1cbiAgICAgIH07XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBzdGFydCB3aXRoOlxuICAgICAgLy8gLSBlbXB0eSBhcnJheSBmb3IgZmVhdHVyZXMgYWNjdW11bGF0aW9uXG4gICAgICAvLyAtIGFuZCBhcmUgYW55IG9mIHRoZSBjb25maWdzJyB2aXNpYmxlIHZhbHVlcyB0cnVlP1xuICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgdmlzaWJsZTogY29uZmlncy5zb21lKGMgPT4gYz8udmlzaWJsZSlcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc2F2ZWQgbGF5ZXIgY29uZmlnIHdpdGggbmV3IGRhdGEsXG4gKiB1cGRhdGUgZmllbGRJZHggYmFzZWQgb24gbmV3IGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEYXRhc2V0c0J5T3JkZXIoc3RhdGU6IFZpc1N0YXRlLCBuZXdEYXRhRW50cmllczogRGF0YXNldHMpOiBEYXRhc2V0cyB7XG4gIGNvbnN0IG1lcmdlZCA9IHtcbiAgICAuLi5zdGF0ZS5kYXRhc2V0cyxcbiAgICAuLi5uZXdEYXRhRW50cmllc1xuICB9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXRlLnByZXNlcnZlRGF0YXNldE9yZGVyKSkge1xuICAgIC8vIHByZXNlcnZlRGF0YXNldE9yZGVyICBtaWdodCBub3QgaW5jbHVkZSB0aGUgIG5ldyBkYXRhc2V0c1xuICAgIGNvbnN0IG5ld0RhdGFzZXRJZHMgPSBPYmplY3Qua2V5cyhtZXJnZWQpLmZpbHRlcihcbiAgICAgIGlkID0+ICFzdGF0ZS5wcmVzZXJ2ZURhdGFzZXRPcmRlcj8uaW5jbHVkZXMoaWQpXG4gICAgKTtcbiAgICByZXR1cm4gWy4uLnN0YXRlLnByZXNlcnZlRGF0YXNldE9yZGVyLCAuLi5uZXdEYXRhc2V0SWRzXS5yZWR1Y2UoXG4gICAgICAoYWNjdSwgZGF0YUlkKSA9PiAoe1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICAuLi4obWVyZ2VkW2RhdGFJZF0gPyB7W2RhdGFJZF06IG1lcmdlZFtkYXRhSWRdfSA6IHt9KVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG4vKipcbiAqIFNpbWxpYXIgcHVycG9zZSB0byBhZ2dyZWdhdGlvbiB1dGlscyBgZ2V0TW9kZWAgZnVuY3Rpb24sXG4gKiBidXQgcmV0dXJucyB0aGUgbW9kZSBpbiB0aGUgc2FtZSB2YWx1ZSB0eXBlIHdpdGhvdXQgY29lcmNpbmcgdG8gYSBzdHJpbmcuXG4gKiBJdCBpZ25vcmVzIGB1bmRlZmluZWRgIG9yIGBudWxsYCB2YWx1ZXMsIGJ1dCByZXR1cm5zIGBudWxsYCBpZiBubyBtb2RlIGNvdWxkIGJlIGNhbGN1bGF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlV2l0aEhpZ2hlc3RPY2N1cnJlbmNlPFQ+KGFycjogVFtdKTogVCB8IG51bGwge1xuICBjb25zdCB0YWxseXMgPSBuZXcgTWFwKCk7XG4gIGFyci5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICBpZiAobm90TnVsbG9yVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgaWYgKCF0YWxseXMuaGFzKHZhbHVlKSkge1xuICAgICAgICB0YWxseXMuc2V0KHZhbHVlLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhbGx5cy5zZXQodmFsdWUsIHRhbGx5cy5nZXQodmFsdWUpICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgLy8gcmV0dXJuIHRoZSB2YWx1ZSB3aXRoIHRoZSBoaWdoZXN0IHRvdGFsIG9jY3VycmVuY2UgY291bnRcbiAgaWYgKHRhbGx5cy5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIFsuLi50YWxseXMuZW50cmllcygpXT8ucmVkdWNlKChhY2MsIG5leHQpID0+IChuZXh0WzFdID4gYWNjWzFdID8gbmV4dCA6IGFjYykpWzBdO1xufVxuXG5leHBvcnQgY29uc3QgVklTX1NUQVRFX01FUkdFUlM6IFZpc1N0YXRlTWVyZ2Vyczxhbnk+ID0gW1xuICB7XG4gICAgbWVyZ2U6IG1lcmdlTGF5ZXJzLFxuICAgIHByb3A6ICdsYXllcnMnLFxuICAgIHRvTWVyZ2VQcm9wOiAnbGF5ZXJUb0JlTWVyZ2VkJyxcbiAgICBwcmVzZXJ2ZU9yZGVyOiAncHJlc2VydmVMYXllck9yZGVyJ1xuICB9LFxuICB7XG4gICAgbWVyZ2U6IG1lcmdlRmlsdGVycyxcbiAgICBwcm9wOiAnZmlsdGVycycsXG4gICAgdG9NZXJnZVByb3A6ICdmaWx0ZXJUb0JlTWVyZ2VkJyxcbiAgICBwcmVzZXJ2ZU9yZGVyOiAncHJlc2VydmVGaWx0ZXJPcmRlcicsXG4gICAgcmVwbGFjZVBhcmVudERhdGFzZXRJZHM6IHJlcGxhY2VGaWx0ZXJEYXRhc2V0SWRzXG4gIH0sXG4gIHtcbiAgICBtZXJnZTogbWVyZ2VFZmZlY3RzLFxuICAgIHByb3A6ICdlZmZlY3RzJ1xuICB9LFxuICB7XG4gICAgbWVyZ2U6IG1lcmdlSW50ZXJhY3Rpb25zLFxuICAgIHByb3A6ICdpbnRlcmFjdGlvbkNvbmZpZycsXG4gICAgdG9NZXJnZVByb3A6ICdpbnRlcmFjdGlvblRvQmVNZXJnZWQnLFxuICAgIHJlcGxhY2VQYXJlbnREYXRhc2V0SWRzOiByZXBsYWNlSW50ZXJhY3Rpb25EYXRhc2V0SWRzLFxuICAgIHNhdmVVbm1lcmdlZDogc2F2ZWRVbm1lcmdlZEludGVyYWN0aW9uLFxuICAgIGNvbWJpbmVDb25maWdzOiBjb21iaW5lSW50ZXJhY3Rpb25Db25maWdzXG4gIH0sXG4gIHttZXJnZTogbWVyZ2VMYXllckJsZW5kaW5nLCBwcm9wOiAnbGF5ZXJCbGVuZGluZycsIGNvbWJpbmVDb25maWdzOiBjb21iaW5lTGF5ZXJCbGVuZGluZ0NvbmZpZ3N9LFxuICB7XG4gICAgbWVyZ2U6IG1lcmdlT3ZlcmxheUJsZW5kaW5nLFxuICAgIHByb3A6ICdvdmVybGF5QmxlbmRpbmcnLFxuICAgIGNvbWJpbmVDb25maWdzOiBjb21iaW5lT3ZlcmxheUJsZW5kaW5nQ29uZmlnc1xuICB9LFxuICB7bWVyZ2U6IG1lcmdlU3BsaXRNYXBzLCBwcm9wOiAnc3BsaXRNYXBzJywgdG9NZXJnZVByb3A6ICdzcGxpdE1hcHNUb0JlTWVyZ2VkJ30sXG4gIHttZXJnZTogbWVyZ2VBbmltYXRpb25Db25maWcsIHByb3A6ICdhbmltYXRpb25Db25maWcnLCBjb21iaW5lQ29uZmlnczogY29tYmluZUFuaW1hdGlvbkNvbmZpZ3N9LFxuICB7bWVyZ2U6IG1lcmdlRWRpdG9yLCBwcm9wOiAnZWRpdG9yJywgY29tYmluZUNvbmZpZ3M6IGNvbWJpbmVFZGl0b3JDb25maWdzfVxuXTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQSxJQUFBQSxLQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxLQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRSxZQUFBLEdBQUFILHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRyxVQUFBLEdBQUFKLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBSSxNQUFBLEdBQUFKLE9BQUE7QUFVQSxJQUFBSyxRQUFBLEdBQUFMLE9BQUE7QUFDQSxJQUFBTSxZQUFBLEdBQUFOLE9BQUE7QUFDQSxJQUFBTyxVQUFBLEdBQUFQLE9BQUE7QUFDQSxJQUFBUSxRQUFBLEdBQUFSLE9BQUE7QUFrQkEsSUFBQVMsTUFBQSxHQUFBVCxPQUFBO0FBRUEsSUFBQVUsV0FBQSxHQUFBVixPQUFBO0FBQXNELElBQUFXLFNBQUE7QUFBQSxTQUFBQywyQkFB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