"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.INITIAL_VIS_STATE = exports.DEFAULT_EDITOR = exports.DEFAULT_ANIMATION_CONFIG = exports.ACTION_TASK_FIT_BOUNDS = exports.ACTION_TASK_ADD_NOTIFICATION = void 0;
exports.addDefaultLayers = addDefaultLayers;
exports.addDefaultTooltips = addDefaultTooltips;
exports.applyCPUFilterUpdater = exports.addLayerUpdater = exports.addFilterUpdater = exports.addEffectUpdater = void 0;
exports.applyFilterConfigUpdater = applyFilterConfigUpdater;
exports.applyLayerConfigUpdater = applyLayerConfigUpdater;
exports.applyMergersUpdater = applyMergersUpdater;
exports.closeSpecificMapAtIndex = closeSpecificMapAtIndex;
exports.copyTableColumnUpdater = copyTableColumnUpdater;
exports.defaultInteractionConfig = exports.createOrUpdateFilterUpdater = exports.createNewDatasetSuccessUpdater = void 0;
exports.deleteFeatureUpdater = deleteFeatureUpdater;
exports.duplicateLayerUpdater = void 0;
exports.initialFileLoadingProgress = initialFileLoadingProgress;
exports.interactionConfigChangeUpdater = interactionConfigChangeUpdater;
exports.isFilterAnimationConfig = isFilterAnimationConfig;
exports.layerAnimationChangeUpdater = layerAnimationChangeUpdater;
exports.layerColorUIChangeUpdater = exports.layerClickUpdater = void 0;
exports.layerConfigChangeUpdater = layerConfigChangeUpdater;
exports.layerDataIdChangeUpdater = layerDataIdChangeUpdater;
exports.layerFilteredItemsChangeUpdater = layerFilteredItemsChangeUpdater;
exports.layerHoverUpdater = void 0;
exports.layerSetIsValidUpdater = layerSetIsValidUpdater;
exports.layerTextLabelChangeUpdater = layerTextLabelChangeUpdater;
exports.layerToggleVisibilityUpdater = layerToggleVisibilityUpdater;
exports.layerTypeChangeUpdater = layerTypeChangeUpdater;
exports.layerVisConfigChangeUpdater = layerVisConfigChangeUpdater;
exports.layerVisualChannelChangeUpdater = layerVisualChannelChangeUpdater;
exports.loadFileStepSuccessUpdater = loadFileStepSuccessUpdater;
exports.loadFilesUpdater = exports.loadFilesErrUpdater = void 0;
exports.loadNextFileUpdater = loadNextFileUpdater;
exports.makeLoadFileTask = makeLoadFileTask;
exports.nextFileBatchUpdater = exports.mouseMoveUpdater = exports.mapClickUpdater = void 0;
exports.parseProgress = parseProgress;
exports.pinTableColumnUpdater = pinTableColumnUpdater;
exports.prepareStateForDatasetReplace = prepareStateForDatasetReplace;
exports.processFileContentUpdater = processFileContentUpdater;
exports.receiveMapConfigUpdater = void 0;
exports.removeDatasetUpdater = removeDatasetUpdater;
exports.removeFilterUpdater = exports.removeEffectUpdater = void 0;
exports.removeLayerUpdater = removeLayerUpdater;
exports.renameDatasetUpdater = renameDatasetUpdater;
exports.reorderLayerUpdater = exports.reorderEffectUpdater = void 0;
exports.replaceDatasetDepsInState = replaceDatasetDepsInState;
exports.resetMapConfigUpdater = void 0;
exports.setAnimationConfigUpdater = setAnimationConfigUpdater;
exports.setColumnDisplayFormatUpdater = setColumnDisplayFormatUpdater;
exports.setEditorModeUpdater = void 0;
exports.setFeaturesUpdater = setFeaturesUpdater;
exports.setFilterAnimationTimeConfigUpdater = setFilterAnimationTimeConfigUpdater;
exports.setFilterAnimationTimeUpdater = setFilterAnimationTimeUpdater;
exports.setFilterAnimationWindowUpdater = setFilterAnimationWindowUpdater;
exports.setFilterPlotUpdater = void 0;
exports.setFilterUpdater = setFilterUpdater;
exports.setFilterViewUpdater = void 0;
exports.setInitialLayerConfig = setInitialLayerConfig;
exports.setLayerAnimationTimeConfigUpdater = setLayerAnimationTimeConfigUpdater;
exports.setMapInfoUpdater = exports.setLoadingIndicatorUpdater = exports.setLayerAnimationTimeUpdater = void 0;
exports.setPolygonFilterLayerUpdater = setPolygonFilterLayerUpdater;
exports.setSelectedFeatureUpdater = void 0;
exports.setTimeFilterTimelineModeUpdater = setTimeFilterTimelineModeUpdater;
exports.showDatasetTableUpdater = void 0;
exports.sortTableColumnUpdater = sortTableColumnUpdater;
exports.syncTimeFilterWithLayerTimelineUpdater = syncTimeFilterWithLayerTimelineUpdater;
exports.toggleEditorVisibilityUpdater = toggleEditorVisibilityUpdater;
exports.toggleSplitMapUpdater = exports.toggleLayerForMapUpdater = exports.toggleLayerAnimationUpdater = exports.toggleLayerAnimationControlUpdater = exports.toggleFilterFeatureUpdater = exports.toggleFilterAnimationUpdater = void 0;
exports.updateAllLayerDomainData = updateAllLayerDomainData;
exports.updateAnimationDomain = updateAnimationDomain;
exports.updateDatasetPropsUpdater = updateDatasetPropsUpdater;
exports.updateEffectUpdater = void 0;
exports.updateFileLoadingProgressUpdater = updateFileLoadingProgressUpdater;
exports.updateOverlayBlendingUpdater = exports.updateLayerBlendingUpdater = exports.updateLayerAnimationSpeedUpdater = exports.updateFilterAnimationSpeedUpdater = void 0;
exports.updateStateOnLayerVisibilityChange = updateStateOnLayerVisibilityChange;
exports.updateStateWithLayerAndData = updateStateWithLayerAndData;
exports.updateVisDataUpdater = exports.updateTableColorUpdater = void 0;
var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _bbox = _interopRequireDefault(require("@turf/bbox"));
var _copyToClipboard = _interopRequireDefault(require("copy-to-clipboard"));
var _deepmerge = _interopRequireDefault(require("deepmerge"));
var _window = require("global/window");
var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));
var _get = _interopRequireDefault(require("lodash/get"));
var _isEqual = _interopRequireDefault(require("lodash/isEqual"));
var _pick = _interopRequireDefault(require("lodash/pick"));
var _uniq = _interopRequireDefault(require("lodash/uniq"));
var _xor = _interopRequireDefault(require("lodash/xor"));
var _tasks = _interopRequireWildcard(require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/node_modules/react-palm/tasks"));
var _tasks2 = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/tasks/src");
var _actions = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/actions/src");
var _utils = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/utils/src");
var _commonUtils = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/common-utils/src");
var _constants = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/constants/src");
var _layers = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/layers/src");
var _composerHelpers = require("./composer-helpers");
var _mergerHandler = require("./merger-handler");
var _visStateMerger = require("./vis-state-merger");
var _schemas = _interopRequireDefault(require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/schemas/src"));
var _table = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/table/src");
var _interactionUtils = require("./interaction-utils");
var _layerUtils = require("./layer-utils");
var _effects = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/effects/src");
var _dataUtils = require("./data-utils");
var _excluded = ["dataId"],
  _excluded2 = ["info"];
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != _typeof(e) && "function" != typeof e) return {
    "default": e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n["default"] = e, t && t.set(e, n), n;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0,
        F = function F() {};
      return {
        s: F,
        n: function n() {
          return _n >= r.length ? {
            done: !0
          } : {
            done: !1,
            value: r[_n++]
          };
        },
        e: function e(r) {
          throw r;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o,
    a = !0,
    u = !1;
  return {
    s: function s() {
      t = t.call(r);
    },
    n: function n() {
      var r = t.next();
      return a = r.done, r;
    },
    e: function e(r) {
      u = !0, o = r;
    },
    f: function f() {
      try {
        a || null == t["return"] || t["return"]();
      } finally {
        if (u) throw o;
      }
    }
  };
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      (0, _defineProperty2["default"])(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
} // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
// Tasks
// Actions
// Utils
// Mergers
// react-palm
// disable capture exception for react-palm call to withTask
(0, _tasks.disableStackCapturing)();

/**
 * Updaters for `visState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 *
 * @public
 * @example
 *
 * import keplerGlReducer, {visStateUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             visState: visStateUpdaters.enlargeFilterUpdater(
 *               state.keplerGl.foo.visState,
 *               {idx: 0}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */
/* eslint-disable @typescript-eslint/no-unused-vars */
// @ts-ignore
var visStateUpdaters = null;
/* eslint-enable @typescript-eslint/no-unused-vars */

var defaultInteractionConfig = exports.defaultInteractionConfig = {
  tooltip: {
    id: 'tooltip',
    label: 'interactions.tooltip',
    enabled: true,
    config: {
      fieldsToShow: {},
      compareMode: false,
      compareType: _constants.COMPARE_TYPES.ABSOLUTE
    }
  },
  geocoder: {
    id: 'geocoder',
    label: 'interactions.geocoder',
    enabled: false,
    position: null
  },
  brush: {
    id: 'brush',
    label: 'interactions.brush',
    enabled: false,
    config: {
      // size is in km
      size: 0.5
    }
  },
  coordinate: {
    id: 'coordinate',
    label: 'interactions.coordinate',
    enabled: false,
    position: null
  }
};
var DEFAULT_ANIMATION_CONFIG = exports.DEFAULT_ANIMATION_CONFIG = {
  domain: null,
  currentTime: null,
  speed: 1,
  isAnimating: false,
  timeSteps: null,
  timeFormat: null,
  timezone: null,
  defaultTimeFormat: null,
  hideControl: false,
  duration: null
};
var DEFAULT_EDITOR = exports.DEFAULT_EDITOR = {
  mode: _constants.EDITOR_MODES.DRAW_POLYGON,
  features: [],
  selectedFeature: null,
  visible: true
};

/**
 * Default initial `visState`
 * @memberof visStateUpdaters
 * @constant
 * @public
 */
var INITIAL_VIS_STATE = exports.INITIAL_VIS_STATE = {
  // map info
  mapInfo: {
    title: '',
    description: ''
  },
  // layers
  layers: [],
  layerData: [],
  layerToBeMerged: [],
  layerOrder: [],
  // filters
  filters: [],
  filterToBeMerged: [],
  // a collection of multiple dataset
  datasets: {},
  editingDataset: undefined,
  // effects
  effects: [],
  effectOrder: [],
  interactionConfig: defaultInteractionConfig,
  interactionToBeMerged: {},
  layerBlending: 'normal',
  overlayBlending: 'normal',
  hoverInfo: undefined,
  clicked: undefined,
  mousePos: {},
  maxDefaultTooltips: _constants.MAX_DEFAULT_TOOLTIPS,
  // this is used when user split maps
  splitMaps: [
    // this will contain a list of objects to
    // describe the state of layer availability and visibility for each map
    // [
    //   {
    //      layers: {layer_id: true | false}
    //   }
    // ]
  ],
  splitMapsToBeMerged: [],
  isMergingDatasets: {},
  // defaults layer classes
  layerClasses: _layers.LayerClasses,
  // default animation
  // time in unix timestamp (milliseconds) (the number of seconds since the Unix Epoch)
  animationConfig: DEFAULT_ANIMATION_CONFIG,
  editor: DEFAULT_EDITOR,
  fileLoading: false,
  fileLoadingProgress: {},
  // for loading datasets
  loadingIndicatorValue: 0,
  loaders: [],
  loadOptions: {},
  // visStateMergers
  mergers: _visStateMerger.VIS_STATE_MERGERS,
  // kepler schemas
  schema: _schemas["default"]
};
var ACTION_TASK_FIT_BOUNDS = exports.ACTION_TASK_FIT_BOUNDS = _tasks["default"].fromCallback(function (_, cb) {
  return cb();
}, 'ACTION_TASK_FIT_BOUNDS');
var ACTION_TASK_ADD_NOTIFICATION = exports.ACTION_TASK_ADD_NOTIFICATION = _tasks["default"].fromCallback(function (_, cb) {
  return cb();
}, 'ACTION_TASK_ADD_NOTIFICATION');
/**
 * Update state with updated layer and layerData
 *
 */
function updateStateWithLayerAndData(state, _ref) {
  var layerData = _ref.layerData,
    layer = _ref.layer,
    idx = _ref.idx;
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: state.layers.map(function (lyr, i) {
      return i === idx ? layer : lyr;
    }),
    layerData: layerData ? state.layerData.map(function (d, i) {
      return i === idx ? layerData : d;
    }) : state.layerData
  });
}
function updateStateOnLayerVisibilityChange(state, layer) {
  var newState = state;
  if (state.splitMaps.length) {
    newState = _objectSpread(_objectSpread({}, state), {}, {
      splitMaps: layer.config.isVisible ? (0, _utils.addNewLayersToSplitMap)(state.splitMaps, layer) : (0, _utils.removeLayerFromSplitMaps)(state.splitMaps, layer)
    });
  }
  if (layer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  }
  return newState;
}

/**
 * Compares two objects (or arrays) and returns a new object with only the
 * properties that have changed between the two objects.
 */
function pickChangedProps(prev, next) {
  var changedProps = {};
  var pickPropsOf = function pickPropsOf(obj) {
    Object.keys(obj).forEach(function (key) {
      if (!Object.prototype.hasOwnProperty.call(changedProps, key) && !(0, _isEqual["default"])(prev[key], next[key])) {
        changedProps[key] = next[key];
      }
    });
  };
  pickPropsOf(prev);
  pickPropsOf(next);
  return changedProps;
}
var VISUAL_CHANNEL_PROP_TYPES = ['field', 'scale', 'domain', 'aggregation'];

/**
 * Apply layer config
 * @memberof visStateUpdaters
 * @returns nextState
 */
// eslint-disable-next-line complexity, max-statements
function applyLayerConfigUpdater(state, action) {
  var _serializeLayer;
  var oldLayerId = action.oldLayerId,
    newLayerConfig = action.newLayerConfig,
    layerIndex = action.layerIndex;
  var newParsedLayer =
  // will move visualChannels to the config prop
  (0, _visStateMerger.parseLayerConfig)(state.schema, newLayerConfig);
  var oldLayer = state.layers.find(function (l) {
    return l.id === oldLayerId;
  });
  if (!oldLayer || !newParsedLayer) {
    return state;
  }
  if (layerIndex !== null && layerIndex !== undefined && state.layers[layerIndex] !== oldLayer) {
    // layerIndex is provided, but it doesn't match the oldLayer
    return state;
  }
  var dataset = state.datasets[newParsedLayer.config.dataId];
  if (!dataset) {
    return state;
  }
  // Make sure the layer is valid and convert it to Layer
  var newLayer = (0, _visStateMerger.validateLayerWithData)(dataset, newParsedLayer, state.layerClasses);
  if (!newLayer) {
    return state;
  }
  var nextState = state;
  if (newLayer.type && newLayer.type !== oldLayer.type) {
    var oldLayerIndex = state.layers.findIndex(function (l) {
      return l.id === oldLayerId;
    });
    if (oldLayerIndex >= 0) {
      nextState = layerTypeChangeUpdater(nextState, (0, _actions.layerTypeChange)(oldLayer, newLayer.type));
      // layerTypeChangeUpdater changes the id of the layer, so we need to obtain the new id
      // but first make sure that the layer was not removed
      if (nextState.layers.length === state.layers.length) {
        var newLayerId = nextState.layers[oldLayerIndex].id;
        nextState = applyLayerConfigUpdater(nextState, (0, _actions.applyLayerConfig)(newLayerId, _objectSpread(_objectSpread({}, newLayerConfig), {}, {
          id: newLayerId
        })));
      }
    }
    return nextState;
  }

  // serializeLayer() might return null if the old layer is not valid,
  // we should still apply the changes in that case
  var serializedOldLayer = (_serializeLayer = (0, _visStateMerger.serializeLayer)(oldLayer, state.schema)) !== null && _serializeLayer !== void 0 ? _serializeLayer : {
    config: {}
  };
  var serializedNewLayer = (0, _visStateMerger.serializeLayer)(newLayer, state.schema);
  if (!serializedNewLayer) {
    return state;
  }
  if (!(0, _isEqual["default"])(serializedOldLayer, serializedNewLayer)) {
    var changed = pickChangedProps(serializedOldLayer.config, serializedNewLayer.config);
    if ('visConfig' in changed) {
      if (changed.visConfig) {
        nextState = layerVisConfigChangeUpdater(nextState, (0, _actions.layerVisConfigChange)(oldLayer, changed.visConfig));
      }
      delete changed.visConfig;
    }
    Object.keys(oldLayer.visualChannels).forEach(function (channelName) {
      var channel = oldLayer.visualChannels[channelName];
      var channelPropNames = VISUAL_CHANNEL_PROP_TYPES.map(function (prop) {
        return channel[prop];
      });
      if (channelPropNames.some(function (prop) {
        return prop in changed;
      })) {
        nextState = layerVisualChannelChangeUpdater(nextState, (0, _actions.layerVisualChannelConfigChange)(oldLayer, (0, _pick["default"])(newLayer.config, channelPropNames), channelName));
        var _iterator = _createForOfIteratorHelper(channelPropNames),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var prop = _step.value;
            delete changed[prop];
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    });
    if (Object.keys(changed).length > 0) {
      nextState = layerConfigChangeUpdater(nextState, (0, _actions.layerConfigChange)(oldLayer, (0, _pick["default"])(newLayer.config, Object.keys(changed))));
    }
  }
  return nextState;
}
function updatelayerVisibilty(state, newLayer, isVisible) {
  var newState = updateStateOnLayerVisibilityChange(state, newLayer);
  var filterIndex = filterSyncedWithTimeline(state);
  if ((0, _utils.isLayerAnimatable)(newLayer) && filterIndex !== -1) {
    // if layer is going to be visible we sync with filter otherwise we need to check whether other animatable layers exists and are visible
    newState = syncTimeFilterWithLayerTimelineUpdater(newState, {
      idx: filterIndex,
      enable: isVisible ? isVisible : (0, _utils.getAnimatableVisibleLayers)(state.layers).length > 0
    });
  }
  return newState;
}

/**
 * Update layer base config: dataId, label, column, isVisible
 * @memberof visStateUpdaters
 * @returns nextState
 */
// eslint-disable-next-line complexity
function layerConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newConfig);
  if (typeof action.newConfig.dataId === 'string' && action.newConfig.dataId !== oldLayer.config.dataId) {
    var _action$newConfig = action.newConfig,
      dataId = _action$newConfig.dataId,
      restConfig = (0, _objectWithoutProperties2["default"])(_action$newConfig, _excluded);
    var stateWithDataId = layerDataIdChangeUpdater(state, {
      oldLayer: oldLayer,
      newConfig: {
        dataId: dataId
      }
    });
    var nextLayer = stateWithDataId.layers.find(function (l) {
      return l.id === oldLayer.id;
    });
    return nextLayer && Object.keys(restConfig).length ? layerConfigChangeUpdater(stateWithDataId, {
      oldLayer: nextLayer,
      newConfig: restConfig
    }) : stateWithDataId;
  }
  var newLayer = oldLayer.updateLayerConfig(action.newConfig);
  var layerData;
  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];
    var updateLayerDataResult = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData);
    newLayer = updateLayerDataResult.layer;
    layerData = updateLayerDataResult.layerData;
  }
  var newState = state;
  if ('isVisible' in action.newConfig) {
    newState = updatelayerVisibilty(newState, newLayer, action.newConfig.isVisible);
  }
  if ('columns' in action.newConfig && newLayer.config.animation.enabled) {
    // TODO: Shan, make the animation config function more robust
    newState = updateAnimationDomain(newState);
  }
  return updateStateWithLayerAndData(newState, {
    layer: newLayer,
    layerData: layerData,
    idx: idx
  });
}
function layerAnimationChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
    prop = action.prop,
    value = action.value;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig({
    animation: _objectSpread(_objectSpread({}, oldLayer.config.animation), {}, (0, _defineProperty2["default"])({}, prop, value))
  });
  var _calculateLayerData = (0, _layerUtils.calculateLayerData)(newLayer, state, state.layerData[idx]),
    layerData = _calculateLayerData.layerData,
    layer = _calculateLayerData.layer;
  return updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}

/**
 * Update layerId, isVisible, splitMapId
 * handles two cases:
 * 1) toggle the visibility of local SplitMap layer (visState.splitMap.layers)
 * 2) toggle the visibility of global layer (visState.layers)

 * @memberof visStateUpdaters
 * @returns nextState
 */
function layerToggleVisibilityUpdater(state, action) {
  var layerId = action.layerId,
    isVisible = action.isVisible,
    splitMapId = action.splitMapId;
  var layer = state.layers.find(function (d) {
    return d.id === layerId;
  });
  if (!layer) {
    return state;
  }
  var newState = state;
  if (splitMapId) {
    // [case 1]: toggle local layer visibility for each SplitMap
    var mapIndex = newState.splitMaps.findIndex(function (sm) {
      return sm.id === splitMapId;
    });
    if (isVisible) {
      // 1) if the layer is invisible globally
      // -> set global visibility to true
      newState = layerConfigChangeUpdater(newState, (0, _actions.layerConfigChange)(layer, {
        isVisible: true
      }));

      // -> set local visibility to true and the local visibilities of all other SplitMaps to false
      return _objectSpread(_objectSpread({}, newState), {}, {
        splitMaps: newState.splitMaps.map(function (sm) {
          return sm.id !== splitMapId ? _objectSpread(_objectSpread({}, sm), {}, {
            layers: _objectSpread(_objectSpread({}, sm.layers), {}, (0, _defineProperty2["default"])({}, layerId, false))
          }) : _objectSpread(_objectSpread({}, sm), {}, {
            layers: _objectSpread(_objectSpread({}, sm.layers), {}, (0, _defineProperty2["default"])({}, layerId, true))
          });
        })
      });
    }
    // 2) else when the layer is visible globally
    return toggleLayerForMapUpdater(newState, (0, _actions.toggleLayerForMap)(mapIndex, layerId));
  } else {
    // [case 2]: toggle global layer visibility
    var newLayer = layer.updateLayerConfig({
      isVisible: isVisible
    });
    var idx = newState.layers.findIndex(function (l) {
      return l.id === layerId;
    });
    newState = updatelayerVisibilty(newState, newLayer, isVisible);
    return updateStateWithLayerAndData(newState, {
      layer: newLayer,
      idx: idx
    });
  }
}

/**
 *
 * @param state
 * @returns index of the filter synced to timeline or -1
 */
function filterSyncedWithTimeline(state) {
  return state.filters.findIndex(function (f) {
    return f.syncedWithLayerTimeline;
  });
}

/**
 * Updates isValid flag of a layer.
 * Updates isVisible based on the value of isValid.
 * Triggers update of data for the layer in order to get errors again during next update iteration.
 * @memberof visStateUpdaters
 * @returns nextState
 */
function layerSetIsValidUpdater(state, action) {
  var oldLayer = action.oldLayer,
    isValid = action.isValid;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var layerToUpdate = state.layers[idx];
  if (layerToUpdate) {
    var newLayer;
    var newData = null;
    if (isValid) {
      // Trigger data update in order to show errors again if present.
      var _calculateLayerData2 = (0, _layerUtils.calculateLayerData)(layerToUpdate, state, undefined),
        layer = _calculateLayerData2.layer,
        layerData = _calculateLayerData2.layerData;
      newLayer = layer;
      newData = layerData;
    } else {
      newLayer = layerToUpdate.updateLayerConfig({
        isVisible: false
      });
      newLayer.isValid = false;
    }
    return updateStateWithLayerAndData(state, {
      idx: idx,
      layer: newLayer,
      layerData: newData
    });
  }
  return state;
}
function addOrRemoveTextLabels(newFields, textLabel) {
  var defaultTextLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constants.DEFAULT_TEXT_LABEL;
  var newTextLabel = textLabel.slice();
  var currentFields = textLabel.map(function (tl) {
    return tl.field && tl.field.name;
  }).filter(function (d) {
    return d;
  });
  var addFields = newFields.filter(function (f) {
    return !currentFields.includes(f.name);
  });
  var deleteFields = currentFields.filter(function (f) {
    return !newFields.find(function (fd) {
      return fd.name === f;
    });
  });

  // delete
  newTextLabel = newTextLabel.filter(function (tl) {
    return tl.field && !deleteFields.includes(tl.field.name);
  });
  newTextLabel = !newTextLabel.length ? [defaultTextLabel] : newTextLabel;

  // add
  newTextLabel = [].concat((0, _toConsumableArray2["default"])(newTextLabel.filter(function (tl) {
    return tl.field;
  })), (0, _toConsumableArray2["default"])(addFields.map(function (af) {
    return _objectSpread(_objectSpread({}, defaultTextLabel), {}, {
      field: af
    });
  })));
  return newTextLabel;
}
function updateTextLabelPropAndValue(idx, prop, value, textLabel) {
  if (!Object.prototype.hasOwnProperty.call(textLabel[idx], prop)) {
    return textLabel;
  }
  var newTextLabel = textLabel.slice();
  if (prop === 'field' && value === null && textLabel.length > 1) {
    // remove label when field value is set to null
    newTextLabel.splice(idx, 1);
  } else if (prop) {
    newTextLabel = textLabel.map(function (tl, i) {
      return i === idx ? _objectSpread(_objectSpread({}, tl), {}, (0, _defineProperty2["default"])({}, prop, value)) : tl;
    });
  }
  return newTextLabel;
}

/**
 * Update layer base config: dataId, label, column, isVisible
 * @memberof visStateUpdaters
 * @returns nextState
 */
function layerTextLabelChangeUpdater(state, action) {
  var _oldLayer$getDefaultL, _oldLayer$getDefaultL2;
  var oldLayer = action.oldLayer,
    idx = action.idx,
    prop = action.prop,
    value = action.value;
  var textLabel = oldLayer.config.textLabel;

  // when adding a new empty text label,
  // rely on the layer's default config, or use the constant DEFAULT_TEXT_LABEL
  var defaultTextLabel = (_oldLayer$getDefaultL = (_oldLayer$getDefaultL2 = oldLayer.getDefaultLayerConfig({
    dataId: ''
  })) === null || _oldLayer$getDefaultL2 === void 0 || (_oldLayer$getDefaultL2 = _oldLayer$getDefaultL2.textLabel) === null || _oldLayer$getDefaultL2 === void 0 ? void 0 : _oldLayer$getDefaultL2[0]) !== null && _oldLayer$getDefaultL !== void 0 ? _oldLayer$getDefaultL : _constants.DEFAULT_TEXT_LABEL;
  var newTextLabel = textLabel.slice();
  if (!textLabel[idx] && idx === textLabel.length) {
    // if idx is set to length, add empty text label
    newTextLabel = [].concat((0, _toConsumableArray2["default"])(textLabel), [defaultTextLabel]);
  }
  if (idx === 'all' && prop === 'fields') {
    newTextLabel = addOrRemoveTextLabels(value, textLabel, defaultTextLabel);
  } else {
    newTextLabel = updateTextLabelPropAndValue(idx, prop, value, newTextLabel);
  }
  // update text label prop and value
  return layerConfigChangeUpdater(state, {
    oldLayer: oldLayer,
    newConfig: {
      textLabel: newTextLabel
    }
  });
}
function validateExistingLayerWithData(dataset, layerClasses, layer, schema) {
  var loadedLayer = (0, _visStateMerger.serializeLayer)(layer, schema);
  return loadedLayer ? (0, _visStateMerger.validateLayerWithData)(dataset, loadedLayer, layerClasses, {
    allowEmptyColumn: true
  }) : null;
}

/**
 * Update layer config dataId
 * @memberof visStateUpdaters
 * @returns nextState
 */
function layerDataIdChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
    newConfig = action.newConfig;
  var dataId = newConfig.dataId;
  if (!oldLayer || !state.datasets[dataId]) {
    return state;
  }
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig({
    dataId: dataId
  });

  // this may happen when a layer is new (type: null and no columns) but it's not ready to be saved
  if (newLayer.isValidToSave()) {
    var validated = validateExistingLayerWithData(state.datasets[dataId], state.layerClasses, newLayer, state.schema);
    // if cant validate it with data create a new one
    if (!validated) {
      var oldLayerType = oldLayer.type;
      if (oldLayerType) {
        newLayer = new state.layerClasses[oldLayerType]({
          dataId: dataId,
          id: oldLayer.id
        });
      }
    } else {
      newLayer = validated;
    }
  }
  newLayer = newLayer.updateLayerConfig({
    isVisible: oldLayer.config.isVisible,
    isConfigActive: true
  });
  newLayer.updateLayerDomain(state.datasets);
  var _calculateLayerData3 = (0, _layerUtils.calculateLayerData)(newLayer, state, undefined),
    layerData = _calculateLayerData3.layerData,
    layer = _calculateLayerData3.layer;
  return updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}
function setInitialLayerConfig(layer, datasets, layerClasses) {
  var newLayer = layer;
  if (!Object.keys(datasets).length) {
    // no data is loaded
    return layer;
  }
  if (!layer.config.dataId) {
    // set layer dataId
    newLayer = layer.updateLayerConfig({
      dataId: Object.keys(datasets)[0]
    });
  }
  var dataset = datasets[newLayer.config.dataId];
  if (!dataset) {
    return layer;
  }

  // find defaut layer props
  var result = typeof layerClasses[newLayer.type].findDefaultLayerProps === 'function' ? layerClasses[newLayer.type].findDefaultLayerProps(dataset, []) : {
    props: []
  };

  // an array of possible props, use 1st one
  var props = Array.isArray(result) ? result : result.props || [];
  if (props.length) {
    newLayer = new layerClasses[layer.type](_objectSpread(_objectSpread({}, props[0]), {}, {
      label: newLayer.config.label,
      dataId: newLayer.config.dataId,
      isConfigActive: newLayer.config.isConfigActive
    }));
  }
  return typeof newLayer.setInitialLayerConfig === 'function' ? newLayer.setInitialLayerConfig(dataset) : newLayer;
}
/**
 * Update layer type. Previews layer config will be copied if applicable.
 * @memberof visStateUpdaters
 * @public
 */
function layerTypeChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
    newType = action.newType;
  if (!oldLayer) {
    return state;
  }
  var oldId = oldLayer.id;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldId;
  });
  if (!state.layerClasses[newType]) {
    _window.console.error("".concat(newType, " is not a valid layer type"));
    return state;
  }
  var newLayer = new state.layerClasses[newType]({
    // keep old layer lable and isConfigActive
    label: oldLayer.config.label,
    isConfigActive: oldLayer.config.isConfigActive,
    dataId: oldLayer.config.dataId
  });
  if (!oldLayer.type) {
    // if setting layer type on an empty layer
    newLayer = setInitialLayerConfig(newLayer, state.datasets, state.layerClasses);
  } else {
    // get a mint layer, with new id and type
    // because deck.gl uses id to match between new and old layer.
    // If type has changed but id is the same, it will break

    var defaultLayerProps = typeof state.layerClasses[newType].findDefaultLayerProps === 'function' ? state.layerClasses[newType].findDefaultLayerProps(state.datasets[newLayer.config.dataId]) : null;
    newLayer.assignConfigToLayer(oldLayer.config, oldLayer.visConfigSettings, state.datasets, defaultLayerProps);
    newLayer.updateLayerDomain(state.datasets);
  }
  var clicked = state.clicked,
    hoverInfo = state.hoverInfo;
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    clicked: oldLayer.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: oldLayer.isLayerHovered(hoverInfo) ? undefined : hoverInfo
  });
  var _calculateLayerData4 = (0, _layerUtils.calculateLayerData)(newLayer, newState),
    layerData = _calculateLayerData4.layerData,
    layer = _calculateLayerData4.layer;
  newState = updateStateWithLayerAndData(newState, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
  if (layer.config.animation.enabled || oldLayer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  }

  // update splitMap layer id
  if (state.splitMaps.length) {
    newState = _objectSpread(_objectSpread({}, newState), {}, {
      splitMaps: newState.splitMaps.map(function (settings) {
        var _settings$layers = settings.layers,
          oldLayerMap = _settings$layers[oldId],
          otherLayers = (0, _objectWithoutProperties2["default"])(_settings$layers, [oldId].map(_toPropertyKey));
        return oldId in settings.layers ? _objectSpread(_objectSpread({}, settings), {}, {
          layers: _objectSpread(_objectSpread({}, otherLayers), {}, (0, _defineProperty2["default"])({}, layer.id, oldLayerMap))
        }) : settings;
      })
    });
  }

  // update layerOrder with new id
  newState = _objectSpread(_objectSpread({}, newState), {}, {
    layerOrder: newState.layerOrder.map(function (layerId) {
      return layerId === oldLayer.id ? newLayer.id : layerId;
    })
  });
  return newState;
}

/**
 * Update layer visual channel
 * @memberof visStateUpdaters
 * @returns {Object} nextState
 * @public
 */
function layerVisualChannelChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
    newConfig = action.newConfig,
    newVisConfig = action.newVisConfig,
    channel = action.channel;
  if (!oldLayer.config.dataId) {
    return state;
  }
  var dataset = state.datasets[oldLayer.config.dataId];
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig(newConfig);
  if (newVisConfig) newLayer = newLayer.updateLayerVisConfig(newVisConfig);
  newLayer.updateLayerVisualChannel(dataset, channel);

  // calling update animation domain first to merge all layer animation domain
  var updatedState = updateAnimationDomain(state);
  var visualChannel = oldLayer.visualChannels[channel];
  if ((visualChannel === null || visualChannel === void 0 ? void 0 : visualChannel.channelScaleType) === _constants.CHANNEL_SCALES.color && newConfig[visualChannel.field]) {
    // if color field changed, set customBreaks to false
    newLayer.updateLayerColorUI(visualChannel.range, {
      colorRangeConfig: _objectSpread(_objectSpread({}, newLayer.config.colorUI[visualChannel.range].colorRangeConfig), {}, {
        customBreaks: false
      })
    });
    updatedState = _objectSpread(_objectSpread({}, updatedState), {}, {
      layers: updatedState.layers.map(function (l) {
        return l.id === oldLayer.id ? newLayer : l;
      })
    });
  }
  var oldLayerData = updatedState.layerData[idx];
  var _calculateLayerData5 = (0, _layerUtils.calculateLayerData)(newLayer, updatedState, oldLayerData),
    layerData = _calculateLayerData5.layerData,
    layer = _calculateLayerData5.layer;
  if ((visualChannel === null || visualChannel === void 0 ? void 0 : visualChannel.channelScaleType) === _constants.CHANNEL_SCALES.color && newConfig[visualChannel === null || visualChannel === void 0 ? void 0 : visualChannel.scale] === _constants.SCALE_TYPES.customOrdinal && !newVisConfig) {
    // when switching to customOrdinal scale, create a customPalette in colorUI with updated colorDomain
    var customPalette = (0, _utils.initCustomPaletteByCustomScale)({
      scale: _constants.SCALE_TYPES.customOrdinal,
      field: layer.config[visualChannel.field],
      ordinalDomain: layer.config[layer.visualChannels[channel].domain],
      range: layer.config.visConfig[visualChannel.range],
      colorBreaks: null
    });
    // update colorRange with new customPalette
    layer.updateLayerColorUI(visualChannel.range, {
      showColorChart: true,
      colorRangeConfig: _objectSpread(_objectSpread({}, layer.config.colorUI[visualChannel.range].colorRangeConfig), {}, {
        customBreaks: true
      }),
      customPalette: customPalette
    });
  }
  return updateStateWithLayerAndData(updatedState, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}

/**
 * Update layer `visConfig`
 * @memberof visStateUpdaters
 * @public
 */
function layerVisConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newVisConfig);
  var newVisConfig = _objectSpread(_objectSpread({}, oldLayer.config.visConfig), action.newVisConfig);
  var newLayer = oldLayer.updateLayerConfig({
    visConfig: newVisConfig
  });
  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];
    var _calculateLayerData6 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData),
      layerData = _calculateLayerData6.layerData,
      layer = _calculateLayerData6.layer;
    return updateStateWithLayerAndData(state, {
      layerData: layerData,
      layer: layer,
      idx: idx
    });
  }
  return updateStateWithLayerAndData(state, {
    layer: newLayer,
    idx: idx
  });
}

/**
 * Reset animation config current time to a specified value
 * @memberof visStateUpdaters
 * @public
 *
 */
var setLayerAnimationTimeUpdater = exports.setLayerAnimationTimeUpdater = function setLayerAnimationTimeUpdater(state, _ref2) {
  var value = _ref2.value;
  var currentTime = Array.isArray(value) ? value[0] : value;
  var nextState = _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      currentTime: currentTime
    })
  });
  // update animation config for each layer
  return state.layers.reduce(function (accu, l) {
    if (l.config.animation.enabled && l.type !== 'trip') {
      return layerAnimationChangeUpdater(accu, {
        oldLayer: l,
        prop: 'currentTime',
        currentTime: currentTime
      });
    }
    return accu;
  }, nextState);
};

/**
 * Update filter property
 * @memberof visStateUpdaters
 * @public
 */
function setFilterAnimationTimeUpdater(state, action) {
  return setFilterUpdater(state, action);
}

/**
 * Update filter animation window
 * @memberof visStateUpdaters
 * @public
 */
function setFilterAnimationWindowUpdater(state, _ref3) {
  var id = _ref3.id,
    animationWindow = _ref3.animationWindow;
  var filter = state.filters.find(function (f) {
    return f.id === id;
  });
  if (!filter) {
    return state;
  }
  var newFilter = _objectSpread(_objectSpread({}, filter), {}, {
    animationWindow: animationWindow
  });
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    filters: (0, _composerHelpers.swap_)(newFilter)(state.filters)
  });
  var newSyncTimelineMode = getSyncAnimationMode(newFilter);
  return setTimeFilterTimelineModeUpdater(newState, {
    id: id,
    mode: newSyncTimelineMode
  });
}
function applyFilterConfigUpdater(state, action) {
  var _serializeFilter;
  var filterId = action.filterId,
    newFilter = action.newFilter;
  var oldFilter = state.filters.find(function (f) {
    return f.id === filterId;
  });
  if (!oldFilter) {
    return state;
  }

  // Serialize the filters to only compare the saved properties
  var serializedOldFilter = (_serializeFilter = (0, _visStateMerger.serializeFilter)(oldFilter, state.schema)) !== null && _serializeFilter !== void 0 ? _serializeFilter : {
    config: {}
  };
  var serializedNewFilter = (0, _visStateMerger.serializeFilter)(newFilter, state.schema);
  if (!serializedNewFilter || (0, _isEqual["default"])(serializedOldFilter, serializedNewFilter)) {
    return state;
  }

  // If there are any changes to the filter, apply them
  var changed = pickChangedProps(serializedOldFilter, serializedNewFilter);
  delete changed['id']; // id should not be changed

  var filterIndex = state.filters.findIndex(function (f) {
    return f.id === filterId;
  });
  if (filterIndex < 0) {
    return state;
  }
  return setFilterUpdater(state, (0, _actions.setFilter)(filterIndex, Object.keys(changed), Object.values(changed)));
}

/**
 * Update filter property
 * @memberof visStateUpdaters
 * @public
 */
function setFilterUpdater(state, action) {
  var idx = action.idx,
    _action$valueIndex = action.valueIndex,
    valueIndex = _action$valueIndex === void 0 ? 0 : _action$valueIndex;
  var oldFilter = state.filters[idx];
  if (!oldFilter) {
    _window.console.error("filters.".concat(idx, " is undefined"));
    return state;
  }
  if (Array.isArray(action.prop) && (!Array.isArray(action.value) || action.prop.length !== action.value.length)) {
    _window.console.error('Expecting value to be an array of the same length, since prop is an array');
    return state;
  }
  // convert prop and value to array
  var props = (0, _commonUtils.toArray)(action.prop);
  var values = Array.isArray(action.prop) ? (0, _commonUtils.toArray)(action.value) : [action.value];
  var newFilter = oldFilter;
  var newState = state;
  var datasetIdsToFilter = [];
  var _loop = function _loop() {
    var prop = props[i];
    var value = values[i];
    // We currently do not support passing in name as an array into _updateFilterProp, so we call it multiple times with each name
    // See the comment in there as to what should be addressed
    var res;
    if (prop === 'name' && Array.isArray(value)) {
      // eslint-disable-next-line no-loop-func
      res = value.reduce(function (accu, v) {
        return _updateFilterProp(accu, newFilter, prop, v, valueIndex);
      }, newState);
    } else {
      res = _updateFilterProp(newState, newFilter, prop, value, valueIndex);
    }
    newFilter = res.filter;
    newState = res.state;
    datasetIdsToFilter = datasetIdsToFilter.concat(res.datasetIdsToFilter);
  };
  for (var i = 0; i < props.length; i++) {
    _loop();
  }
  var enlargedFilter = state.filters.find(function (f) {
    return f.view === _constants.FILTER_VIEW_TYPES.enlarged;
  });
  if (enlargedFilter && enlargedFilter.id !== newFilter.id) {
    // there should be only one enlarged filter
    newFilter.view = _constants.FILTER_VIEW_TYPES.side;
  }

  // save new filters to newState
  newState = (0, _utils.set)(['filters', idx], newFilter, newState);

  // filter data
  var filteredDatasets = (0, _utils.applyFiltersToDatasets)((0, _uniq["default"])(datasetIdsToFilter), newState.datasets, newState.filters, newState.layers);
  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState);

  // need to update filterPlot after filter Dataset for plot to update on filtered result
  var filterWithPLot = (0, _utils.updateFilterPlot)(newState.datasets, newState.filters[idx]);
  newState = (0, _utils.set)(['filters', idx], filterWithPLot, newState);

  // dataId is an array
  // pass only the dataset we need to update
  newState = updateAllLayerDomainData(newState, datasetIdsToFilter, newFilter);

  // If time range filter value was updated, adjust animation config
  if (newFilter.type === _constants.FILTER_TYPES.timeRange && props.includes('value')) {
    newState = adjustAnimationConfigWithFilter(newState, action.idx);
  }
  return newState;
}
function _updateFilterDataIdAtValueIndex(filter, valueIndex, value, datasets) {
  var newFilter = filter;
  if (filter.dataId[valueIndex]) {
    // if dataId already exist
    newFilter = _removeFilterDataIdAtValueIndex(filter, valueIndex, datasets);
  }
  if (value) {
    var nextValue = newFilter.dataId.slice();
    nextValue[valueIndex] = value;
    newFilter = (0, _utils.set)(['dataId'], nextValue, newFilter);
  }
  return newFilter;
}
function _removeFilterDataIdAtValueIndex(filter, valueIndex, datasets) {
  var dataId = filter.dataId[valueIndex];
  if (filter.dataId.length === 1 && valueIndex === 0) {
    // if remove the only dataId, create an empty filter instead;
    return (0, _utils.getDefaultFilter)({
      id: filter.id
    });
  }
  if (dataId) {
    filter = (0, _utils.removeFilterPlot)(filter, dataId);
  }
  for (var _i = 0, _arr = ['dataId', 'name', 'fieldIdx', 'gpuChannel']; _i < _arr.length; _i++) {
    var prop = _arr[_i];
    if (Array.isArray(filter[prop])) {
      var nextVal = filter[prop].slice();
      nextVal.splice(valueIndex, 1);
      filter = (0, _utils.set)([prop], nextVal, filter);
    }
  }

  // mergeFieldDomain for the remaining fields
  var domainSteps = (0, _utils.mergeFilterDomain)(filter, datasets);
  var nextFilter = _objectSpread(_objectSpread({}, filter), domainSteps ? {
    domain: domainSteps === null || domainSteps === void 0 ? void 0 : domainSteps.domain,
    step: domainSteps === null || domainSteps === void 0 ? void 0 : domainSteps.step
  } : {});
  var nextValue = (0, _utils.adjustValueToFilterDomain)(nextFilter.value, nextFilter);
  return _objectSpread(_objectSpread({}, nextFilter), {}, {
    value: nextValue
  });
}

/** *
 * Updates a single property of a filter
 */
function _updateFilterProp(state, filter, prop, value, valueIndex, datasetIds) {
  var datasetIdsToFilter = [];
  switch (prop) {
    // TODO: Next PR for UI if we update filterDataId, we need to consider two cases:
    // 1. dataId is empty: create a default filter
    // 2. Add a new dataset id
    case _utils.FILTER_UPDATER_PROPS.dataId:
      {
        var oldDataId = (0, _toConsumableArray2["default"])(filter.dataId);
        filter = _updateFilterDataIdAtValueIndex(filter, valueIndex, value, state.datasets);
        datasetIdsToFilter = (0, _uniq["default"])([].concat((0, _toConsumableArray2["default"])(oldDataId), (0, _toConsumableArray2["default"])(filter.dataId)));
        break;
      }
    case _utils.FILTER_UPDATER_PROPS.name:
      {
        // we are supporting the current functionality
        // TODO: Next PR for UI filter name will only update filter name but it won't have side effects
        // we are gonna use pair of datasets and fieldIdx to update the filter
        var datasetId = filter.dataId[valueIndex];
        var _applyFilterFieldName = (0, _utils.applyFilterFieldName)(filter, state.datasets, datasetId, value, valueIndex, {
            mergeDomain: valueIndex > 0
          }),
          updatedFilter = _applyFilterFieldName.filter,
          newDataset = _applyFilterFieldName.dataset;
        if (updatedFilter) {
          filter = updatedFilter;
          if (filter.gpu) {
            filter = (0, _table.setFilterGpuMode)(filter, state.filters);
            filter = (0, _table.assignGpuChannel)(filter, state.filters);
          }
          state = (0, _utils.set)(['datasets', datasetId], newDataset, state);
          // remove filter Plot at datasetId, so it will be recalculated
          filter = (0, _utils.removeFilterPlot)(filter, datasetId);
          datasetIdsToFilter = updatedFilter.dataId;
        }
        // only filter the current dataset
        break;
      }
    case _utils.FILTER_UPDATER_PROPS.layerId:
      {
        // We need to update only datasetId/s if we have added/removed layers
        // - check for layerId changes (XOR works because of string values)
        // if no differences between layerIds, don't do any filtering
        // @ts-ignore
        var layerIdDifference = (0, _xor["default"])(value, filter.layerId);
        var layerDataIds = (0, _uniq["default"])(layerIdDifference.map(function (lid) {
          return (0, _get["default"])(state.layers.find(function (l) {
            return l.id === lid;
          }), ['config', 'dataId']);
        }).filter(function (d) {
          return d;
        }));

        // only filter datasetsIds
        datasetIdsToFilter = layerDataIds;

        // Update newFilter dataIds
        var newDataIds = (0, _uniq["default"])(value === null || value === void 0 ? void 0 : value.map(function (lid) {
          return (0, _get["default"])(state.layers.find(function (l) {
            return l.id === lid;
          }), ['config', 'dataId']);
        }).filter(function (d) {
          return d;
        }));
        filter = _objectSpread(_objectSpread({}, filter), {}, {
          layerId: value,
          dataId: newDataIds
        });
        break;
      }
    default:
      filter = (0, _utils.set)([prop], value, filter);
      datasetIdsToFilter = (0, _toConsumableArray2["default"])(filter.dataId);
      break;
  }
  return {
    filter: filter,
    datasetIds: datasetIds,
    datasetIdsToFilter: datasetIdsToFilter,
    state: state
  };
}
/* eslint-enable max-statements */

/**
 * Set the property of a filter plot
 * @memberof visStateUpdaters
 * @public
 */
var setFilterPlotUpdater = exports.setFilterPlotUpdater = function setFilterPlotUpdater(state, _ref4) {
  var idx = _ref4.idx,
    newProp = _ref4.newProp;
  if (!state.filters[idx]) {
    _window.console.error("filters[".concat(idx, "] is undefined"));
    return state;
  }
  var newFilter = state.filters[idx];
  for (var prop in newProp) {
    if (prop === 'plotType') {
      newFilter = (0, _composerHelpers.pick_)('plotType')((0, _composerHelpers.merge_)(newProp.plotType))(newFilter);
    } else if (prop === 'yAxis') {
      var chartType = newProp.yAxis ? _constants.PLOT_TYPES.lineChart : _constants.PLOT_TYPES.histogram;
      newFilter = (0, _composerHelpers.pick_)('plotType')((0, _composerHelpers.merge_)({
        type: chartType
      }))((0, _composerHelpers.merge_)(newProp)(newFilter));
    }
  }
  newFilter = (0, _utils.updateFilterPlot)(state.datasets, newFilter);
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? newFilter : f;
    })
  });
};

/**
 * Add a new filter
 * @memberof visStateUpdaters
 * @public
 */
var addFilterUpdater = exports.addFilterUpdater = function addFilterUpdater(state, action) {
  return !action.dataId ? state : _objectSpread(_objectSpread({}, state), {}, {
    filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [(0, _utils.getDefaultFilter)({
      dataId: action.dataId,
      id: action.id
    })])
  });
};

/**
 * Create or update a filter
 * @memberof visStateUpdaters
 * @public
 */
var createOrUpdateFilterUpdater = exports.createOrUpdateFilterUpdater = function createOrUpdateFilterUpdater(state, action) {
  var id = action.id,
    dataId = action.dataId,
    field = action.field,
    value = action.value;
  var newState = state;
  var originalIndex = newState.filters.findIndex(function (f) {
    return f.id === id;
  });
  var filterIndex = originalIndex;
  if (!id && !dataId) {
    return newState;
  }
  if (originalIndex < 0 && dataId) {
    newState = addFilterUpdater(newState, {
      dataId: dataId
    });
    if (newState.filters.length !== state.filters.length + 1) {
      // No new filter was added
      return state;
    }
    // Here we are assuming that the filter was added at the end
    filterIndex = newState.filters.length - 1;
    newState.filters[filterIndex] = _objectSpread(_objectSpread({}, newState.filters[filterIndex]), id ? {
      id: id
    } : null);
  }

  // No need to update this if it's a newly created filter
  // First we make sure all the dataIds that fields refer to are updated
  if (originalIndex >= 0 && dataId) {
    // If the dataId is an array, we need to update each one individually as they need a correct valueIndex passed
    newState = (Array.isArray(dataId) ? dataId : [dataId]).reduce(function (accu, d, index) {
      return setFilterUpdater(accu, {
        idx: filterIndex,
        prop: 'dataId',
        value: d,
        valueIndex: index
      });
    }, newState);
  }
  // Then we update the fields
  if (field) {
    // If the field is an array, we need to update each field individually as they need a correct valueIndex passed
    newState = (Array.isArray(field) ? field : [field]).reduce(function (accu, f, index) {
      return setFilterUpdater(accu, {
        idx: filterIndex,
        prop: 'name',
        value: f,
        valueIndex: index
      });
    }, newState);
  }
  // Then we update the value separately
  if (value !== null && typeof value !== 'undefined') {
    newState = setFilterUpdater(newState, {
      idx: filterIndex,
      prop: 'value',
      value: value
    });
  }
  return newState;
};

/**
 * Set layer color palette ui state
 * @memberof visStateUpdaters
 */
var layerColorUIChangeUpdater = exports.layerColorUIChangeUpdater = function layerColorUIChangeUpdater(state, _ref5) {
  var oldLayer = _ref5.oldLayer,
    prop = _ref5.prop,
    newConfig = _ref5.newConfig;
  var oldVixConfig = oldLayer.config.visConfig[prop];
  var newLayer = oldLayer.updateLayerColorUI(prop, newConfig);
  var newVisConfig = newLayer.config.visConfig[prop];
  if (oldVixConfig !== newVisConfig) {
    return layerVisConfigChangeUpdater(state, {
      oldLayer: oldLayer,
      newVisConfig: (0, _defineProperty2["default"])({}, prop, newVisConfig)
    });
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: state.layers.map(function (l) {
      return l.id === oldLayer.id ? newLayer : l;
    })
  });
};

/**
 * Start and end filter animation
 * @memberof visStateUpdaters
 * @public
 */
var toggleFilterAnimationUpdater = exports.toggleFilterAnimationUpdater = function toggleFilterAnimationUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {
        isAnimating: !f.isAnimating
      }) : f;
    })
  });
};
function isFilterAnimationConfig(config) {
  return 'dataId' in config && 'animationWindow' in config;
}
function setAnimationConfigUpdater(state, action) {
  var config = action.config;
  if (isFilterAnimationConfig(config)) {
    // Find filter used for animation
    // Assuming there's only one filter used for animation, see setFilterViewUpdater
    var filter = state.filters.find(function (f) {
      return !(0, _utils.isSideFilter)(f);
    });
    if (!filter) {
      return state;
    }
    var newFilter = _objectSpread(_objectSpread({}, filter), config);
    return applyFilterConfigUpdater(state, (0, _actions.applyFilterConfig)(filter.id, newFilter));
  } else {
    return _objectSpread(_objectSpread({}, state), {}, {
      animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), config)
    });
  }
}

/**
 * @memberof visStateUpdaters
 * @public
 */
var toggleLayerAnimationUpdater = exports.toggleLayerAnimationUpdater = function toggleLayerAnimationUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      isAnimating: !state.animationConfig.isAnimating
    })
  });
};

/**
 * Hide and show layer animation control
 * @memberof visStateUpdaters
 * @public
 */
var toggleLayerAnimationControlUpdater = exports.toggleLayerAnimationControlUpdater = function toggleLayerAnimationControlUpdater(state) {
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      hideControl: !state.animationConfig.hideControl
    })
  });
};

/**
 * Change filter animation speed
 * @memberof visStateUpdaters
 * @public
 */
var updateFilterAnimationSpeedUpdater = exports.updateFilterAnimationSpeedUpdater = function updateFilterAnimationSpeedUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {
        speed: action.speed
      }) : f;
    })
  });
};

/**
 * Update animation speed with the vertical speed slider
 * @memberof visStateUpdaters
 * @public
 *
 */
var updateLayerAnimationSpeedUpdater = exports.updateLayerAnimationSpeedUpdater = function updateLayerAnimationSpeedUpdater(state, _ref6) {
  var speed = _ref6.speed;
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      speed: speed
    })
  });
};

/**
 * Show larger time filter at bottom for time playback (apply to time filter only)
 * @memberof visStateUpdaters
 * @public
 */
var setFilterViewUpdater = exports.setFilterViewUpdater = function setFilterViewUpdater(state, action) {
  var view = action.view,
    idx = action.idx;
  var shouldResetOtherFiltersView = view === _constants.FILTER_VIEW_TYPES.enlarged;
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? _objectSpread(_objectSpread({}, f), {}, {
        view: view
      }) : shouldResetOtherFiltersView ? _objectSpread(_objectSpread({}, f), {}, {
        view: _constants.FILTER_VIEW_TYPES.side
      }) : f;
    })
  });
};

/**
 * Toggles filter feature visibility
 * @memberof visStateUpdaters
 */
var toggleFilterFeatureUpdater = exports.toggleFilterFeatureUpdater = function toggleFilterFeatureUpdater(state, action) {
  var filter = state.filters[action.idx];
  var isVisible = (0, _get["default"])(filter, ['value', 'properties', 'isVisible']);
  var newState = setFilterUpdater(state, {
    idx: action.idx,
    prop: 'enabled',
    value: !isVisible
  });
  newState = setFilterUpdater(newState, {
    idx: action.idx,
    prop: 'value',
    value: (0, _utils.featureToFilterValue)(filter.value, filter.id, {
      isVisible: !isVisible
    })
  });
  return newState;
};

/**
 * Remove a filter
 * @memberof visStateUpdaters
 * @public
 */
var removeFilterUpdater = exports.removeFilterUpdater = function removeFilterUpdater(state, action) {
  var idx = action.idx;
  var _state$filters$idx = state.filters[idx],
    dataId = _state$filters$idx.dataId,
    id = _state$filters$idx.id;
  var newFilters = [].concat((0, _toConsumableArray2["default"])(state.filters.slice(0, idx)), (0, _toConsumableArray2["default"])(state.filters.slice(idx + 1, state.filters.length)));
  var filteredDatasets = (0, _utils.applyFiltersToDatasets)(dataId, state.datasets, newFilters, state.layers);
  var newEditor = (0, _utils.getFilterIdInFeature)(state.editor.selectedFeature) === id ? _objectSpread(_objectSpread({}, state.editor), {}, {
    selectedFeature: null
  }) : state.editor;
  var newState = (0, _utils.set)(['filters'], newFilters, state);
  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState);
  newState = (0, _utils.set)(['editor'], newEditor, newState);
  return updateAllLayerDomainData(newState, dataId, undefined);
};

/**
 * Add a new layer
 * @memberof visStateUpdaters
 * @public
 */
var addLayerUpdater = exports.addLayerUpdater = function addLayerUpdater(state, action) {
  var newLayer;
  var newLayerData;
  if (action.config) {
    newLayer = (0, _visStateMerger.createLayerFromConfig)(state, action.config);
    if (!newLayer) {
      _window.console.warn('Failed to create layer from config, it usually means the config is not be in correct format', action.config);
      return state;
    }
    var result = (0, _layerUtils.calculateLayerData)(newLayer, state);
    newLayer = result.layer;
    newLayerData = result.layerData;
  } else {
    var _action$datasetId;
    // create an empty layer with a specific dataset or a default one
    var defaultDataset = (_action$datasetId = action.datasetId) !== null && _action$datasetId !== void 0 ? _action$datasetId : Object.keys(state.datasets)[0];
    newLayer = new _layers.Layer({
      isVisible: true,
      isConfigActive: true,
      dataId: defaultDataset
    });
    newLayerData = {};
  }
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: [].concat((0, _toConsumableArray2["default"])(state.layers), [newLayer]),
    layerData: [].concat((0, _toConsumableArray2["default"])(state.layerData), [newLayerData]),
    // add new layer at the top
    layerOrder: [newLayer.id].concat((0, _toConsumableArray2["default"])(state.layerOrder)),
    splitMaps: (0, _utils.addNewLayersToSplitMap)(state.splitMaps, newLayer)
  });
  if (newLayer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  }
  return newState;
};

/**
 * remove layer
 * @memberof visStateUpdaters
 * @public
 */
function removeLayerUpdater(state, _ref7) {
  var id = _ref7.id;
  var idx = Number.isFinite(id) ?
  // support older API, remove layer by idx
  Number(id) : state.layers.findIndex(function (l) {
    return l.id === id;
  });
  if (idx < 0 || idx >= state.layers.length) {
    // invalid index
    _window.console.warn("can not remove layer with invalid id|idx ".concat(id));
    return state;
  }
  var layers = state.layers,
    layerData = state.layerData,
    layerOrder = state.layerOrder,
    clicked = state.clicked,
    hoverInfo = state.hoverInfo;
  var layerToRemove = layers[idx];
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: (0, _composerHelpers.filterOutById)(layerToRemove.id)(layers),
    layerData: (0, _composerHelpers.removeElementAtIndex)(idx)(layerData),
    layerOrder: layerOrder.filter(function (layerId) {
      return layerId !== layerToRemove.id;
    }),
    clicked: layerToRemove.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: layerToRemove.isLayerHovered(hoverInfo) ? undefined : hoverInfo,
    splitMaps: (0, _utils.removeLayerFromSplitMaps)(state.splitMaps, layerToRemove)
    // TODO: update filters, create helper to remove layer form filter (remove layerid and dataid) if mapped
  });
  return updateAnimationDomain(newState);
}

/**
 * Reorder layer
 * @memberof visStateUpdaters
 * @public
 */
var reorderLayerUpdater = exports.reorderLayerUpdater = function reorderLayerUpdater(state, _ref8) {
  var order = _ref8.order;
  return _objectSpread(_objectSpread({}, state), {}, {
    layerOrder: order
  });
};

/**
 * duplicate layer
 * @memberof visStateUpdaters
 * @public
 */
var duplicateLayerUpdater = exports.duplicateLayerUpdater = function duplicateLayerUpdater(state, _ref9) {
  var id = _ref9.id;
  var idx = Number.isFinite(id) ?
  // support older API, remove layer by idx
  Number(id) : state.layers.findIndex(function (l) {
    return l.id === id;
  });
  if (idx < 0 || !state.layers[idx]) {
    _window.console.warn("layer ".concat(idx, " not found in layerOrder"));
    return state;
  }
  var layers = state.layers;
  var original = layers[idx];
  var originalLayerOrderIdx = state.layerOrder.findIndex(function (lid) {
    return lid === original.id;
  });
  var newLabel = "Copy of ".concat(original.config.label);
  var postfix = 0;
  // eslint-disable-next-line no-loop-func
  while (layers.find(function (l) {
    return l.config.label === newLabel;
  })) {
    newLabel = "Copy of ".concat(original.config.label, " ").concat(++postfix);
  }

  // collect layer config from original
  var loadedLayer = (0, _visStateMerger.serializeLayer)(original, state.schema);

  // assign new id and label to copied layer
  if (!(loadedLayer !== null && loadedLayer !== void 0 && loadedLayer.config)) {
    return state;
  }
  loadedLayer.config.label = newLabel;
  loadedLayer.id = (0, _commonUtils.generateHashId)(_layers.LAYER_ID_LENGTH);

  // add layer to state
  var nextState = addLayerUpdater(state, {
    config: loadedLayer
  });
  // retrieve newly created layer
  var newLayer = nextState.layers[nextState.layers.length - 1];
  // update layer order with newLyaer.id
  var newLayerOrder = (0, _utils.arrayInsert)(nextState.layerOrder.slice(1, nextState.layerOrder.length), originalLayerOrderIdx, newLayer.id);
  nextState = reorderLayerUpdater(nextState, {
    order: newLayerOrder
  });
  return updateAnimationDomain(nextState);
};

/**
 * Add a new effect
 * @memberof visStateUpdaters
 * @public
 */
var addEffectUpdater = exports.addEffectUpdater = function addEffectUpdater(state, action) {
  var _action$config;
  if (((_action$config = action.config) === null || _action$config === void 0 ? void 0 : _action$config.type) === _constants.LIGHT_AND_SHADOW_EFFECT.type && state.effects.some(function (effect) {
    return effect.type === _constants.LIGHT_AND_SHADOW_EFFECT.type;
  })) {
    _window.console.warn("Can't add more than one ".concat(_constants.LIGHT_AND_SHADOW_EFFECT.name, " effect"));
    return state;
  }
  var newEffect = (0, _effects.createEffect)(action.config);

  // collapse configurators for other effects
  state.effects.forEach(function (effect) {
    return effect.setProps({
      isConfigActive: false
    });
  });
  var effects = [].concat((0, _toConsumableArray2["default"])(state.effects), [newEffect]);
  var effectOrder = (0, _utils.fixEffectOrder)(effects, [newEffect.id].concat((0, _toConsumableArray2["default"])(state.effectOrder)));
  return _objectSpread(_objectSpread({}, state), {}, {
    effects: effects,
    effectOrder: effectOrder
  });
};

/**
 * remove effect
 * @memberof visStateUpdaters
 * @public
 */
var removeEffectUpdater = exports.removeEffectUpdater = function removeEffectUpdater(state, _ref10) {
  var id = _ref10.id;
  var idx = state.effects.findIndex(function (l) {
    return l.id === id;
  });
  if (idx < 0 || idx >= state.effects.length) {
    _window.console.warn("can not remove effect with invalid id ".concat(id));
    return state;
  }
  var effects = state.effects,
    effectOrder = state.effectOrder;
  var effectToRemove = effects[idx];
  return _objectSpread(_objectSpread({}, state), {}, {
    // @ts-expect-error fixed in ts
    effects: (0, _composerHelpers.filterOutById)(effectToRemove.id)(effects),
    effectOrder: effectOrder.filter(function (effectId) {
      return effectId !== effectToRemove.id;
    })
  });
};

/**
 * Reorder effect
 * @memberof visStateUpdaters
 * @public
 */
var reorderEffectUpdater = exports.reorderEffectUpdater = function reorderEffectUpdater(state, _ref11) {
  var order = _ref11.order;
  return _objectSpread(_objectSpread({}, state), {}, {
    effectOrder: (0, _utils.fixEffectOrder)(state.effects, (0, _toConsumableArray2["default"])(order))
  });
};

/**
 * Update effect
 * @memberof visStateUpdaters
 * @public
 */
var updateEffectUpdater = exports.updateEffectUpdater = function updateEffectUpdater(state, _ref12) {
  var id = _ref12.id,
    props = _ref12.props;
  var idx = state.effects.findIndex(function (l) {
    return l.id === id;
  });
  if (idx < 0 || idx >= state.effects.length) {
    _window.console.warn("can not update effect with invalid id ".concat(id));
    return state;
  }
  var effectOrder = state.effectOrder;
  if (props.id !== undefined && props.id !== id) {
    var idx2 = state.effects.findIndex(function (l) {
      return l.id === props.id;
    });
    if (idx2 >= 0) {
      _window.console.warn("can not update effect with existing effect id ".concat(id));
      return state;
    }
    effectOrder = effectOrder.map(function (effectOrderId) {
      return effectOrderId === id ? props.id : effectOrderId;
    });
  }
  var newEffects = (0, _toConsumableArray2["default"])(state.effects);
  newEffects[idx].setProps(props);
  return _objectSpread(_objectSpread({}, state), {}, {
    effects: newEffects,
    effectOrder: effectOrder
  });
};

/**
 * Remove a dataset and all layers, filters, tooltip configs that based on it
 * @memberof visStateUpdaters
 * @public
 */
function removeDatasetUpdater(state, action) {
  // extract dataset key
  var datasetKey = action.dataId;
  var datasets = state.datasets;

  // check if dataset is present
  if (!datasets[datasetKey]) {
    return state;
  }
  var layers = state.layers,
    _state$datasets = state.datasets,
    dataset = _state$datasets[datasetKey],
    newDatasets = (0, _objectWithoutProperties2["default"])(_state$datasets, [datasetKey].map(_toPropertyKey));
  var layersToRemove = layers.filter(function (l) {
    return l.config.dataId === datasetKey;
  }).map(function (l) {
    return l.id;
  });

  // remove layers and datasets
  var newState = layersToRemove.reduce(function (accu, id) {
    return removeLayerUpdater(accu, {
      id: id
    });
  }, _objectSpread(_objectSpread({}, state), {}, {
    datasets: newDatasets
  }));

  // update filters
  var filters = [];
  var _iterator2 = _createForOfIteratorHelper(newState.filters),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var filter = _step2.value;
      var valueIndex = filter.dataId.indexOf(datasetKey);
      if (valueIndex >= 0 && filter.dataId.length > 1) {
        // only remove one synced dataset from the filter
        filters.push(_removeFilterDataIdAtValueIndex(filter, valueIndex, datasets));
      } else if (valueIndex < 0) {
        // leave the filter as is
        filters.push(filter);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  newState = _objectSpread(_objectSpread({}, newState), {}, {
    filters: filters
  });
  return removeDatasetFromInteractionConfig(newState, {
    dataId: datasetKey
  });
}
function removeDatasetFromInteractionConfig(state, _ref13) {
  var dataId = _ref13.dataId;
  var interactionConfig = state.interactionConfig;
  var _interactionConfig = interactionConfig,
    tooltip = _interactionConfig.tooltip;
  if (tooltip) {
    var config = tooltip.config;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var _config$fieldsToShow = config.fieldsToShow,
      fields = _config$fieldsToShow[dataId],
      fieldsToShow = (0, _objectWithoutProperties2["default"])(_config$fieldsToShow, [dataId].map(_toPropertyKey));
    interactionConfig = _objectSpread(_objectSpread({}, interactionConfig), {}, {
      tooltip: _objectSpread(_objectSpread({}, tooltip), {}, {
        config: _objectSpread(_objectSpread({}, config), {}, {
          fieldsToShow: fieldsToShow
        })
      })
    });
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: interactionConfig
  });
}
/**
 * update layer blending mode
 * @memberof visStateUpdaters
 * @public
 */
var updateLayerBlendingUpdater = exports.updateLayerBlendingUpdater = function updateLayerBlendingUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    layerBlending: action.mode
  });
};

/**
 * update overlay blending mode
 * @memberof visStateUpdaters
 * @public
 */
var updateOverlayBlendingUpdater = exports.updateOverlayBlendingUpdater = function updateOverlayBlendingUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    overlayBlending: action.mode
  });
};

/**
 * Display dataset table in a modal
 * @memberof visStateUpdaters
 * @public
 */
var showDatasetTableUpdater = exports.showDatasetTableUpdater = function showDatasetTableUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    editingDataset: action.dataId
  });
};

/**
 * Add custom color for datasets and layers
 * @memberof visStateUpdaters
 * @public
 */
var updateTableColorUpdater = exports.updateTableColorUpdater = function updateTableColorUpdater(state, action) {
  return updateDatasetPropsUpdater(state, {
    dataId: action.dataId,
    props: {
      color: action.newColor
    }
  });
};

/**
 * reset visState to initial State
 * @memberof visStateUpdaters
 * @public
 */
var resetMapConfigUpdater = exports.resetMapConfigUpdater = function resetMapConfigUpdater(state) {
  return _objectSpread(_objectSpread(_objectSpread({}, INITIAL_VIS_STATE), state.initialState), {}, {
    initialState: state.initialState
  });
};

/**
 * Propagate `visState` reducer with a new configuration. Current config will be override.
 * @memberof visStateUpdaters
 * @public
 */
var receiveMapConfigUpdater = exports.receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref14) {
  var _ref14$payload = _ref14.payload,
    _ref14$payload$config = _ref14$payload.config,
    config = _ref14$payload$config === void 0 ? {} : _ref14$payload$config,
    _ref14$payload$option = _ref14$payload.options,
    options = _ref14$payload$option === void 0 ? {} : _ref14$payload$option;
  if (!config.visState) {
    return state;
  }
  var keepExistingConfig = options.keepExistingConfig;

  // reset config if keepExistingConfig is falsy
  var mergedState = !keepExistingConfig ? resetMapConfigUpdater(state) : state;
  var _iterator3 = _createForOfIteratorHelper(state.mergers),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var merger = _step3.value;
      if ((0, _mergerHandler.isValidMerger)(merger) && (0, _mergerHandler.hasPropsToMerge)(config.visState, merger.prop)) {
        mergedState = merger.merge(mergedState, (0, _mergerHandler.getPropValueToMerger)(config.visState, merger.prop, merger.toMergeProp),
        // fromConfig
        true);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return mergedState;
};

/**
 * Trigger layer hover event with hovered object
 * @memberof visStateUpdaters
 * @public
 */
var layerHoverUpdater = exports.layerHoverUpdater = function layerHoverUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    hoverInfo: _objectSpread(_objectSpread({}, action.info), Number.isFinite(action.mapIndex) ? {
      mapIndex: action.mapIndex
    } : {})
  });
};

/* eslint-enable max-statements */

/**
 * Update `interactionConfig`
 * @memberof visStateUpdaters
 * @public
 */
function interactionConfigChangeUpdater(state, action) {
  var config = action.config;
  var interactionConfig = _objectSpread(_objectSpread({}, state.interactionConfig), (0, _defineProperty2["default"])({}, config.id, config));

  // Don't enable tooltip and brush at the same time
  // but coordinates can be shown at all time
  var contradict = ['brush', 'tooltip'];
  if (contradict.includes(config.id) && config.enabled && !state.interactionConfig[config.id].enabled) {
    // only enable one interaction at a time
    contradict.forEach(function (k) {
      if (k !== config.id) {
        interactionConfig[k] = _objectSpread(_objectSpread({}, interactionConfig[k]), {}, {
          enabled: false
        });
      }
    });
  }
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: interactionConfig
  });
  if (config.id === 'geocoder' && !config.enabled) {
    return removeDatasetUpdater(newState, {
      dataId: 'geocoder_dataset'
    });
  }
  return newState;
}

/**
 * Trigger layer click event with clicked object
 * @memberof visStateUpdaters
 * @public
 */
var layerClickUpdater = exports.layerClickUpdater = function layerClickUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    mousePos: state.interactionConfig.coordinate.enabled ? _objectSpread(_objectSpread({}, state.mousePos), {}, {
      pinned: state.mousePos.pinned ? null : (0, _cloneDeep["default"])(state.mousePos)
    }) : state.mousePos,
    clicked: action.info && action.info.picked ? action.info : null
  });
};

/**
 * Trigger map click event, unselect clicked object
 * @memberof visStateUpdaters
 * @public
 */
var mapClickUpdater = exports.mapClickUpdater = function mapClickUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    clicked: null
  });
};

/**
 * Trigger map move event
 * @memberof visStateUpdaters
 * @public
 */
var mouseMoveUpdater = exports.mouseMoveUpdater = function mouseMoveUpdater(state, _ref15) {
  var evt = _ref15.evt;
  if (Object.values(state.interactionConfig).some(function (config) {
    return config.enabled;
  })) {
    return _objectSpread(_objectSpread({}, state), {}, {
      mousePos: _objectSpread(_objectSpread(_objectSpread({}, state.mousePos), Array.isArray(evt.point) ? {
        mousePosition: (0, _toConsumableArray2["default"])(evt.point)
      } : {}), Array.isArray(evt.lngLat) ? {
        coordinate: (0, _toConsumableArray2["default"])(evt.lngLat)
      } : {})
    });
  }
  return state;
};
/**
 * Toggle visibility of a layer for a split map
 * @memberof visStateUpdaters
 * @public
 */
var toggleSplitMapUpdater = exports.toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {
  return state.splitMaps && state.splitMaps.length === 0 ? _objectSpread(_objectSpread({}, state), {}, {
    // maybe we should use an array to store state for a single map as well
    // if current maps length is equal to 0 it means that we are about to split the view
    splitMaps: (0, _utils.computeSplitMapLayers)(state.layers, {
      duplicate: false
    })
  }) : closeSpecificMapAtIndex(state, action);
};

/**
 * Toggle visibility of a layer in a split map
 * @memberof visStateUpdaters
 * @public
 */
var toggleLayerForMapUpdater = exports.toggleLayerForMapUpdater = function toggleLayerForMapUpdater(state, _ref16) {
  var mapIndex = _ref16.mapIndex,
    layerId = _ref16.layerId;
  var splitMaps = state.splitMaps;
  return _objectSpread(_objectSpread({}, state), {}, {
    splitMaps: splitMaps.map(function (sm, i) {
      return i === mapIndex ? _objectSpread(_objectSpread({}, splitMaps[i]), {}, {
        layers: _objectSpread(_objectSpread({}, splitMaps[i].layers), {}, (0, _defineProperty2["default"])({}, layerId, !splitMaps[i].layers[layerId]))
      }) : sm;
    })
  });
};

/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 * @memberof visStateUpdaters
 * @public
 */
// eslint-disable-next-line complexity
var updateVisDataUpdater = exports.updateVisDataUpdater = function updateVisDataUpdater(state, action) {
  // datasets can be a single data entries or an array of multiple data entries
  var config = action.config,
    options = action.options;

  // apply config if passed from action
  // TODO: we don't handle async mergers here yet
  var updatedState = config ? receiveMapConfigUpdater(state, {
    payload: {
      config: config,
      options: options
    }
  }) : state;
  var datasets = (0, _commonUtils.toArray)(action.datasets);
  if (!datasets.length) {
    return updatedState;
  }
  var createDatasetTasks = [];
  var notificationTasks = [];
  datasets.forEach(function (_ref17, datasetIndex) {
    var _ref17$info = _ref17.info,
      info = _ref17$info === void 0 ? {} : _ref17$info,
      rest = (0, _objectWithoutProperties2["default"])(_ref17, _excluded2);
    var task = (0, _table.createNewDataEntry)(_objectSpread({
      info: info
    }, rest), state.datasets);
    if (task) {
      createDatasetTasks.push(task);
    } else {
      notificationTasks.push(ACTION_TASK_ADD_NOTIFICATION().map(function () {
        return (0, _actions.addNotification)((0, _utils.errorNotification)({
          message: "Failed to create a new dataset due to data verification errors",
          id: "dataset-failed-".concat(datasetIndex)
        }));
      }));
    }
  });
  var datasetsAllSettledTask = createDatasetTasks.length ? _tasks["default"].allSettled(createDatasetTasks).map(function (results) {
    return (0, _actions.createNewDatasetSuccess)({
      results: results,
      addToMapOptions: options
    });
  }) : null;
  if (datasetsAllSettledTask) {
    updatedState = setLoadingIndicatorUpdater(updatedState, (0, _composerHelpers.payload_)({
      change: 1,
      type: ''
    }));
  }
  return (0, _tasks.withTask)(updatedState, [].concat((0, _toConsumableArray2["default"])(datasetsAllSettledTask ? [datasetsAllSettledTask] : []), notificationTasks));
};
var createNewDatasetSuccessUpdater = exports.createNewDatasetSuccessUpdater = function createNewDatasetSuccessUpdater(state, action) {
  var _action$payload = action.payload,
    results = _action$payload.results,
    addToMapOptions = _action$payload.addToMapOptions;
  var notificationTasks = [];
  var newDataEntries = results.reduce(function (accu, result, idx) {
    if (result.status === 'fulfilled') {
      var dataset = result.value;
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, dataset.id, dataset));
    } else {
      // show error notification on UI
      notificationTasks.push((0, _tasks2.ACTION_TASK)().map(function () {
        return (0, _actions.addNotification)((0, _utils.errorNotification)({
          message: "Dataset error: Failed to create a new dataset:\n              ".concat(result.reason || result.value),
          id: "dataset-create-failed-".concat(idx)
        }));
      }));
      return accu;
    }
  }, {});
  // save new dataset entry to state
  var mergedState = _objectSpread(_objectSpread({}, state), {}, {
    datasets: (0, _visStateMerger.mergeDatasetsByOrder)(state, newDataEntries)
  });

  // merge state with config to be merged
  var layerMergers = state.mergers.filter(function (m) {
    return m.waitForLayerData;
  });
  var datasetMergers = state.mergers.filter(function (m) {
    return !layerMergers.includes(m);
  });
  var newDataIds = Object.keys(newDataEntries);
  var postMergerPayload = {
    newDataIds: newDataIds,
    options: addToMapOptions,
    layerMergers: layerMergers
  };
  var updatedState = applyMergersUpdater(mergedState, {
    mergers: datasetMergers,
    postMergerPayload: postMergerPayload
  });
  return (0, _tasks.withTask)(setLoadingIndicatorUpdater(updatedState, (0, _composerHelpers.payload_)({
    change: -1
  })), notificationTasks);
};

/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 */
function applyMergersUpdater(state, action) {
  var mergers = action.mergers,
    postMergerPayload = action.postMergerPayload;

  // merge state with config to be merged
  var mergeStateResult = (0, _mergerHandler.mergeStateFromMergers)(state, _objectSpread(_objectSpread({}, INITIAL_VIS_STATE), state.initialState), mergers,
  // newDataIds,
  postMergerPayload);

  // if all merged, kickup post merge process
  // if not wait
  return mergeStateResult.allMerged ? postMergeUpdater(mergeStateResult.mergedState, postMergerPayload) : mergeStateResult.mergedState;
}

/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 */
function postMergeUpdater(mergedState, postMergerPayload) {
  var newDataIds = postMergerPayload.newDataIds,
    options = postMergerPayload.options,
    layerMergers = postMergerPayload.layerMergers;
  var newFilters = mergedState.filters.filter(function (f) {
    return f.dataId.find(function (fDataId) {
      return newDataIds.includes(fDataId);
    });
  });
  var datasetFiltered = (0, _uniq["default"])(newFilters.reduce(function (accu, f) {
    return [].concat((0, _toConsumableArray2["default"])(accu), (0, _toConsumableArray2["default"])(f.dataId));
  }, []));
  var dataEmpty = newDataIds.length < 1;
  var newLayers = !dataEmpty ? mergedState.layers.filter(function (l) {
    return l.config.dataId && newDataIds.includes(l.config.dataId);
  }) : [];
  var newDataEntries = newDataIds.reduce(function (accu, id) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, mergedState.datasets[id]));
  }, {});
  if (!newLayers.length && (options || {}).autoCreateLayers !== false) {
    // no layer merged, find defaults
    var result = addDefaultLayers(mergedState, newDataEntries);
    mergedState = result.state;
    newLayers = result.newLayers;
  }
  if (mergedState.splitMaps.length) {
    // if map is split, add new layers to splitMaps
    newLayers = mergedState.layers.filter(function (l) {
      return l.config.dataId && newDataIds.includes(l.config.dataId);
    });
    mergedState = _objectSpread(_objectSpread({}, mergedState), {}, {
      splitMaps: (0, _utils.addNewLayersToSplitMap)(mergedState.splitMaps, newLayers)
    });
  }

  // if no tooltips merged add default tooltips
  newDataIds.forEach(function (dataId) {
    var tooltipFields = mergedState.interactionConfig.tooltip.config.fieldsToShow[dataId];
    // loading dataset: autoCreateTooltips is false and we don't want to run addDefaultTooltips when tooltipFields is empty
    if ((options === null || options === void 0 ? void 0 : options.autoCreateTooltips) !== false && (!Array.isArray(tooltipFields) || !tooltipFields.length)) {
      // adding dataset: autoCreateTooltips is true
      mergedState = addDefaultTooltips(mergedState, newDataEntries[dataId]);
    }
  });
  var updatedDatasets = dataEmpty ? Object.keys(mergedState.datasets) : (0, _uniq["default"])(Object.keys(newDataEntries).concat(datasetFiltered));
  var updatedState = updateAllLayerDomainData(mergedState, updatedDatasets, undefined);

  // register layer animation domain,
  // need to be called after layer data is calculated
  updatedState = updateAnimationDomain(updatedState);

  // try to process layerMergers after dataset+datasetMergers
  updatedState = layerMergers && layerMergers.length > 0 ? applyMergersUpdater(updatedState, {
    mergers: layerMergers,
    postMergerPayload: _objectSpread(_objectSpread({}, postMergerPayload), {}, {
      layerMergers: []
    })
  }) : updatedState;

  // center the map once the dataset is created
  if (newLayers.length && (options || {}).centerMap) {
    var bounds = (0, _dataUtils.findMapBounds)(newLayers);
    if (bounds) {
      var fitBoundsTask = ACTION_TASK_FIT_BOUNDS().map(function () {
        return (0, _actions.fitBounds)(bounds);
      });
      updatedState = (0, _tasks.withTask)(updatedState, fitBoundsTask);
    }
  }

  // need to center map here if we have new layers
  return updatedState;
}

/**
 * Rename an existing dataset in `visState`
 * @memberof visStateUpdaters
 * @public
 */
function renameDatasetUpdater(state, action) {
  return updateDatasetPropsUpdater(state, {
    dataId: action.dataId,
    props: {
      label: action.label
    }
  });
}
var ALLOWED_UPDATE_DATASET_PROPS = ['label', 'color', 'metadata'];

/**
 * Validates properties before updating the dataset.
 * Makes sure each property is in the allowed list
 * Makes sure color value is RGB
 * Performs deep merge when updating metadata
 */
var validateDatasetUpdateProps = function validateDatasetUpdateProps(props, dataset) {
  var validatedProps = Object.entries(props).reduce(function (acc, entry) {
    var _entry = (0, _slicedToArray2["default"])(entry, 2),
      key = _entry[0],
      value = _entry[1];
    // is it allowed ?
    if (!ALLOWED_UPDATE_DATASET_PROPS.includes(key)) {
      return acc;
    }

    // if we are adding a color but it is not RGB we don't accept the value
    // in the future as we add more props we should change this if into a switch
    if (key === 'color' && !(0, _utils.isRgbColor)(value)) {
      return acc;
    }

    // do we need deep merge ?
    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, key, (0, _utils.isPlainObject)(value) ? (0, _deepmerge["default"])(dataset[key] || {}, value) : value));
  }, {});
  return validatedProps;
};

/**
 * Update Dataset props (label, color, meta). Do not use to update data or any related properties
 * @memberof visStateUpdaters
 * @public
 */
function updateDatasetPropsUpdater(state, action) {
  var dataId = action.dataId,
    props = action.props;
  var datasets = state.datasets;
  var existing = datasets[dataId];
  if (existing) {
    var validatedProps = validateDatasetUpdateProps(props, existing);
    //  validate props: just color for now
    //  we only allow label, color and meta to be updated
    // const newTable = copyTableAndUpdate(existing, validatedProps);
    return _objectSpread(_objectSpread({}, state), {}, {
      datasets: _objectSpread(_objectSpread({}, datasets), {}, (0, _defineProperty2["default"])({}, dataId, (0, _table.copyTableAndUpdate)(existing, validatedProps)))
    });
  }
  return state;
}

/**
 * When a user clicks on the specific map closing icon
 * the application will close the selected map
 * and will merge the remaining one with the global state
 * TODO: i think in the future this action should be called merge map layers with global settings
 * @param {Object} state `visState`
 * @param {Object} action action
 * @returns {Object} nextState
 */
function closeSpecificMapAtIndex(state, action) {
  var _state$splitMaps$inde;
  // retrieve layers meta data from the remaining map that we need to keep
  var indexToRetrieve = 1 - action.payload;
  var mapLayers = (_state$splitMaps$inde = state.splitMaps[indexToRetrieve]) === null || _state$splitMaps$inde === void 0 ? void 0 : _state$splitMaps$inde.layers;
  var layers = state.layers;

  // update layer visibility
  var newLayers = layers.map(function (layer) {
    return mapLayers && !mapLayers[layer.id] && layer.config.isVisible ? layer.updateLayerConfig({
      // if layer.id is not in mapLayers, it should be inVisible
      isVisible: false
    }) : layer;
  });

  // delete map
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    splitMaps: []
  });
}

/**
 * Trigger file loading dispatch `addDataToMap` if succeed, or `loadFilesErr` if failed
 * @memberof visStateUpdaters
 * @public
 */
var loadFilesUpdater = exports.loadFilesUpdater = function loadFilesUpdater(state, action) {
  var files = action.files,
    _action$onFinish = action.onFinish,
    onFinish = _action$onFinish === void 0 ? _actions.loadFilesSuccess : _action$onFinish;
  if (!files.length) {
    return state;
  }
  var fileLoadingProgress = Array.from(files).reduce(function (accu, f, i) {
    return (0, _composerHelpers.merge_)(initialFileLoadingProgress(f, i))(accu);
  }, {});
  var fileLoading = {
    fileCache: [],
    filesToLoad: files,
    onFinish: onFinish
  };
  var nextState = (0, _composerHelpers.merge_)({
    fileLoadingProgress: fileLoadingProgress,
    fileLoading: fileLoading
  })(state);
  return loadNextFileUpdater(nextState);
};

/**
 * Sucessfully loaded one file, move on to the next one
 * @memberof visStateUpdaters
 * @public
 */
function loadFileStepSuccessUpdater(state, action) {
  if (!state.fileLoading) {
    return state;
  }
  var fileName = action.fileName,
    fileCache = action.fileCache;
  var _state$fileLoading = state.fileLoading,
    filesToLoad = _state$fileLoading.filesToLoad,
    onFinish = _state$fileLoading.onFinish;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: {
      percent: 1,
      message: 'Done'
    }
  });

  // save processed file to fileCache
  var stateWithCache = (0, _composerHelpers.pick_)('fileLoading')((0, _composerHelpers.merge_)({
    fileCache: fileCache
  }))(stateWithProgress);
  return (0, _tasks.withTask)(stateWithCache, (0, _tasks2.DELAY_TASK)(200).map(filesToLoad.length ? _actions.loadNextFile : function () {
    return onFinish(fileCache);
  }));
}

// withTask<T>(state: T, task: any): T

/**
 *
 * @memberof visStateUpdaters
 * @public
 */
function loadNextFileUpdater(state) {
  if (!state.fileLoading) {
    return state;
  }
  var filesToLoad = state.fileLoading.filesToLoad;
  var _filesToLoad = (0, _toArray2["default"])(filesToLoad),
    file = _filesToLoad[0],
    remainingFilesToLoad = _filesToLoad.slice(1);

  // save filesToLoad to state
  var nextState = (0, _composerHelpers.pick_)('fileLoading')((0, _composerHelpers.merge_)({
    filesToLoad: remainingFilesToLoad
  }))(state);
  var stateWithProgress = updateFileLoadingProgressUpdater(nextState, {
    fileName: file.name,
    progress: {
      percent: 0,
      message: 'loading...'
    }
  });
  var loaders = state.loaders,
    loadOptions = state.loadOptions;
  return (0, _tasks.withTask)(stateWithProgress, makeLoadFileTask(file, nextState.fileLoading && nextState.fileLoading.fileCache, loaders, loadOptions));
}
function makeLoadFileTask(file, fileCache) {
  var loaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var loadOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return (0, _tasks2.LOAD_FILE_TASK)({
    file: file,
    fileCache: fileCache,
    loaders: loaders,
    loadOptions: loadOptions
  }).bimap(
  // prettier ignore
  // success
  function (gen) {
    return (0, _actions.nextFileBatch)({
      gen: gen,
      fileName: file.name,
      onFinish: function onFinish(result) {
        return (0, _actions.processFileContent)({
          content: result,
          fileCache: fileCache
        });
      }
    });
  },
  // error
  function (err) {
    return (0, _actions.loadFilesErr)(file.name, err);
  });
}

/**
 *
 * @memberof visStateUpdaters
 * @public
 */
function processFileContentUpdater(state, action) {
  var _action$payload2 = action.payload,
    content = _action$payload2.content,
    fileCache = _action$payload2.fileCache;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: content.fileName,
    progress: {
      percent: 1,
      message: 'processing...'
    }
  });
  return (0, _tasks.withTask)(stateWithProgress, (0, _tasks2.PROCESS_FILE_DATA)({
    content: content,
    fileCache: fileCache
  }).bimap(function (result) {
    return (0, _actions.loadFileStepSuccess)({
      fileName: content.fileName,
      fileCache: result
    });
  }, function (err) {
    return (0, _actions.loadFilesErr)(content.fileName, err);
  }));
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function parseProgress() {
  var prevProgress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var progress = arguments.length > 1 ? arguments[1] : undefined;
  // This happens when receiving query metadata or other cases we don't
  // have an update for the user.
  if (!progress || !progress.percent) {
    return {};
  }
  return {
    percent: progress.percent
  };
}

/**
 * gets called with payload = AsyncGenerator<???>
 * @memberof visStateUpdaters
 * @public
 */
var nextFileBatchUpdater = exports.nextFileBatchUpdater = function nextFileBatchUpdater(state, _ref18) {
  var _accumulated$data;
  var _ref18$payload = _ref18.payload,
    gen = _ref18$payload.gen,
    fileName = _ref18$payload.fileName,
    progress = _ref18$payload.progress,
    accumulated = _ref18$payload.accumulated,
    onFinish = _ref18$payload.onFinish;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: parseProgress(state.fileLoadingProgress[fileName], progress)
  });
  return (0, _tasks.withTask)(stateWithProgress, [].concat((0, _toConsumableArray2["default"])((0, _utils.getApplicationConfig)().useArrowProgressiveLoading && fileName.endsWith('arrow') && (accumulated === null || accumulated === void 0 || (_accumulated$data = accumulated.data) === null || _accumulated$data === void 0 ? void 0 : _accumulated$data.length) > 0 ? [(0, _tasks2.PROCESS_FILE_DATA)({
    content: accumulated,
    fileCache: []
  }).bimap(function (result) {
    return (0, _actions.loadFilesSuccess)(result);
  }, function (err) {
    return (0, _actions.loadFilesErr)(fileName, err);
  })] : []), [(0, _tasks2.UNWRAP_TASK)(gen.next()).bimap(function (_ref19) {
    var value = _ref19.value,
      done = _ref19.done;
    return done ? onFinish(accumulated) : (0, _actions.nextFileBatch)({
      gen: gen,
      fileName: fileName,
      progress: value.progress,
      accumulated: value,
      onFinish: onFinish
    });
  }, function (err) {
    return (0, _actions.loadFilesErr)(fileName, err);
  })]));
};

/**
 * Trigger loading file error
 * @memberof visStateUpdaters
 * @public
 */
var loadFilesErrUpdater = exports.loadFilesErrUpdater = function loadFilesErrUpdater(state, _ref20) {
  var error = _ref20.error,
    fileName = _ref20.fileName;
  // update ui with error message
  _window.console.warn(error);
  if (!state.fileLoading) {
    return state;
  }
  var _state$fileLoading2 = state.fileLoading,
    filesToLoad = _state$fileLoading2.filesToLoad,
    onFinish = _state$fileLoading2.onFinish,
    fileCache = _state$fileLoading2.fileCache;
  var nextState = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: {
      error: error
    }
  });

  // kick off next file or finish
  return (0, _tasks.withTask)(nextState, (0, _tasks2.DELAY_TASK)(200).map(filesToLoad.length ? _actions.loadNextFile : function () {
    return onFinish(fileCache);
  }));
};

/**
 * When select dataset for export, apply cpu filter to selected dataset
 * @memberof visStateUpdaters
 * @public
 */
var applyCPUFilterUpdater = exports.applyCPUFilterUpdater = function applyCPUFilterUpdater(state, _ref21) {
  var dataId = _ref21.dataId;
  // apply cpuFilter
  var dataIds = (0, _commonUtils.toArray)(dataId);
  return dataIds.reduce(function (accu, id) {
    return (0, _utils.filterDatasetCPU)(accu, id);
  }, state);
};

/**
 * User input to update the info of the map
 * @memberof visStateUpdaters
 * @public
 */
var setMapInfoUpdater = exports.setMapInfoUpdater = function setMapInfoUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    mapInfo: _objectSpread(_objectSpread({}, state.mapInfo), action.info)
  });
};
/**
 * Helper function to update All layer domain and layer data of state
 */
function addDefaultLayers(state, datasets) {
  var empty = [];
  var defaultLayers = Object.values(datasets).reduce(function (accu, dataset) {
    var foundLayers = (0, _layerUtils.findDefaultLayer)(dataset, state.layerClasses);
    return foundLayers && foundLayers.length ? accu.concat(foundLayers) : accu;
  }, empty);
  return {
    state: _objectSpread(_objectSpread({}, state), {}, {
      layers: [].concat((0, _toConsumableArray2["default"])(state.layers), (0, _toConsumableArray2["default"])(defaultLayers)),
      layerOrder: [].concat((0, _toConsumableArray2["default"])((0, _layerUtils.getLayerOrderFromLayers)(defaultLayers)), (0, _toConsumableArray2["default"])(state.layerOrder))
    }),
    newLayers: defaultLayers
  };
}

/**
 * helper function to find default tooltips
 * @param {Object} state
 * @param {Object} dataset
 * @returns {Object} nextState
 */
function addDefaultTooltips(state, dataset) {
  var tooltipFields = (0, _interactionUtils.findFieldsToShow)(_objectSpread(_objectSpread({}, dataset), {}, {
    maxDefaultTooltips: state.maxDefaultTooltips
  }));
  var merged = _objectSpread(_objectSpread({}, state.interactionConfig.tooltip.config.fieldsToShow), tooltipFields);
  return (0, _utils.set)(['interactionConfig', 'tooltip', 'config', 'fieldsToShow'], merged, state);
}
function initialFileLoadingProgress(file, index) {
  var fileName = file.name || "Untitled File ".concat(index);
  return (0, _defineProperty2["default"])({}, fileName, {
    // percent of current file
    percent: 0,
    message: '',
    fileName: fileName,
    error: null
  });
}
function updateFileLoadingProgressUpdater(state, _ref23) {
  var fileName = _ref23.fileName,
    progress = _ref23.progress;
  // @ts-expect-error
  return (0, _composerHelpers.pick_)('fileLoadingProgress')((0, _composerHelpers.pick_)(fileName)((0, _composerHelpers.merge_)(progress)))(state);
}
/**
 * Helper function to update layer domains for an array of datasets
 */
function updateAllLayerDomainData(state, dataId, updatedFilter) {
  var dataIds = typeof dataId === 'string' ? [dataId] : dataId;
  var newLayers = [];
  var newLayerData = [];
  state.layers.forEach(function (oldLayer, i) {
    if (oldLayer.config.dataId && dataIds.includes(oldLayer.config.dataId)) {
      // No need to recalculate layer domain if filter has fixed domain
      var newLayer = updatedFilter && updatedFilter.fixedDomain ? oldLayer : oldLayer.updateLayerDomain(state.datasets, updatedFilter);
      var _calculateLayerData7 = (0, _layerUtils.calculateLayerData)(newLayer, state, state.layerData[i]),
        layerData = _calculateLayerData7.layerData,
        layer = _calculateLayerData7.layer;
      newLayers.push(layer);
      newLayerData.push(layerData);
    } else {
      newLayers.push(oldLayer);
      newLayerData.push(state.layerData[i]);
    }
  });
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    layerData: newLayerData
  });
  return newState;
}
function updateAnimationDomain(state) {
  var _state$filters;
  // merge all animatable layer domain and update global config
  var animatableLayers = (0, _utils.getAnimatableVisibleLayers)(state.layers);
  if (!animatableLayers.length) {
    return _objectSpread(_objectSpread({}, state), {}, {
      animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
        domain: null,
        isAnimating: false,
        timeSteps: null,
        defaultTimeFormat: null
      })
    });
  }
  var layerDomains = animatableLayers.map(function (l) {
    return l.config.animation.domain || [];
  });
  // @ts-ignore
  var mergedDomain = (0, _utils.mergeTimeDomains)(layerDomains);
  var defaultTimeFormat = (0, _utils.getTimeWidgetTitleFormatter)(mergedDomain);

  // merge timeSteps
  var mergedTimeSteps = (0, _uniq["default"])(animatableLayers.reduce(function (accu, layer) {
    accu.push.apply(accu, (0, _toConsumableArray2["default"])(layer.config.animation.timeSteps || []));
    return accu;
  }, [])).sort();
  mergedTimeSteps = mergedTimeSteps.length ? mergedTimeSteps : null;

  // TODO: better handling of duration calculation
  var duration = mergedTimeSteps ? _constants.BASE_SPEED * (1000 / _constants.FPS) / mergedTimeSteps.length / (state.animationConfig.speed || 1) : null;
  var nextState = _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      domain: mergedDomain,
      defaultTimeFormat: defaultTimeFormat,
      duration: duration,
      timeSteps: mergedTimeSteps
    })
  });

  // reset currentTime based on new domain
  var syncedFilter = (_state$filters = state.filters) === null || _state$filters === void 0 ? void 0 : _state$filters.find(function (f) {
    return f.syncedWithLayerTimeline;
  });

  // if synced filter exist wee need to merge animationConfig and filter domains
  // and validate the current time against the new merged domain
  var newAnimationDomain = syncedFilter ? (0, _utils.mergeTimeDomains)([mergedDomain, syncedFilter.domain]) : mergedDomain;
  var currentTime = (0, _utils.isInRange)(state.animationConfig.currentTime, newAnimationDomain) ? state.animationConfig.currentTime : newAnimationDomain[0];
  if (currentTime !== state.animationConfig.currentTime) {
    // if currentTime changed, need to call animationTimeUpdater to re call formatLayerData
    return setLayerAnimationTimeUpdater(nextState, {
      value: currentTime
    });
  }
  return nextState;
}

/**
 * Update the status of the editor
 * @memberof visStateUpdaters
 */
var setEditorModeUpdater = exports.setEditorModeUpdater = function setEditorModeUpdater(state, _ref24) {
  var mode = _ref24.mode;
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      mode: mode,
      selectedFeature: null
    })
  });
};

// const featureToFilterValue = (feature) => ({...feature, id: feature.id});
/**
 * Update editor features
 * @memberof visStateUpdaters
 */
function setFeaturesUpdater(state, _ref25) {
  var _lastFeature$properti;
  var _ref25$features = _ref25.features,
    features = _ref25$features === void 0 ? [] : _ref25$features;
  var lastFeature = features.length && features[features.length - 1];
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      // only save none filter features to editor
      features: features.filter(function (f) {
        return !(0, _utils.getFilterIdInFeature)(f);
      }),
      mode: lastFeature && (_lastFeature$properti = lastFeature.properties) !== null && _lastFeature$properti !== void 0 && _lastFeature$properti.isClosed ? _constants.EDITOR_MODES.EDIT : state.editor.mode
    })
  });

  // Retrieve existing feature
  var selectedFeature = state.editor.selectedFeature;

  // If no feature is selected we can simply return since no operations
  if (!selectedFeature) {
    return newState;
  }

  // TODO: check if the feature has changed
  var feature = features.find(function (f) {
    return f.id === selectedFeature.id;
  });

  // if feature is part of a filter
  var filterId = feature && (0, _utils.getFilterIdInFeature)(feature);
  if (filterId && feature) {
    // add bbox for polygon filter to speed up filtering
    if (feature.properties) feature.properties.bbox = (0, _bbox["default"])(feature);
    var featureValue = (0, _utils.featureToFilterValue)(feature, filterId);
    var filterIdx = state.filters.findIndex(function (fil) {
      return fil.id === filterId;
    });
    // @ts-ignore
    return setFilterUpdater(newState, {
      idx: filterIdx,
      prop: 'value',
      value: featureValue
    });
  }
  return newState;
}

/**
 * Set the current selected feature
 * @memberof uiStateUpdaters
 */
var setSelectedFeatureUpdater = exports.setSelectedFeatureUpdater = function setSelectedFeatureUpdater(state, _ref26) {
  var feature = _ref26.feature,
    selectionContext = _ref26.selectionContext;
  // add bbox for polygon filter to speed up filtering
  var selectedFeature = feature;
  if (feature !== null && feature !== void 0 && feature.properties) {
    selectedFeature = _objectSpread(_objectSpread({}, feature), {}, {
      properties: _objectSpread(_objectSpread({}, feature.properties), {}, {
        bbox: (0, _bbox["default"])(feature)
      })
    });
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      selectedFeature: selectedFeature,
      selectionContext: selectionContext
    })
  });
};

/**
 * Delete existing feature from filters
 * @memberof visStateUpdaters
 */
function deleteFeatureUpdater(state, _ref27) {
  var feature = _ref27.feature;
  if (!feature) {
    return state;
  }
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      selectedFeature: null
    })
  });
  if ((0, _utils.getFilterIdInFeature)(feature)) {
    var filterIdx = newState.filters.findIndex(function (f) {
      return f.id === (0, _utils.getFilterIdInFeature)(feature);
    });
    return filterIdx > -1 ? removeFilterUpdater(newState, {
      idx: filterIdx
    }) : newState;
  }

  // modify editor object
  var newEditor = _objectSpread(_objectSpread({}, state.editor), {}, {
    features: state.editor.features.filter(function (f) {
      return f.id !== feature.id;
    }),
    selectedFeature: null
  });
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: newEditor
  });
}

/**
 * Toggle feature as layer filter
 * @memberof visStateUpdaters
 */
function setPolygonFilterLayerUpdater(state, payload) {
  var layer = payload.layer,
    feature = payload.feature;
  var filterId = (0, _utils.getFilterIdInFeature)(feature);

  // let newFilter = null;
  var filterIdx;
  var newLayerId = [layer.id];
  var newState = state;
  // If polygon filter already exists, we need to find out if the current layer is already included
  if (filterId) {
    filterIdx = state.filters.findIndex(function (f) {
      return f.id === filterId;
    });
    if (!state.filters[filterIdx]) {
      // what if filter doesn't exist?... not possible.
      // because features in the editor is passed in from filters and editors.
      // but we will move this feature back to editor just in case
      var noneFilterFeature = _objectSpread(_objectSpread({}, feature), {}, {
        properties: _objectSpread(_objectSpread({}, feature.properties), {}, {
          filterId: null
        })
      });
      return _objectSpread(_objectSpread({}, state), {}, {
        editor: _objectSpread(_objectSpread({}, state.editor), {}, {
          features: [].concat((0, _toConsumableArray2["default"])(state.editor.features), [noneFilterFeature]),
          selectedFeature: noneFilterFeature
        })
      });
    }
    var filter = state.filters[filterIdx];
    var _filter$layerId = filter.layerId,
      layerId = _filter$layerId === void 0 ? [] : _filter$layerId;
    var isLayerIncluded = layerId.includes(layer.id);
    newLayerId = isLayerIncluded ?
    // if layer is included, remove it
    layerId.filter(function (l) {
      return l !== layer.id;
    }) : [].concat((0, _toConsumableArray2["default"])(layerId), [layer.id]);
  } else {
    // if we haven't create the polygon filter, create it
    var newFilter = (0, _utils.generatePolygonFilter)([], feature);
    filterIdx = state.filters.length;

    // add feature, remove feature from eidtor
    newState = _objectSpread(_objectSpread({}, state), {}, {
      filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [newFilter]),
      editor: _objectSpread(_objectSpread({}, state.editor), {}, {
        features: state.editor.features.filter(function (f) {
          return f.id !== feature.id;
        }),
        selectedFeature: newFilter.value
      })
    });
  }
  return setFilterUpdater(newState, {
    idx: filterIdx,
    prop: 'layerId',
    value: newLayerId
  });
}

/**
 * @memberof visStateUpdaters
 * @public
 */
function sortTableColumnUpdater(state, _ref28) {
  var dataId = _ref28.dataId,
    column = _ref28.column,
    mode = _ref28.mode;
  var dataset = state.datasets[dataId];
  if (!dataset) {
    return state;
  }
  var sortMode = mode;
  if (!sortMode) {
    var currentMode = (0, _get["default"])(dataset, ['sortColumn', column]);
    // @ts-ignore - should be fixable in a TS file
    sortMode = currentMode ? Object.keys(_constants.SORT_ORDER).find(function (m) {
      return m !== currentMode;
    }) : _constants.SORT_ORDER.ASCENDING;
  }
  var sorted = (0, _table.sortDatasetByColumn)(dataset, column, sortMode);
  return (0, _utils.set)(['datasets', dataId], sorted, state);
}

/**
 * @memberof visStateUpdaters
 * @public
 */
function pinTableColumnUpdater(state, _ref29) {
  var dataId = _ref29.dataId,
    column = _ref29.column;
  var dataset = state.datasets[dataId];
  if (!dataset) {
    return state;
  }
  var newDataset = (0, _table.pinTableColumns)(dataset, column);
  return (0, _utils.set)(['datasets', dataId], newDataset, state);
}

/**
 * Copy column content as strings
 * @memberof visStateUpdaters
 * @public
 */
function copyTableColumnUpdater(state, _ref30) {
  var dataId = _ref30.dataId,
    column = _ref30.column;
  var dataset = state.datasets[dataId];
  if (!dataset) {
    return state;
  }
  var fieldIdx = dataset.fields.findIndex(function (f) {
    return f.name === column;
  });
  if (fieldIdx < 0) {
    return state;
  }
  var type = dataset.fields[fieldIdx].type;
  var text = dataset.dataContainer.map(function (row) {
    return (0, _utils.parseFieldValue)(row.valueAt(fieldIdx), type);
  }, true).join('\n');
  (0, _copyToClipboard["default"])(text);
  return state;
}

/**
 * Set display format from columns from user selection
 * @memberof visStateUpdaters
 * @public
 */
function setColumnDisplayFormatUpdater(state, _ref31) {
  var dataId = _ref31.dataId,
    formats = _ref31.formats;
  var dataset = state.datasets[dataId];
  if (!dataset) {
    return state;
  }
  var newFields = dataset.fields;
  Object.keys(formats).forEach(function (column) {
    var fieldIdx = dataset.fields.findIndex(function (f) {
      return f.name === column;
    });
    if (fieldIdx >= 0) {
      var displayFormat = formats[column];
      var field = newFields[fieldIdx];
      newFields = (0, _composerHelpers.swap_)((0, _composerHelpers.merge_)({
        displayFormat: displayFormat
      })(field))(newFields);
    }
  });
  var newDataset = (0, _table.copyTableAndUpdate)(dataset, {
    fields: newFields
  });
  var newState = (0, _composerHelpers.pick_)('datasets')((0, _composerHelpers.merge_)((0, _defineProperty2["default"])({}, dataId, newDataset)))(state);

  // update colorField displayFormat
  newState = _objectSpread(_objectSpread({}, newState), {}, {
    layers: newState.layers.map(function (layer) {
      var _layer$config;
      return (_layer$config = layer.config) !== null && _layer$config !== void 0 && (_layer$config = _layer$config.colorField) !== null && _layer$config !== void 0 && _layer$config.name && layer.config.colorField.name in formats ? layer.updateLayerConfig({
        colorField: _objectSpread(_objectSpread({}, layer.config.colorField), {}, {
          displayFormat: formats[layer.config.colorField.name]
        })
      }) : layer;
    })
  });
  return newState;
}

/**
 * Update editor
 */
function toggleEditorVisibilityUpdater(state,
// eslint-disable-next-line @typescript-eslint/no-unused-vars
action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      visible: !state.editor.visible
    })
  });
}
function setFilterAnimationTimeConfigUpdater(state, _ref32) {
  var idx = _ref32.idx,
    config = _ref32.config;
  var oldFilter = state.filters[idx];
  if (!oldFilter) {
    _window.console.error("filters.".concat(idx, " is undefined"));
    return state;
  }
  if (oldFilter.type !== _constants.FILTER_TYPES.timeRange) {
    _window.console.error("setFilterAnimationTimeConfig can only be called to update a time filter. check filter.type === 'timeRange'");
    return state;
  }
  var updates = checkTimeConfigArgs(config);
  return (0, _composerHelpers.pick_)('filters')((0, _composerHelpers.swap_)((0, _composerHelpers.merge_)(updates)(oldFilter)))(state);
}
function checkTimeConfigArgs(config) {
  var allowed = ['timeFormat', 'timezone'];
  return Object.keys(config).reduce(function (accu, prop) {
    if (!allowed.includes(prop)) {
      _window.console.error("setLayerAnimationTimeConfig takes timeFormat and/or timezone as options, found ".concat(prop));
      return accu;
    }

    // here we are NOT checking if timezone or timeFormat input is valid
    accu[prop] = config[prop];
    return accu;
  }, {});
}

/**
 * Update editor
 */
function setLayerAnimationTimeConfigUpdater(state, _ref33) {
  var config = _ref33.config;
  if (!config) {
    return state;
  }
  var updates = checkTimeConfigArgs(config);
  return (0, _composerHelpers.pick_)('animationConfig')((0, _composerHelpers.merge_)(updates))(state);
}

/**
 * Update editor
 */
function layerFilteredItemsChangeUpdater(state, action) {
  var _layer$filteredItemCo;
  var event = action.event,
    layer = action.layer;
  var deckglLayerId = event.id,
    count = event.count;
  if (!layer) {
    _window.console.warn("layerFilteredItems layer doesnt exists");
    return state;
  }
  if (((_layer$filteredItemCo = layer.filteredItemCount) === null || _layer$filteredItemCo === void 0 ? void 0 : _layer$filteredItemCo[deckglLayerId]) === count) {
    return state;
  }
  layer.filteredItemCount = _objectSpread(_objectSpread({}, layer.filteredItemCount), {}, (0, _defineProperty2["default"])({}, deckglLayerId, count));
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: (0, _composerHelpers.swap_)(layer)(state.layers)
  });
}

// eslint-disable-next-line max-statements
function syncTimeFilterWithLayerTimelineUpdater(state, action) {
  var _newState$animationCo, _newState$animationCo2;
  var filterIdx = action.idx,
    _action$enable = action.enable,
    enable = _action$enable === void 0 ? false : _action$enable;
  var filter = state.filters[filterIdx];
  var newState = state;
  var newFilter = filter;

  // if we enable sync we are going to merge filter and animationConfig domains and store into filter.domain
  if (enable) {
    var animatableLayers = (0, _utils.getAnimatableVisibleLayers)(newState.layers);
    // if no animatableLayers are present we simply return
    if (!animatableLayers.length) {
      return newState;
    }
    var intervalBasedAnimationLayers = (0, _utils.getIntervalBasedAnimationLayers)(animatableLayers);
    var hasIntervalBasedAnimationLayer = Boolean(intervalBasedAnimationLayers.length);
    var newFilterDomain = (0, _utils.mergeTimeDomains)([filter.domain, newState.animationConfig.domain]);

    // we only update animationWindow if we have interval based animation layers with defined intervals and the current filter animation window is not interval
    if (hasIntervalBasedAnimationLayer) {
      if (filter.animationWindow !== _constants.ANIMATION_WINDOW.interval) {
        newState = setFilterAnimationWindowUpdater(newState, {
          id: filter.id,
          animationWindow: _constants.ANIMATION_WINDOW.interval
        });
      }
      newFilter = newState.filters[filterIdx];

      // adjust time filter interval
      newFilter = adjustTimeFilterInterval(newState, newFilter);

      // replace filter in state with newFilter
      newState = _objectSpread(_objectSpread({}, newState), {}, {
        filters: (0, _composerHelpers.swap_)(newFilter)(newState.filters)
      });
    }
    newFilter = newState.filters[filterIdx];

    // adjust value based on new domain
    var _newFilterValue = (0, _utils.adjustValueToFilterDomain)(newFilter.animationWindow === _constants.ANIMATION_WINDOW.interval ? [newFilterDomain[0], newFilterDomain[0]] : newFilterDomain, _objectSpread(_objectSpread({}, newFilter), {}, {
      domain: newFilterDomain
    }));
    newState = setFilterUpdater(newState, {
      idx: filterIdx,
      prop: 'value',
      value: _newFilterValue
    });
    newFilter = _objectSpread(_objectSpread({}, newState.filters[filterIdx]), {}, {
      syncedWithLayerTimeline: true
    });

    // replace filter in state with newFilter
    newState = _objectSpread(_objectSpread({}, newState), {}, {
      filters: (0, _composerHelpers.swap_)(newFilter)(newState.filters)
    });
    newState = setTimeFilterTimelineModeUpdater(newState, {
      id: newFilter.id,
      mode: getSyncAnimationMode(newFilter)
    });
    newFilter = newState.filters[filterIdx];

    // set the animation config value to match filter value
    return setLayerAnimationTimeUpdater(newState, {
      value: newFilter.value[newFilter.syncTimelineMode]
    });
  }

  // set domain and step
  newFilter = _objectSpread(_objectSpread({}, filter), {}, {
    syncedWithLayerTimeline: false
  });

  // replace filter in state with newFilter
  newState = _objectSpread(_objectSpread({}, newState), {}, {
    filters: (0, _composerHelpers.swap_)(newFilter)(newState.filters)
  });

  // reset sync timeline mode
  newState = setTimeFilterTimelineModeUpdater(newState, {
    id: newFilter.id,
    mode: _constants.SYNC_TIMELINE_MODES.end
  });
  newFilter = newState.filters[filterIdx];

  // reset filter value
  var newFilterValue = (0, _utils.adjustValueToFilterDomain)(newFilter.domain, newFilter);
  newState = setFilterUpdater(newState, {
    idx: filterIdx,
    prop: 'value',
    value: newFilterValue
  });
  newState = setTimeFilterTimelineModeUpdater(newState, {
    id: newFilter.id,
    mode: getSyncAnimationMode(newFilter)
  });

  // reset animation config current time to
  return setLayerAnimationTimeUpdater(newState, {
    value: (_newState$animationCo = (_newState$animationCo2 = newState.animationConfig.domain) === null || _newState$animationCo2 === void 0 ? void 0 : _newState$animationCo2[0]) !== null && _newState$animationCo !== void 0 ? _newState$animationCo : null
  });
}
function setTimeFilterTimelineModeUpdater(state, action) {
  var filterId = action.id,
    syncTimelineMode = action.mode;
  var filterIdx = state.filters.findIndex(function (f) {
    return f.id === filterId;
  });
  if (filterIdx === -1) {
    return state;
  }
  var filter = state.filters[filterIdx];
  if (!validateSyncAnimationMode(filter, syncTimelineMode)) {
    return state;
  }
  var newFilter = _objectSpread(_objectSpread({}, filter), {}, {
    syncTimelineMode: syncTimelineMode
  });
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    filters: (0, _composerHelpers.swap_)(newFilter)(state.filters)
  });
  return adjustAnimationConfigWithFilter(newState, filterIdx);
}

/**
 * Update state of the loading indicator.
 * @memberof visStateUpdaters
 * @param state visState
 * @param action
 * @param action.payload Payload with change of number of active loading actions.
 * @returns nextState
 * @public
 */
var setLoadingIndicatorUpdater = exports.setLoadingIndicatorUpdater = function setLoadingIndicatorUpdater(state, _ref34) {
  var change = _ref34.payload.change;
  var loadingIndicatorValue = state.loadingIndicatorValue;
  if (!loadingIndicatorValue) {
    loadingIndicatorValue = 0;
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    loadingIndicatorValue: Math.max(loadingIndicatorValue + change, 0)
  });
};
function adjustAnimationConfigWithFilter(state, filterIdx) {
  var filter = state.filters[filterIdx];
  if (filter.syncedWithLayerTimeline) {
    var timelineValue = getTimelineValueFromFilter(filter);
    var value = state.animationConfig.timeSteps ? (0, _utils.snapToMarks)(timelineValue, state.animationConfig.timeSteps) : timelineValue;
    return setLayerAnimationTimeUpdater(state, {
      value: value
    });
  }
  return state;
}
function getTimelineValueFromFilter(filter) {
  return filter.value[filter.syncTimelineMode];
}
function getSyncAnimationMode(filter) {
  if (filter.animationWindow === _constants.ANIMATION_WINDOW.free) {
    var _filter$syncTimelineM;
    return (_filter$syncTimelineM = filter.syncTimelineMode) !== null && _filter$syncTimelineM !== void 0 ? _filter$syncTimelineM : _constants.SYNC_TIMELINE_MODES.end;
  }
  return _constants.SYNC_TIMELINE_MODES.end;
}
function validateSyncAnimationMode(filter, newMode) {
  return !(filter.animationWindow !== _constants.ANIMATION_WINDOW.free && newMode === _constants.SYNC_TIMELINE_MODES.start);
}
function adjustTimeFilterInterval(state, filter) {
  var intervalBasedAnimationLayers = (0, _utils.getIntervalBasedAnimationLayers)(state.layers);
  var interval = null;
  if (intervalBasedAnimationLayers.length > 0) {
    // @ts-ignore
    var intervalIndex = intervalBasedAnimationLayers.reduce(function (currentIndex, l) {
      if (l.meta.targetTimeInterval) {
        var newIndex = _utils.TIME_INTERVALS_ORDERED.findIndex(function (i) {
          return i === l.meta.targetTimeInterval;
        });
        return newIndex > -1 && newIndex < currentIndex ? newIndex : currentIndex;
      }
    }, _utils.TIME_INTERVALS_ORDERED.length - 1);
    // @ts-ignore
    var hexTileInterval = _utils.TIME_INTERVALS_ORDERED[intervalIndex];
    interval = _utils.LayerToFilterTimeInterval[hexTileInterval];
  }
  if (!interval) {
    return filter;
  }

  // adjust filter
  var timeFormat = (0, _utils.getDefaultTimeFormat)(interval);
  var updatedPlotType = _objectSpread(_objectSpread({}, filter.plotType), {}, {
    interval: interval,
    timeFormat: timeFormat
  });
  var newFilter = (0, _utils.updateTimeFilterPlotType)(filter, updatedPlotType, state.datasets);
  return (0, _utils.adjustValueToAnimationWindow)(state, newFilter);
}

// Find dataId from a saved visState property:
// layers, filters, interactions, layerBlending, overlayBlending, splitMaps, animationConfig, editor
// replace it with another dataId
function defaultReplaceParentDatasetIds(value, dataId, dataIdToReplace) {
  var _value$config, _value$config2;
  if (Array.isArray(value)) {
    // for layers, filters, call defaultReplaceParentDatasetIds on each item in array
    var replaced = value.map(function (v) {
      return defaultReplaceParentDatasetIds(v, dataId, dataIdToReplace);
    }).filter(function (d) {
      return d;
    });
    return replaced.length ? replaced : null;
  }
  if (typeof value.dataId === 'string' && value.dataId === dataId) {
    // others
    return _objectSpread(_objectSpread({}, value), {}, {
      dataId: dataIdToReplace
    });
  } else if (Array.isArray(value.dataId) && value.dataId.includes(dataId)) {
    // filter
    return _objectSpread(_objectSpread({}, value), {}, {
      dataId: value.dataId.map(function (d) {
        return d === dataId ? dataIdToReplace : d;
      })
    });
  } else if ((_value$config = value.config) !== null && _value$config !== void 0 && _value$config.dataId && ((_value$config2 = value.config) === null || _value$config2 === void 0 ? void 0 : _value$config2.dataId) === dataId) {
    // layer
    return _objectSpread(_objectSpread({}, value), {}, {
      config: _objectSpread(_objectSpread({}, value.config), {}, {
        dataId: dataIdToReplace
      })
    });
  } else if ((0, _utils.isObject)(value) && Object.prototype.hasOwnProperty.call(value, dataId)) {
    // for value saved as {[dataId]: {...}}
    return (0, _defineProperty2["default"])({}, dataIdToReplace, value[dataId]);
  }
  return null;
}

// Find datasetIds derived a saved visState Property;
function findChildDatasetIds(value) {
  var _value$newDataset;
  if (Array.isArray(value)) {
    // for layers, filters, call defaultReplaceParentDatasetIds on each item in array
    var childDataIds = value.map(findChildDatasetIds).filter(function (d) {
      return d;
    });
    return childDataIds.length ? childDataIds : null;
  }

  // child data id usually stores in the derived dataset info
  return (value === null || value === void 0 || (_value$newDataset = value.newDataset) === null || _value$newDataset === void 0 ? void 0 : _value$newDataset.info.id) || null;
}

// moved unmerged layers, filters, interactions
function moveValueToBeMerged(state, propValues, _ref36) {
  var prop = _ref36.prop,
    toMergeProp = _ref36.toMergeProp,
    saveUnmerged = _ref36.saveUnmerged;
  // remove prop value from state
  // TODO: should we add remove updater to merger as well?
  if (!propValues) {
    return state;
  }
  var stateRemoved = prop === 'layers' ? propValues.reduce(function (accu, propValue) {
    return removeLayerUpdater(accu, {
      id: propValue.id
    });
  }, state) : Array.isArray(state[prop]) ? _objectSpread(_objectSpread({}, state), {}, (0, _defineProperty2["default"])({}, prop, state[prop].filter(function (p) {
    return !propValues.find(function (propValue) {
      return p.id === propValue.id;
    });
  }))) :
  // if not array, we won't remove it, remove dataset should handle it
  state;

  // move to stateToBeMerged
  var toBeMerged = (0, _defineProperty2["default"])({}, toMergeProp, saveUnmerged ?
  // call merge saveUnmerged method
  saveUnmerged(stateRemoved, propValues) :
  // if toMergeProp is araay, append to it
  Array.isArray(stateRemoved[toMergeProp]) ? [].concat((0, _toConsumableArray2["default"])(stateRemoved[toMergeProp]), (0, _toConsumableArray2["default"])(propValues)) :
  // save propValues to toMerge
  (0, _utils.isObject)(stateRemoved[toMergeProp]) ? _objectSpread(_objectSpread({}, stateRemoved[toMergeProp]), propValues) : stateRemoved[toMergeProp]);
  return _objectSpread(_objectSpread({}, stateRemoved), toBeMerged);
}
function replaceDatasetAndDeps(state, dataId, dataIdToUse) {
  return (0, _composerHelpers.compose_)([(0, _composerHelpers.apply_)(replaceDatasetDepsInState, {
    dataId: dataId,
    dataIdToUse: dataIdToUse
  }), (0, _composerHelpers.apply_)(removeDatasetUpdater, {
    dataId: dataId
  })])(state);
}
function prepareStateForDatasetReplace(state, dataId, dataIdToUse) {
  var _nextState$layerToBeM;
  var serializedState = (0, _visStateMerger.serializeVisState)(state, state.schema);
  var nextState = replaceDatasetAndDeps(state, dataId, dataIdToUse);
  // make a copy of layerOrder, because layer id will be removed from it by calling removeLayerUpdater
  var preserveLayerOrder = (0, _toConsumableArray2["default"])(state.layerOrder);

  // preserve dataset order
  nextState.preserveDatasetOrder = Object.keys(state.datasets).map(function (d) {
    return d === dataId ? dataIdToUse : d;
  });

  // preserveLayerOrder
  if ((_nextState$layerToBeM = nextState.layerToBeMerged) !== null && _nextState$layerToBeM !== void 0 && _nextState$layerToBeM.length) {
    var _serializedState$spli;
    // copy split maps to be merged, because it will be reset in remove layer
    nextState.splitMapsToBeMerged = (_serializedState$spli = serializedState === null || serializedState === void 0 ? void 0 : serializedState.splitMaps) !== null && _serializedState$spli !== void 0 ? _serializedState$spli : [];
    nextState.layerOrder = (0, _toConsumableArray2["default"])(preserveLayerOrder);
  }
  return nextState;
}
function replaceDatasetDepsInState(state, _ref37) {
  var dataId = _ref37.dataId,
    dataIdToUse = _ref37.dataIdToUse;
  var serializedState = (0, _visStateMerger.serializeVisState)(state, state.schema);
  var nextState = state.mergers.reduce(function (accuState, _ref38) {
    var prop = _ref38.prop,
      toMergeProp = _ref38.toMergeProp,
      replaceParentDatasetIds = _ref38.replaceParentDatasetIds,
      getChildDatasetIds = _ref38.getChildDatasetIds,
      saveUnmerged = _ref38.saveUnmerged,
      preserveOrder = _ref38.preserveOrder;
    // get dataset ids that are depends on this dataset
    var props = (0, _commonUtils.toArray)(prop);
    var toMergeProps = (0, _commonUtils.toArray)(toMergeProp);
    var savedProps = serializedState ? props.map(function (p) {
      return serializedState[p];
    }) : [];
    var replacedState = accuState;
    savedProps.forEach(function (propValue, i) {
      var _replacedState$merger;
      var mergerOptions = {
        prop: props[i],
        toMergeProp: toMergeProps[i],
        getChildDatasetIds: getChildDatasetIds,
        saveUnmerged: saveUnmerged
      };
      var replacedItem = (replaceParentDatasetIds === null || replaceParentDatasetIds === void 0 ? void 0 : replaceParentDatasetIds(propValue, dataId, dataIdToUse)) || defaultReplaceParentDatasetIds(propValue, dataId, dataIdToUse);
      replacedState = replacedItem ? replacePropValueInState(replacedState, replacedItem, mergerOptions) : replacedState;
      if (mergerOptions.toMergeProp !== undefined && (_replacedState$merger = replacedState[mergerOptions.toMergeProp]) !== null && _replacedState$merger !== void 0 && _replacedState$merger.length && preserveOrder) {
        replacedState[preserveOrder] = propValue.map(function (item) {
          return item.id;
        });
      }
    });
    return replacedState;
  }, state);
  return nextState;
}
function replacePropValueInState(state, replacedItem, _ref39) {
  var prop = _ref39.prop,
    toMergeProp = _ref39.toMergeProp,
    getChildDatasetIds = _ref39.getChildDatasetIds,
    saveUnmerged = _ref39.saveUnmerged;
  // prop is depends on the dataset to be replaced
  // remove prop from state, and move it to toBeMerged
  var nextState = moveValueToBeMerged(state, replacedItem, {
    prop: prop,
    toMergeProp: toMergeProp,
    saveUnmerged: saveUnmerged
  });
  var childDataIds = (getChildDatasetIds === null || getChildDatasetIds === void 0 ? void 0 : getChildDatasetIds(replacedItem)) || findChildDatasetIds(replacedItem);
  if (childDataIds) {
    nextState = (0, _commonUtils.toArray)(childDataIds).reduce(function (accu, childDataId) {
      // shouldn't need to change child dataset id,
      // but still need to move out of state and merge back in
      return replaceDatasetAndDeps(accu, childDataId, childDataId);
    }, nextState);
  }
  return nextState;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfYmJveCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2NvcHlUb0NsaXBib2FyZCIsIl9kZWVwbWVyZ2UiLCJfd2luZG93IiwiX2Nsb25lRGVlcCIsIl9nZXQiLCJfaXNFcXVhbCIsIl9waWNrIiwiX3VuaXEiLCJfeG9yIiwiX3Rhc2tzIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfdGFza3MyIiwiX2FjdGlvbnMiLCJfdXRpbHMiLCJfY29tbW9uVXRpbHMiLCJfY29uc3RhbnRzIiwiX2xheWVycyIsIl9jb21wb3NlckhlbHBlcnMiLCJfbWVyZ2VySGFuZGxlciIsIl92aXNTdGF0ZU1lcmdlciIsIl9zY2hlbWFzIiwiX3RhYmxlIiwiX2ludGVyYWN0aW9uVXRpbHMiLCJfbGF5ZXJVdGlscyIsIl9lZmZlY3RzIiwiX2RhdGFVdGlscyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJfdG9Qcm9wZXJ0eUtleSIsIl90b1ByaW1pdGl2ZSIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJpdGVyYXRvciIsIkFycmF5IiwiaXNBcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsImxlbmd0aCIsIl9uIiwiRiIsInMiLCJkb25lIiwidmFsdWUiLCJmIiwibyIsIm5leHQiLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJmcm9tIiwidGVzdCIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5MiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGlzYWJsZVN0YWNrQ2FwdHVyaW5nIiwidmlzU3RhdGVVcGRhdGVycyIsImRlZmF1bHRJbnRlcmFjdGlvbkNvbmZpZyIsImV4cG9ydHMiLCJ0b29sdGlwIiwiaWQiLCJsYWJlbCIsImVuYWJsZWQiLCJjb25maWciLCJmaWVsZHNUb1Nob3ciLCJjb21wYXJlTW9kZSIsImNvbXBhcmVUeXBlIiwiQ09NUEFSRV9UWVBFUyIsIkFCU09MVVRFIiwiZ2VvY29kZXIiLCJwb3NpdGlvbiIsImJydXNoIiwic2l6ZSIsImNvb3JkaW5hdGUiLCJERUZBVUxUX0FOSU1BVElPTl9DT05GSUciLCJkb21haW4iLCJjdXJyZW50VGltZSIsInNwZWVkIiwiaXNBbmltYXRpbmciLCJ0aW1lU3RlcHMiLCJ0aW1lRm9ybWF0IiwidGltZXpvbmUiLCJkZWZhdWx0VGltZUZvcm1hdCIsImhpZGVDb250cm9sIiwiZHVyYXRpb24iLCJERUZBVUxUX0VESVRPUiIsIm1vZGUiLCJFRElUT1JfTU9ERVMiLCJEUkFXX1BPTFlHT04iLCJmZWF0dXJlcyIsInNlbGVjdGVkRmVhdHVyZSIsInZpc2libGUiLCJJTklUSUFMX1ZJU19TVEFURSIsIm1hcEluZm8iLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwibGF5ZXJzIiwibGF5ZXJEYXRhIiwibGF5ZXJUb0JlTWVyZ2VkIiwibGF5ZXJPcmRlciIsImZpbHRlcnMiLCJmaWx0ZXJUb0JlTWVyZ2VkIiwiZGF0YXNldHMiLCJlZGl0aW5nRGF0YXNldCIsInVuZGVmaW5lZCIsImVmZmVjdHMiLCJlZmZlY3RPcmRlciIsImludGVyYWN0aW9uQ29uZmlnIiwiaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkIiwibGF5ZXJCbGVuZGluZyIsIm92ZXJsYXlCbGVuZGluZyIsImhvdmVySW5mbyIsImNsaWNrZWQiLCJtb3VzZVBvcyIsIm1heERlZmF1bHRUb29sdGlwcyIsIk1BWF9ERUZBVUxUX1RPT0xUSVBTIiwic3BsaXRNYXBzIiwic3BsaXRNYXBzVG9CZU1lcmdlZCIsImlzTWVyZ2luZ0RhdGFzZXRzIiwibGF5ZXJDbGFzc2VzIiwiTGF5ZXJDbGFzc2VzIiwiYW5pbWF0aW9uQ29uZmlnIiwiZWRpdG9yIiwiZmlsZUxvYWRpbmciLCJmaWxlTG9hZGluZ1Byb2dyZXNzIiwibG9hZGluZ0luZGljYXRvclZhbHVlIiwibG9hZGVycyIsImxvYWRPcHRpb25zIiwibWVyZ2VycyIsIlZJU19TVEFURV9NRVJHRVJTIiwic2NoZW1hIiwiQUNUSU9OX1RBU0tfRklUX0JPVU5EUyIsImZyb21DYWxsYmFjayIsIl8iLCJjYiIsIkFDVElPTl9UQVNLX0FERF9OT1RJRklDQVRJT04iLCJ1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEiLCJzdGF0ZSIsIl9yZWYiLCJsYXllciIsImlkeCIsIm1hcCIsImx5ciIsImQiLCJ1cGRhdGVTdGF0ZU9uTGF5ZXJWaXNpYmlsaXR5Q2hhbmdlIiwibmV3U3RhdGUiLCJpc1Zpc2libGUiLCJhZGROZXdMYXllcnNUb1NwbGl0TWFwIiwicmVtb3ZlTGF5ZXJGcm9tU3BsaXRNYXBzIiwiYW5pbWF0aW9uIiwidXBkYXRlQW5pbWF0aW9uRG9tYWluIiwicGlja0NoYW5nZWRQcm9wcyIsInByZXYiLCJjaGFuZ2VkUHJvcHMiLCJwaWNrUHJvcHNPZiIsIm9iaiIsImtleSIsInByb3RvdHlwZSIsIlZJU1VBTF9DSEFOTkVMX1BST1BfVFlQRVMiLCJhcHBseUxheWVyQ29uZmlnVXBkYXRlciIsImFjdGlvbiIsIl9zZXJpYWxpemVMYXllciIsIm9sZExheWVySWQiLCJuZXdMYXllckNvbmZpZyIsImxheWVySW5kZXgiLCJuZXdQYXJzZWRMYXllciIsInBhcnNlTGF5ZXJDb25maWciLCJvbGRMYXllciIsImZpbmQiLCJsIiwiZGF0YXNldCIsImRhdGFJZCIsIm5ld0xheWVyIiwidmFsaWRhdGVMYXllcldpdGhEYXRhIiwibmV4dFN0YXRlIiwidHlwZSIsIm9sZExheWVySW5kZXgiLCJmaW5kSW5kZXgiLCJsYXllclR5cGVDaGFuZ2VVcGRhdGVyIiwibGF5ZXJUeXBlQ2hhbmdlIiwibmV3TGF5ZXJJZCIsImFwcGx5TGF5ZXJDb25maWciLCJzZXJpYWxpemVkT2xkTGF5ZXIiLCJzZXJpYWxpemVMYXllciIsInNlcmlhbGl6ZWROZXdMYXllciIsImNoYW5nZWQiLCJ2aXNDb25maWciLCJsYXllclZpc0NvbmZpZ0NoYW5nZVVwZGF0ZXIiLCJsYXllclZpc0NvbmZpZ0NoYW5nZSIsInZpc3VhbENoYW5uZWxzIiwiY2hhbm5lbE5hbWUiLCJjaGFubmVsIiwiY2hhbm5lbFByb3BOYW1lcyIsInByb3AiLCJzb21lIiwibGF5ZXJWaXN1YWxDaGFubmVsQ2hhbmdlVXBkYXRlciIsImxheWVyVmlzdWFsQ2hhbm5lbENvbmZpZ0NoYW5nZSIsIl9pdGVyYXRvciIsIl9zdGVwIiwiZXJyIiwibGF5ZXJDb25maWdDaGFuZ2VVcGRhdGVyIiwibGF5ZXJDb25maWdDaGFuZ2UiLCJ1cGRhdGVsYXllclZpc2liaWx0eSIsImZpbHRlckluZGV4IiwiZmlsdGVyU3luY2VkV2l0aFRpbWVsaW5lIiwiaXNMYXllckFuaW1hdGFibGUiLCJzeW5jVGltZUZpbHRlcldpdGhMYXllclRpbWVsaW5lVXBkYXRlciIsImVuYWJsZSIsImdldEFuaW1hdGFibGVWaXNpYmxlTGF5ZXJzIiwicHJvcHMiLCJuZXdDb25maWciLCJfYWN0aW9uJG5ld0NvbmZpZyIsInJlc3RDb25maWciLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMyIiwic3RhdGVXaXRoRGF0YUlkIiwibGF5ZXJEYXRhSWRDaGFuZ2VVcGRhdGVyIiwibmV4dExheWVyIiwidXBkYXRlTGF5ZXJDb25maWciLCJzaG91bGRDYWxjdWxhdGVMYXllckRhdGEiLCJvbGRMYXllckRhdGEiLCJ1cGRhdGVMYXllckRhdGFSZXN1bHQiLCJjYWxjdWxhdGVMYXllckRhdGEiLCJsYXllckFuaW1hdGlvbkNoYW5nZVVwZGF0ZXIiLCJfY2FsY3VsYXRlTGF5ZXJEYXRhIiwibGF5ZXJUb2dnbGVWaXNpYmlsaXR5VXBkYXRlciIsImxheWVySWQiLCJzcGxpdE1hcElkIiwibWFwSW5kZXgiLCJzbSIsInRvZ2dsZUxheWVyRm9yTWFwVXBkYXRlciIsInRvZ2dsZUxheWVyRm9yTWFwIiwic3luY2VkV2l0aExheWVyVGltZWxpbmUiLCJsYXllclNldElzVmFsaWRVcGRhdGVyIiwiaXNWYWxpZCIsImxheWVyVG9VcGRhdGUiLCJuZXdEYXRhIiwiX2NhbGN1bGF0ZUxheWVyRGF0YTIiLCJhZGRPclJlbW92ZVRleHRMYWJlbHMiLCJuZXdGaWVsZHMiLCJ0ZXh0TGFiZWwiLCJkZWZhdWx0VGV4dExhYmVsIiwiREVGQVVMVF9URVhUX0xBQkVMIiwibmV3VGV4dExhYmVsIiwiY3VycmVudEZpZWxkcyIsInRsIiwiZmllbGQiLCJhZGRGaWVsZHMiLCJpbmNsdWRlcyIsImRlbGV0ZUZpZWxkcyIsImZkIiwiY29uY2F0IiwiX3RvQ29uc3VtYWJsZUFycmF5MiIsImFmIiwidXBkYXRlVGV4dExhYmVsUHJvcEFuZFZhbHVlIiwic3BsaWNlIiwibGF5ZXJUZXh0TGFiZWxDaGFuZ2VVcGRhdGVyIiwiX29sZExheWVyJGdldERlZmF1bHRMIiwiX29sZExheWVyJGdldERlZmF1bHRMMiIsImdldERlZmF1bHRMYXllckNvbmZpZyIsInZhbGlkYXRlRXhpc3RpbmdMYXllcldpdGhEYXRhIiwibG9hZGVkTGF5ZXIiLCJhbGxvd0VtcHR5Q29sdW1uIiwiaXNWYWxpZFRvU2F2ZSIsInZhbGlkYXRlZCIsIm9sZExheWVyVHlwZSIsImlzQ29uZmlnQWN0aXZlIiwidXBkYXRlTGF5ZXJEb21haW4iLCJfY2FsY3VsYXRlTGF5ZXJEYXRhMyIsInNldEluaXRpYWxMYXllckNvbmZpZyIsInJlc3VsdCIsImZpbmREZWZhdWx0TGF5ZXJQcm9wcyIsIm5ld1R5cGUiLCJvbGRJZCIsImNvbnNvbGUiLCJlcnJvciIsImRlZmF1bHRMYXllclByb3BzIiwiYXNzaWduQ29uZmlnVG9MYXllciIsInZpc0NvbmZpZ1NldHRpbmdzIiwiaXNMYXllckhvdmVyZWQiLCJfY2FsY3VsYXRlTGF5ZXJEYXRhNCIsInNldHRpbmdzIiwiX3NldHRpbmdzJGxheWVycyIsIm9sZExheWVyTWFwIiwib3RoZXJMYXllcnMiLCJuZXdWaXNDb25maWciLCJ1cGRhdGVMYXllclZpc0NvbmZpZyIsInVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbCIsInVwZGF0ZWRTdGF0ZSIsInZpc3VhbENoYW5uZWwiLCJjaGFubmVsU2NhbGVUeXBlIiwiQ0hBTk5FTF9TQ0FMRVMiLCJjb2xvciIsInVwZGF0ZUxheWVyQ29sb3JVSSIsInJhbmdlIiwiY29sb3JSYW5nZUNvbmZpZyIsImNvbG9yVUkiLCJjdXN0b21CcmVha3MiLCJfY2FsY3VsYXRlTGF5ZXJEYXRhNSIsInNjYWxlIiwiU0NBTEVfVFlQRVMiLCJjdXN0b21PcmRpbmFsIiwiY3VzdG9tUGFsZXR0ZSIsImluaXRDdXN0b21QYWxldHRlQnlDdXN0b21TY2FsZSIsIm9yZGluYWxEb21haW4iLCJjb2xvckJyZWFrcyIsInNob3dDb2xvckNoYXJ0IiwiX2NhbGN1bGF0ZUxheWVyRGF0YTYiLCJzZXRMYXllckFuaW1hdGlvblRpbWVVcGRhdGVyIiwiX3JlZjIiLCJyZWR1Y2UiLCJhY2N1Iiwic2V0RmlsdGVyQW5pbWF0aW9uVGltZVVwZGF0ZXIiLCJzZXRGaWx0ZXJVcGRhdGVyIiwic2V0RmlsdGVyQW5pbWF0aW9uV2luZG93VXBkYXRlciIsIl9yZWYzIiwiYW5pbWF0aW9uV2luZG93IiwibmV3RmlsdGVyIiwic3dhcF8iLCJuZXdTeW5jVGltZWxpbmVNb2RlIiwiZ2V0U3luY0FuaW1hdGlvbk1vZGUiLCJzZXRUaW1lRmlsdGVyVGltZWxpbmVNb2RlVXBkYXRlciIsImFwcGx5RmlsdGVyQ29uZmlnVXBkYXRlciIsIl9zZXJpYWxpemVGaWx0ZXIiLCJmaWx0ZXJJZCIsIm9sZEZpbHRlciIsInNlcmlhbGl6ZWRPbGRGaWx0ZXIiLCJzZXJpYWxpemVGaWx0ZXIiLCJzZXJpYWxpemVkTmV3RmlsdGVyIiwic2V0RmlsdGVyIiwidmFsdWVzIiwiX2FjdGlvbiR2YWx1ZUluZGV4IiwidmFsdWVJbmRleCIsInRvQXJyYXkiLCJkYXRhc2V0SWRzVG9GaWx0ZXIiLCJfbG9vcCIsInJlcyIsInYiLCJfdXBkYXRlRmlsdGVyUHJvcCIsImVubGFyZ2VkRmlsdGVyIiwidmlldyIsIkZJTFRFUl9WSUVXX1RZUEVTIiwiZW5sYXJnZWQiLCJzaWRlIiwiZmlsdGVyZWREYXRhc2V0cyIsImFwcGx5RmlsdGVyc1RvRGF0YXNldHMiLCJmaWx0ZXJXaXRoUExvdCIsInVwZGF0ZUZpbHRlclBsb3QiLCJ1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEiLCJGSUxURVJfVFlQRVMiLCJ0aW1lUmFuZ2UiLCJhZGp1c3RBbmltYXRpb25Db25maWdXaXRoRmlsdGVyIiwiX3VwZGF0ZUZpbHRlckRhdGFJZEF0VmFsdWVJbmRleCIsIl9yZW1vdmVGaWx0ZXJEYXRhSWRBdFZhbHVlSW5kZXgiLCJuZXh0VmFsdWUiLCJnZXREZWZhdWx0RmlsdGVyIiwicmVtb3ZlRmlsdGVyUGxvdCIsIl9pIiwiX2FyciIsIm5leHRWYWwiLCJkb21haW5TdGVwcyIsIm1lcmdlRmlsdGVyRG9tYWluIiwibmV4dEZpbHRlciIsInN0ZXAiLCJhZGp1c3RWYWx1ZVRvRmlsdGVyRG9tYWluIiwiZGF0YXNldElkcyIsIkZJTFRFUl9VUERBVEVSX1BST1BTIiwib2xkRGF0YUlkIiwiZGF0YXNldElkIiwiX2FwcGx5RmlsdGVyRmllbGROYW1lIiwiYXBwbHlGaWx0ZXJGaWVsZE5hbWUiLCJtZXJnZURvbWFpbiIsInVwZGF0ZWRGaWx0ZXIiLCJuZXdEYXRhc2V0IiwiZ3B1Iiwic2V0RmlsdGVyR3B1TW9kZSIsImFzc2lnbkdwdUNoYW5uZWwiLCJsYXllcklkRGlmZmVyZW5jZSIsImxheWVyRGF0YUlkcyIsImxpZCIsIm5ld0RhdGFJZHMiLCJzZXRGaWx0ZXJQbG90VXBkYXRlciIsIl9yZWY0IiwibmV3UHJvcCIsInBpY2tfIiwibWVyZ2VfIiwicGxvdFR5cGUiLCJjaGFydFR5cGUiLCJ5QXhpcyIsIlBMT1RfVFlQRVMiLCJsaW5lQ2hhcnQiLCJoaXN0b2dyYW0iLCJhZGRGaWx0ZXJVcGRhdGVyIiwiY3JlYXRlT3JVcGRhdGVGaWx0ZXJVcGRhdGVyIiwib3JpZ2luYWxJbmRleCIsImluZGV4IiwibGF5ZXJDb2xvclVJQ2hhbmdlVXBkYXRlciIsIl9yZWY1Iiwib2xkVml4Q29uZmlnIiwidG9nZ2xlRmlsdGVyQW5pbWF0aW9uVXBkYXRlciIsImlzRmlsdGVyQW5pbWF0aW9uQ29uZmlnIiwic2V0QW5pbWF0aW9uQ29uZmlnVXBkYXRlciIsImlzU2lkZUZpbHRlciIsImFwcGx5RmlsdGVyQ29uZmlnIiwidG9nZ2xlTGF5ZXJBbmltYXRpb25VcGRhdGVyIiwidG9nZ2xlTGF5ZXJBbmltYXRpb25Db250cm9sVXBkYXRlciIsInVwZGF0ZUZpbHRlckFuaW1hdGlvblNwZWVkVXBkYXRlciIsInVwZGF0ZUxheWVyQW5pbWF0aW9uU3BlZWRVcGRhdGVyIiwiX3JlZjYiLCJzZXRGaWx0ZXJWaWV3VXBkYXRlciIsInNob3VsZFJlc2V0T3RoZXJGaWx0ZXJzVmlldyIsInRvZ2dsZUZpbHRlckZlYXR1cmVVcGRhdGVyIiwiZmVhdHVyZVRvRmlsdGVyVmFsdWUiLCJyZW1vdmVGaWx0ZXJVcGRhdGVyIiwiX3N0YXRlJGZpbHRlcnMkaWR4IiwibmV3RmlsdGVycyIsIm5ld0VkaXRvciIsImdldEZpbHRlcklkSW5GZWF0dXJlIiwiYWRkTGF5ZXJVcGRhdGVyIiwibmV3TGF5ZXJEYXRhIiwiY3JlYXRlTGF5ZXJGcm9tQ29uZmlnIiwid2FybiIsIl9hY3Rpb24kZGF0YXNldElkIiwiZGVmYXVsdERhdGFzZXQiLCJMYXllciIsInJlbW92ZUxheWVyVXBkYXRlciIsIl9yZWY3IiwiaXNGaW5pdGUiLCJsYXllclRvUmVtb3ZlIiwiZmlsdGVyT3V0QnlJZCIsInJlbW92ZUVsZW1lbnRBdEluZGV4IiwicmVvcmRlckxheWVyVXBkYXRlciIsIl9yZWY4Iiwib3JkZXIiLCJkdXBsaWNhdGVMYXllclVwZGF0ZXIiLCJfcmVmOSIsIm9yaWdpbmFsIiwib3JpZ2luYWxMYXllck9yZGVySWR4IiwibmV3TGFiZWwiLCJwb3N0Zml4IiwiZ2VuZXJhdGVIYXNoSWQiLCJMQVlFUl9JRF9MRU5HVEgiLCJuZXdMYXllck9yZGVyIiwiYXJyYXlJbnNlcnQiLCJhZGRFZmZlY3RVcGRhdGVyIiwiX2FjdGlvbiRjb25maWciLCJMSUdIVF9BTkRfU0hBRE9XX0VGRkVDVCIsImVmZmVjdCIsIm5ld0VmZmVjdCIsImNyZWF0ZUVmZmVjdCIsInNldFByb3BzIiwiZml4RWZmZWN0T3JkZXIiLCJyZW1vdmVFZmZlY3RVcGRhdGVyIiwiX3JlZjEwIiwiZWZmZWN0VG9SZW1vdmUiLCJlZmZlY3RJZCIsInJlb3JkZXJFZmZlY3RVcGRhdGVyIiwiX3JlZjExIiwidXBkYXRlRWZmZWN0VXBkYXRlciIsIl9yZWYxMiIsImlkeDIiLCJlZmZlY3RPcmRlcklkIiwibmV3RWZmZWN0cyIsInJlbW92ZURhdGFzZXRVcGRhdGVyIiwiZGF0YXNldEtleSIsIl9zdGF0ZSRkYXRhc2V0cyIsIm5ld0RhdGFzZXRzIiwibGF5ZXJzVG9SZW1vdmUiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiaW5kZXhPZiIsInJlbW92ZURhdGFzZXRGcm9tSW50ZXJhY3Rpb25Db25maWciLCJfcmVmMTMiLCJfaW50ZXJhY3Rpb25Db25maWciLCJfY29uZmlnJGZpZWxkc1RvU2hvdyIsImZpZWxkcyIsInVwZGF0ZUxheWVyQmxlbmRpbmdVcGRhdGVyIiwidXBkYXRlT3ZlcmxheUJsZW5kaW5nVXBkYXRlciIsInNob3dEYXRhc2V0VGFibGVVcGRhdGVyIiwidXBkYXRlVGFibGVDb2xvclVwZGF0ZXIiLCJ1cGRhdGVEYXRhc2V0UHJvcHNVcGRhdGVyIiwibmV3Q29sb3IiLCJyZXNldE1hcENvbmZpZ1VwZGF0ZXIiLCJpbml0aWFsU3RhdGUiLCJyZWNlaXZlTWFwQ29uZmlnVXBkYXRlciIsIl9yZWYxNCIsIl9yZWYxNCRwYXlsb2FkIiwicGF5bG9hZCIsIl9yZWYxNCRwYXlsb2FkJGNvbmZpZyIsIl9yZWYxNCRwYXlsb2FkJG9wdGlvbiIsIm9wdGlvbnMiLCJ2aXNTdGF0ZSIsImtlZXBFeGlzdGluZ0NvbmZpZyIsIm1lcmdlZFN0YXRlIiwiX2l0ZXJhdG9yMyIsIl9zdGVwMyIsIm1lcmdlciIsImlzVmFsaWRNZXJnZXIiLCJoYXNQcm9wc1RvTWVyZ2UiLCJtZXJnZSIsImdldFByb3BWYWx1ZVRvTWVyZ2VyIiwidG9NZXJnZVByb3AiLCJsYXllckhvdmVyVXBkYXRlciIsImluZm8iLCJpbnRlcmFjdGlvbkNvbmZpZ0NoYW5nZVVwZGF0ZXIiLCJjb250cmFkaWN0IiwiayIsImxheWVyQ2xpY2tVcGRhdGVyIiwicGlubmVkIiwicGlja2VkIiwibWFwQ2xpY2tVcGRhdGVyIiwibW91c2VNb3ZlVXBkYXRlciIsIl9yZWYxNSIsImV2dCIsInBvaW50IiwibW91c2VQb3NpdGlvbiIsImxuZ0xhdCIsInRvZ2dsZVNwbGl0TWFwVXBkYXRlciIsImNvbXB1dGVTcGxpdE1hcExheWVycyIsImR1cGxpY2F0ZSIsImNsb3NlU3BlY2lmaWNNYXBBdEluZGV4IiwiX3JlZjE2IiwidXBkYXRlVmlzRGF0YVVwZGF0ZXIiLCJjcmVhdGVEYXRhc2V0VGFza3MiLCJub3RpZmljYXRpb25UYXNrcyIsIl9yZWYxNyIsImRhdGFzZXRJbmRleCIsIl9yZWYxNyRpbmZvIiwicmVzdCIsInRhc2siLCJjcmVhdGVOZXdEYXRhRW50cnkiLCJhZGROb3RpZmljYXRpb24iLCJlcnJvck5vdGlmaWNhdGlvbiIsIm1lc3NhZ2UiLCJkYXRhc2V0c0FsbFNldHRsZWRUYXNrIiwiYWxsU2V0dGxlZCIsInJlc3VsdHMiLCJjcmVhdGVOZXdEYXRhc2V0U3VjY2VzcyIsImFkZFRvTWFwT3B0aW9ucyIsInNldExvYWRpbmdJbmRpY2F0b3JVcGRhdGVyIiwicGF5bG9hZF8iLCJjaGFuZ2UiLCJ3aXRoVGFzayIsImNyZWF0ZU5ld0RhdGFzZXRTdWNjZXNzVXBkYXRlciIsIl9hY3Rpb24kcGF5bG9hZCIsIm5ld0RhdGFFbnRyaWVzIiwic3RhdHVzIiwiQUNUSU9OX1RBU0siLCJyZWFzb24iLCJtZXJnZURhdGFzZXRzQnlPcmRlciIsImxheWVyTWVyZ2VycyIsIm0iLCJ3YWl0Rm9yTGF5ZXJEYXRhIiwiZGF0YXNldE1lcmdlcnMiLCJwb3N0TWVyZ2VyUGF5bG9hZCIsImFwcGx5TWVyZ2Vyc1VwZGF0ZXIiLCJtZXJnZVN0YXRlUmVzdWx0IiwibWVyZ2VTdGF0ZUZyb21NZXJnZXJzIiwiYWxsTWVyZ2VkIiwicG9zdE1lcmdlVXBkYXRlciIsImZEYXRhSWQiLCJkYXRhc2V0RmlsdGVyZWQiLCJkYXRhRW1wdHkiLCJuZXdMYXllcnMiLCJhdXRvQ3JlYXRlTGF5ZXJzIiwiYWRkRGVmYXVsdExheWVycyIsInRvb2x0aXBGaWVsZHMiLCJhdXRvQ3JlYXRlVG9vbHRpcHMiLCJhZGREZWZhdWx0VG9vbHRpcHMiLCJ1cGRhdGVkRGF0YXNldHMiLCJjZW50ZXJNYXAiLCJib3VuZHMiLCJmaW5kTWFwQm91bmRzIiwiZml0Qm91bmRzVGFzayIsImZpdEJvdW5kcyIsInJlbmFtZURhdGFzZXRVcGRhdGVyIiwiQUxMT1dFRF9VUERBVEVfREFUQVNFVF9QUk9QUyIsInZhbGlkYXRlRGF0YXNldFVwZGF0ZVByb3BzIiwidmFsaWRhdGVkUHJvcHMiLCJlbnRyaWVzIiwiYWNjIiwiZW50cnkiLCJfZW50cnkiLCJfc2xpY2VkVG9BcnJheTIiLCJpc1JnYkNvbG9yIiwiaXNQbGFpbk9iamVjdCIsImV4aXN0aW5nIiwiY29weVRhYmxlQW5kVXBkYXRlIiwiX3N0YXRlJHNwbGl0TWFwcyRpbmRlIiwiaW5kZXhUb1JldHJpZXZlIiwibWFwTGF5ZXJzIiwibG9hZEZpbGVzVXBkYXRlciIsImZpbGVzIiwiX2FjdGlvbiRvbkZpbmlzaCIsIm9uRmluaXNoIiwibG9hZEZpbGVzU3VjY2VzcyIsImluaXRpYWxGaWxlTG9hZGluZ1Byb2dyZXNzIiwiZmlsZUNhY2hlIiwiZmlsZXNUb0xvYWQiLCJsb2FkTmV4dEZpbGVVcGRhdGVyIiwibG9hZEZpbGVTdGVwU3VjY2Vzc1VwZGF0ZXIiLCJmaWxlTmFtZSIsIl9zdGF0ZSRmaWxlTG9hZGluZyIsInN0YXRlV2l0aFByb2dyZXNzIiwidXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIiLCJwcm9ncmVzcyIsInBlcmNlbnQiLCJzdGF0ZVdpdGhDYWNoZSIsIkRFTEFZX1RBU0siLCJsb2FkTmV4dEZpbGUiLCJfZmlsZXNUb0xvYWQiLCJfdG9BcnJheTIiLCJmaWxlIiwicmVtYWluaW5nRmlsZXNUb0xvYWQiLCJtYWtlTG9hZEZpbGVUYXNrIiwiTE9BRF9GSUxFX1RBU0siLCJiaW1hcCIsImdlbiIsIm5leHRGaWxlQmF0Y2giLCJwcm9jZXNzRmlsZUNvbnRlbnQiLCJjb250ZW50IiwibG9hZEZpbGVzRXJyIiwicHJvY2Vzc0ZpbGVDb250ZW50VXBkYXRlciIsIl9hY3Rpb24kcGF5bG9hZDIiLCJQUk9DRVNTX0ZJTEVfREFUQSIsImxvYWRGaWxlU3RlcFN1Y2Nlc3MiLCJwYXJzZVByb2dyZXNzIiwicHJldlByb2dyZXNzIiwibmV4dEZpbGVCYXRjaFVwZGF0ZXIiLCJfcmVmMTgiLCJfYWNjdW11bGF0ZWQkZGF0YSIsIl9yZWYxOCRwYXlsb2FkIiwiYWNjdW11bGF0ZWQiLCJnZXRBcHBsaWNhdGlvbkNvbmZpZyIsInVzZUFycm93UHJvZ3Jlc3NpdmVMb2FkaW5nIiwiZW5kc1dpdGgiLCJkYXRhIiwiVU5XUkFQX1RBU0siLCJfcmVmMTkiLCJsb2FkRmlsZXNFcnJVcGRhdGVyIiwiX3JlZjIwIiwiX3N0YXRlJGZpbGVMb2FkaW5nMiIsImFwcGx5Q1BVRmlsdGVyVXBkYXRlciIsIl9yZWYyMSIsImRhdGFJZHMiLCJmaWx0ZXJEYXRhc2V0Q1BVIiwic2V0TWFwSW5mb1VwZGF0ZXIiLCJlbXB0eSIsImRlZmF1bHRMYXllcnMiLCJmb3VuZExheWVycyIsImZpbmREZWZhdWx0TGF5ZXIiLCJnZXRMYXllck9yZGVyRnJvbUxheWVycyIsImZpbmRGaWVsZHNUb1Nob3ciLCJtZXJnZWQiLCJfcmVmMjMiLCJmaXhlZERvbWFpbiIsIl9jYWxjdWxhdGVMYXllckRhdGE3IiwiX3N0YXRlJGZpbHRlcnMiLCJhbmltYXRhYmxlTGF5ZXJzIiwibGF5ZXJEb21haW5zIiwibWVyZ2VkRG9tYWluIiwibWVyZ2VUaW1lRG9tYWlucyIsImdldFRpbWVXaWRnZXRUaXRsZUZvcm1hdHRlciIsIm1lcmdlZFRpbWVTdGVwcyIsInNvcnQiLCJCQVNFX1NQRUVEIiwiRlBTIiwic3luY2VkRmlsdGVyIiwibmV3QW5pbWF0aW9uRG9tYWluIiwiaXNJblJhbmdlIiwic2V0RWRpdG9yTW9kZVVwZGF0ZXIiLCJfcmVmMjQiLCJzZXRGZWF0dXJlc1VwZGF0ZXIiLCJfcmVmMjUiLCJfbGFzdEZlYXR1cmUkcHJvcGVydGkiLCJfcmVmMjUkZmVhdHVyZXMiLCJsYXN0RmVhdHVyZSIsInByb3BlcnRpZXMiLCJpc0Nsb3NlZCIsIkVESVQiLCJmZWF0dXJlIiwiYmJveCIsImZlYXR1cmVWYWx1ZSIsImZpbHRlcklkeCIsImZpbCIsInNldFNlbGVjdGVkRmVhdHVyZVVwZGF0ZXIiLCJfcmVmMjYiLCJzZWxlY3Rpb25Db250ZXh0IiwiZGVsZXRlRmVhdHVyZVVwZGF0ZXIiLCJfcmVmMjciLCJzZXRQb2x5Z29uRmlsdGVyTGF5ZXJVcGRhdGVyIiwibm9uZUZpbHRlckZlYXR1cmUiLCJfZmlsdGVyJGxheWVySWQiLCJpc0xheWVySW5jbHVkZWQiLCJnZW5lcmF0ZVBvbHlnb25GaWx0ZXIiLCJzb3J0VGFibGVDb2x1bW5VcGRhdGVyIiwiX3JlZjI4IiwiY29sdW1uIiwic29ydE1vZGUiLCJjdXJyZW50TW9kZSIsIlNPUlRfT1JERVIiLCJBU0NFTkRJTkciLCJzb3J0ZWQiLCJzb3J0RGF0YXNldEJ5Q29sdW1uIiwicGluVGFibGVDb2x1bW5VcGRhdGVyIiwiX3JlZjI5IiwicGluVGFibGVDb2x1bW5zIiwiY29weVRhYmxlQ29sdW1uVXBkYXRlciIsIl9yZWYzMCIsImZpZWxkSWR4IiwidGV4dCIsImRhdGFDb250YWluZXIiLCJyb3ciLCJwYXJzZUZpZWxkVmFsdWUiLCJ2YWx1ZUF0Iiwiam9pbiIsInNldENvbHVtbkRpc3BsYXlGb3JtYXRVcGRhdGVyIiwiX3JlZjMxIiwiZm9ybWF0cyIsImRpc3BsYXlGb3JtYXQiLCJfbGF5ZXIkY29uZmlnIiwiY29sb3JGaWVsZCIsInRvZ2dsZUVkaXRvclZpc2liaWxpdHlVcGRhdGVyIiwic2V0RmlsdGVyQW5pbWF0aW9uVGltZUNvbmZpZ1VwZGF0ZXIiLCJfcmVmMzIiLCJ1cGRhdGVzIiwiY2hlY2tUaW1lQ29uZmlnQXJncyIsImFsbG93ZWQiLCJzZXRMYXllckFuaW1hdGlvblRpbWVDb25maWdVcGRhdGVyIiwiX3JlZjMzIiwibGF5ZXJGaWx0ZXJlZEl0ZW1zQ2hhbmdlVXBkYXRlciIsIl9sYXllciRmaWx0ZXJlZEl0ZW1DbyIsImV2ZW50IiwiZGVja2dsTGF5ZXJJZCIsImNvdW50IiwiZmlsdGVyZWRJdGVtQ291bnQiLCJfbmV3U3RhdGUkYW5pbWF0aW9uQ28iLCJfbmV3U3RhdGUkYW5pbWF0aW9uQ28yIiwiX2FjdGlvbiRlbmFibGUiLCJpbnRlcnZhbEJhc2VkQW5pbWF0aW9uTGF5ZXJzIiwiZ2V0SW50ZXJ2YWxCYXNlZEFuaW1hdGlvbkxheWVycyIsImhhc0ludGVydmFsQmFzZWRBbmltYXRpb25MYXllciIsIkJvb2xlYW4iLCJuZXdGaWx0ZXJEb21haW4iLCJBTklNQVRJT05fV0lORE9XIiwiaW50ZXJ2YWwiLCJhZGp1c3RUaW1lRmlsdGVySW50ZXJ2YWwiLCJfbmV3RmlsdGVyVmFsdWUiLCJzeW5jVGltZWxpbmVNb2RlIiwiU1lOQ19USU1FTElORV9NT0RFUyIsImVuZCIsIm5ld0ZpbHRlclZhbHVlIiwidmFsaWRhdGVTeW5jQW5pbWF0aW9uTW9kZSIsIl9yZWYzNCIsIk1hdGgiLCJtYXgiLCJ0aW1lbGluZVZhbHVlIiwiZ2V0VGltZWxpbmVWYWx1ZUZyb21GaWx0ZXIiLCJzbmFwVG9NYXJrcyIsImZyZWUiLCJfZmlsdGVyJHN5bmNUaW1lbGluZU0iLCJuZXdNb2RlIiwic3RhcnQiLCJpbnRlcnZhbEluZGV4IiwiY3VycmVudEluZGV4IiwibWV0YSIsInRhcmdldFRpbWVJbnRlcnZhbCIsIm5ld0luZGV4IiwiVElNRV9JTlRFUlZBTFNfT1JERVJFRCIsImhleFRpbGVJbnRlcnZhbCIsIkxheWVyVG9GaWx0ZXJUaW1lSW50ZXJ2YWwiLCJnZXREZWZhdWx0VGltZUZvcm1hdCIsInVwZGF0ZWRQbG90VHlwZSIsInVwZGF0ZVRpbWVGaWx0ZXJQbG90VHlwZSIsImFkanVzdFZhbHVlVG9BbmltYXRpb25XaW5kb3ciLCJkZWZhdWx0UmVwbGFjZVBhcmVudERhdGFzZXRJZHMiLCJkYXRhSWRUb1JlcGxhY2UiLCJfdmFsdWUkY29uZmlnIiwiX3ZhbHVlJGNvbmZpZzIiLCJyZXBsYWNlZCIsImlzT2JqZWN0IiwiZmluZENoaWxkRGF0YXNldElkcyIsIl92YWx1ZSRuZXdEYXRhc2V0IiwiY2hpbGREYXRhSWRzIiwibW92ZVZhbHVlVG9CZU1lcmdlZCIsInByb3BWYWx1ZXMiLCJfcmVmMzYiLCJzYXZlVW5tZXJnZWQiLCJzdGF0ZVJlbW92ZWQiLCJwcm9wVmFsdWUiLCJwIiwidG9CZU1lcmdlZCIsInJlcGxhY2VEYXRhc2V0QW5kRGVwcyIsImRhdGFJZFRvVXNlIiwiY29tcG9zZV8iLCJhcHBseV8iLCJyZXBsYWNlRGF0YXNldERlcHNJblN0YXRlIiwicHJlcGFyZVN0YXRlRm9yRGF0YXNldFJlcGxhY2UiLCJfbmV4dFN0YXRlJGxheWVyVG9CZU0iLCJzZXJpYWxpemVkU3RhdGUiLCJzZXJpYWxpemVWaXNTdGF0ZSIsInByZXNlcnZlTGF5ZXJPcmRlciIsInByZXNlcnZlRGF0YXNldE9yZGVyIiwiX3NlcmlhbGl6ZWRTdGF0ZSRzcGxpIiwiX3JlZjM3IiwiYWNjdVN0YXRlIiwiX3JlZjM4IiwicmVwbGFjZVBhcmVudERhdGFzZXRJZHMiLCJnZXRDaGlsZERhdGFzZXRJZHMiLCJwcmVzZXJ2ZU9yZGVyIiwidG9NZXJnZVByb3BzIiwic2F2ZWRQcm9wcyIsInJlcGxhY2VkU3RhdGUiLCJfcmVwbGFjZWRTdGF0ZSRtZXJnZXIiLCJtZXJnZXJPcHRpb25zIiwicmVwbGFjZWRJdGVtIiwicmVwbGFjZVByb3BWYWx1ZUluU3RhdGUiLCJpdGVtIiwiX3JlZjM5IiwiY2hpbGREYXRhSWQiXSwic291cmNlcyI6WyIuLi9zcmMvdmlzLXN0YXRlLXVwZGF0ZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCBiYm94IGZyb20gJ0B0dXJmL2Jib3gnO1xuaW1wb3J0IGNvcHkgZnJvbSAnY29weS10by1jbGlwYm9hcmQnO1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IHtjb25zb2xlIGFzIENvbnNvbGV9IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2gvY2xvbmVEZWVwJztcbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2gvaXNFcXVhbCc7XG5pbXBvcnQgcGljayBmcm9tICdsb2Rhc2gvcGljayc7XG5pbXBvcnQgdW5pcSBmcm9tICdsb2Rhc2gvdW5pcSc7XG5pbXBvcnQgeG9yIGZyb20gJ2xvZGFzaC94b3InO1xuaW1wb3J0IFRhc2ssIHtkaXNhYmxlU3RhY2tDYXB0dXJpbmcsIHdpdGhUYXNrfSBmcm9tICdyZWFjdC1wYWxtL3Rhc2tzJztcbi8vIFRhc2tzXG5pbXBvcnQge1xuICBERUxBWV9UQVNLLFxuICBBQ1RJT05fVEFTSyxcbiAgTE9BRF9GSUxFX1RBU0ssXG4gIFBST0NFU1NfRklMRV9EQVRBLFxuICBVTldSQVBfVEFTS1xufSBmcm9tICdAa2VwbGVyLmdsL3Rhc2tzJztcbi8vIEFjdGlvbnNcbmltcG9ydCB7XG4gIGFkZE5vdGlmaWNhdGlvbixcbiAgQWN0aW9uVHlwZXMsXG4gIENyZWF0ZU5ld0RhdGFzZXRTdWNjZXNzUGF5bG9hZCxcbiAgTWFwU3RhdGVBY3Rpb25zLFxuICBSZWNlaXZlTWFwQ29uZmlnUGF5bG9hZCxcbiAgVmlzU3RhdGVBY3Rpb25zLFxuICBhcHBseUxheWVyQ29uZmlnLFxuICBjcmVhdGVOZXdEYXRhc2V0U3VjY2VzcyxcbiAgbGF5ZXJDb25maWdDaGFuZ2UsXG4gIGxheWVyVHlwZUNoYW5nZSxcbiAgbGF5ZXJWaXNDb25maWdDaGFuZ2UsXG4gIGxheWVyVmlzdWFsQ2hhbm5lbENvbmZpZ0NoYW5nZSxcbiAgbG9hZEZpbGVTdGVwU3VjY2VzcyxcbiAgbG9hZEZpbGVzRXJyLFxuICBsb2FkRmlsZXNTdWNjZXNzLFxuICBsb2FkTmV4dEZpbGUsXG4gIG5leHRGaWxlQmF0Y2gsXG4gIHNldEZpbHRlcixcbiAgcHJvY2Vzc0ZpbGVDb250ZW50LFxuICBmaXRCb3VuZHMgYXMgZml0TWFwQm91bmRzLFxuICB0b2dnbGVMYXllckZvck1hcCxcbiAgYXBwbHlGaWx0ZXJDb25maWcsXG4gIFNldExvYWRpbmdJbmRpY2F0b3JQYXlsb2FkXG59IGZyb20gJ0BrZXBsZXIuZ2wvYWN0aW9ucyc7XG5cbi8vIFV0aWxzXG5pbXBvcnQge1xuICBGSUxURVJfVVBEQVRFUl9QUk9QUyxcbiAgYWRkTmV3TGF5ZXJzVG9TcGxpdE1hcCxcbiAgc25hcFRvTWFya3MsXG4gIGFwcGx5RmlsdGVyRmllbGROYW1lLFxuICBhcHBseUZpbHRlcnNUb0RhdGFzZXRzLFxuICBhcnJheUluc2VydCxcbiAgY29tcHV0ZVNwbGl0TWFwTGF5ZXJzLFxuICBhZGp1c3RWYWx1ZVRvRmlsdGVyRG9tYWluLFxuICBlcnJvck5vdGlmaWNhdGlvbixcbiAgZmVhdHVyZVRvRmlsdGVyVmFsdWUsXG4gIGZpbHRlckRhdGFzZXRDUFUsXG4gIGdlbmVyYXRlUG9seWdvbkZpbHRlcixcbiAgZ2V0RGVmYXVsdEZpbHRlcixcbiAgZ2V0RmlsdGVySWRJbkZlYXR1cmUsXG4gIGdldFRpbWVXaWRnZXRUaXRsZUZvcm1hdHRlcixcbiAgaXNJblJhbmdlLFxuICBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNSZ2JDb2xvcixcbiAgcGFyc2VGaWVsZFZhbHVlLFxuICByZW1vdmVMYXllckZyb21TcGxpdE1hcHMsXG4gIHNldCxcbiAgdXBkYXRlRmlsdGVyUGxvdCxcbiAgcmVtb3ZlRmlsdGVyUGxvdCxcbiAgaXNMYXllckFuaW1hdGFibGUsXG4gIGlzU2lkZUZpbHRlcixcbiAgZ2V0QXBwbGljYXRpb25Db25maWdcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge2dlbmVyYXRlSGFzaElkLCB0b0FycmF5fSBmcm9tICdAa2VwbGVyLmdsL2NvbW1vbi11dGlscyc7XG4vLyBNZXJnZXJzXG5pbXBvcnQge1xuICBBTklNQVRJT05fV0lORE9XLFxuICBCQVNFX1NQRUVELFxuICBDT01QQVJFX1RZUEVTLFxuICBERUZBVUxUX1RFWFRfTEFCRUwsXG4gIEVESVRPUl9NT0RFUyxcbiAgRklMVEVSX1RZUEVTLFxuICBGSUxURVJfVklFV19UWVBFUyxcbiAgRlBTLFxuICBMSUdIVF9BTkRfU0hBRE9XX0VGRkVDVCxcbiAgTUFYX0RFRkFVTFRfVE9PTFRJUFMsXG4gIFBMT1RfVFlQRVMsXG4gIFNPUlRfT1JERVIsXG4gIFNZTkNfVElNRUxJTkVfTU9ERVMsXG4gIENIQU5ORUxfU0NBTEVTLFxuICBTQ0FMRV9UWVBFU1xufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge0xBWUVSX0lEX0xFTkdUSCwgTGF5ZXIsIExheWVyQ2xhc3Nlc30gZnJvbSAnQGtlcGxlci5nbC9sYXllcnMnO1xuaW1wb3J0IHtcbiAgYXBwbHlfLFxuICBjb21wb3NlXyxcbiAgZmlsdGVyT3V0QnlJZCxcbiAgbWVyZ2VfLFxuICBwYXlsb2FkXyxcbiAgcGlja18sXG4gIHJlbW92ZUVsZW1lbnRBdEluZGV4LFxuICBzd2FwX1xufSBmcm9tICcuL2NvbXBvc2VyLWhlbHBlcnMnO1xuaW1wb3J0IHtpc1ZhbGlkTWVyZ2VyLCBtZXJnZVN0YXRlRnJvbU1lcmdlcnN9IGZyb20gJy4vbWVyZ2VyLWhhbmRsZXInO1xuaW1wb3J0IHtcbiAgVklTX1NUQVRFX01FUkdFUlMsXG4gIGNyZWF0ZUxheWVyRnJvbUNvbmZpZyxcbiAgcGFyc2VMYXllckNvbmZpZyxcbiAgc2VyaWFsaXplRmlsdGVyLFxuICBzZXJpYWxpemVMYXllcixcbiAgc2VyaWFsaXplVmlzU3RhdGUsXG4gIHZhbGlkYXRlTGF5ZXJXaXRoRGF0YVxufSBmcm9tICcuL3Zpcy1zdGF0ZS1tZXJnZXInO1xuXG5pbXBvcnQgS2VwbGVyR0xTY2hlbWEsIHtNZXJnZXIsIFBvc3RNZXJnZXJQYXlsb2FkLCBWaXNTdGF0ZX0gZnJvbSAnQGtlcGxlci5nbC9zY2hlbWFzJztcblxuaW1wb3J0IHtcbiAgRmlsdGVyLFxuICBJbnRlcmFjdGlvbkNvbmZpZyxcbiAgQW5pbWF0aW9uQ29uZmlnLFxuICBGaWx0ZXJBbmltYXRpb25Db25maWcsXG4gIEVkaXRvcixcbiAgRmllbGQsXG4gIFRpbWVSYW5nZUZpbHRlclxufSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7TG9hZGVyfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuXG5pbXBvcnQge1xuICBEYXRhc2V0cyxcbiAgYXNzaWduR3B1Q2hhbm5lbCxcbiAgY29weVRhYmxlQW5kVXBkYXRlLFxuICBjcmVhdGVOZXdEYXRhRW50cnksXG4gIHBpblRhYmxlQ29sdW1ucyxcbiAgc2V0RmlsdGVyR3B1TW9kZSxcbiAgc29ydERhdGFzZXRCeUNvbHVtblxufSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcbmltcG9ydCB7ZmluZEZpZWxkc1RvU2hvd30gZnJvbSAnLi9pbnRlcmFjdGlvbi11dGlscyc7XG5pbXBvcnQge2NhbGN1bGF0ZUxheWVyRGF0YSwgZmluZERlZmF1bHRMYXllciwgZ2V0TGF5ZXJPcmRlckZyb21MYXllcnN9IGZyb20gJy4vbGF5ZXItdXRpbHMnO1xuaW1wb3J0IHtnZXRQcm9wVmFsdWVUb01lcmdlciwgaGFzUHJvcHNUb01lcmdlfSBmcm9tICcuL21lcmdlci1oYW5kbGVyJztcbmltcG9ydCB7bWVyZ2VEYXRhc2V0c0J5T3JkZXJ9IGZyb20gJy4vdmlzLXN0YXRlLW1lcmdlcic7XG5pbXBvcnQge1xuICBmaXhFZmZlY3RPcmRlcixcbiAgZ2V0QW5pbWF0YWJsZVZpc2libGVMYXllcnMsXG4gIGdldEludGVydmFsQmFzZWRBbmltYXRpb25MYXllcnMsXG4gIG1lcmdlVGltZURvbWFpbnMsXG4gIGFkanVzdFZhbHVlVG9BbmltYXRpb25XaW5kb3csXG4gIHVwZGF0ZVRpbWVGaWx0ZXJQbG90VHlwZSxcbiAgZ2V0RGVmYXVsdFRpbWVGb3JtYXQsXG4gIExheWVyVG9GaWx0ZXJUaW1lSW50ZXJ2YWwsXG4gIFRJTUVfSU5URVJWQUxTX09SREVSRUQsXG4gIG1lcmdlRmlsdGVyRG9tYWluLFxuICBpbml0Q3VzdG9tUGFsZXR0ZUJ5Q3VzdG9tU2NhbGVcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge2NyZWF0ZUVmZmVjdH0gZnJvbSAnQGtlcGxlci5nbC9lZmZlY3RzJztcbmltcG9ydCB7UGF5bG9hZEFjdGlvbn0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5cbmltcG9ydCB7ZmluZE1hcEJvdW5kc30gZnJvbSAnLi9kYXRhLXV0aWxzJztcblxuLy8gcmVhY3QtcGFsbVxuLy8gZGlzYWJsZSBjYXB0dXJlIGV4Y2VwdGlvbiBmb3IgcmVhY3QtcGFsbSBjYWxsIHRvIHdpdGhUYXNrXG5kaXNhYmxlU3RhY2tDYXB0dXJpbmcoKTtcblxuLyoqXG4gKiBVcGRhdGVycyBmb3IgYHZpc1N0YXRlYCByZWR1Y2VyLiBDYW4gYmUgdXNlZCBpbiB5b3VyIHJvb3QgcmVkdWNlciB0byBkaXJlY3RseSBtb2RpZnkga2VwbGVyLmdsJ3Mgc3RhdGUuXG4gKiBSZWFkIG1vcmUgYWJvdXQgW1VzaW5nIHVwZGF0ZXJzXSguLi9hZHZhbmNlZC11c2FnZS91c2luZy11cGRhdGVycy5tZClcbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBrZXBsZXJHbFJlZHVjZXIsIHt2aXNTdGF0ZVVwZGF0ZXJzfSBmcm9tICdrZXBsZXIuZ2wvcmVkdWNlcnMnO1xuICogLy8gUm9vdCBSZWR1Y2VyXG4gKiBjb25zdCByZWR1Y2VycyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gKiAga2VwbGVyR2w6IGtlcGxlckdsUmVkdWNlcixcbiAqICBhcHA6IGFwcFJlZHVjZXJcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNvbXBvc2VkUmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gKiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICogICAgY2FzZSAnQ0xJQ0tfQlVUVE9OJzpcbiAqICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAuLi5zdGF0ZSxcbiAqICAgICAgICBrZXBsZXJHbDoge1xuICogICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wsXG4gKiAgICAgICAgICBmb286IHtcbiAqICAgICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLmZvbyxcbiAqICAgICAgICAgICAgIHZpc1N0YXRlOiB2aXNTdGF0ZVVwZGF0ZXJzLmVubGFyZ2VGaWx0ZXJVcGRhdGVyKFxuICogICAgICAgICAgICAgICBzdGF0ZS5rZXBsZXJHbC5mb28udmlzU3RhdGUsXG4gKiAgICAgICAgICAgICAgIHtpZHg6IDB9XG4gKiAgICAgICAgICAgICApXG4gKiAgICAgICAgICB9XG4gKiAgICAgICAgfVxuICogICAgICB9O1xuICogIH1cbiAqICByZXR1cm4gcmVkdWNlcnMoc3RhdGUsIGFjdGlvbik7XG4gKiB9O1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGNvbXBvc2VkUmVkdWNlcjtcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCB2aXNTdGF0ZVVwZGF0ZXJzID0gbnVsbDtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0SW50ZXJhY3Rpb25Db25maWc6IEludGVyYWN0aW9uQ29uZmlnID0ge1xuICB0b29sdGlwOiB7XG4gICAgaWQ6ICd0b29sdGlwJyxcbiAgICBsYWJlbDogJ2ludGVyYWN0aW9ucy50b29sdGlwJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGNvbmZpZzoge1xuICAgICAgZmllbGRzVG9TaG93OiB7fSxcbiAgICAgIGNvbXBhcmVNb2RlOiBmYWxzZSxcbiAgICAgIGNvbXBhcmVUeXBlOiBDT01QQVJFX1RZUEVTLkFCU09MVVRFXG4gICAgfVxuICB9LFxuICBnZW9jb2Rlcjoge1xuICAgIGlkOiAnZ2VvY29kZXInLFxuICAgIGxhYmVsOiAnaW50ZXJhY3Rpb25zLmdlb2NvZGVyJyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICBwb3NpdGlvbjogbnVsbFxuICB9LFxuICBicnVzaDoge1xuICAgIGlkOiAnYnJ1c2gnLFxuICAgIGxhYmVsOiAnaW50ZXJhY3Rpb25zLmJydXNoJyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICBjb25maWc6IHtcbiAgICAgIC8vIHNpemUgaXMgaW4ga21cbiAgICAgIHNpemU6IDAuNVxuICAgIH1cbiAgfSxcbiAgY29vcmRpbmF0ZToge1xuICAgIGlkOiAnY29vcmRpbmF0ZScsXG4gICAgbGFiZWw6ICdpbnRlcmFjdGlvbnMuY29vcmRpbmF0ZScsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgcG9zaXRpb246IG51bGxcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQU5JTUFUSU9OX0NPTkZJRzogQW5pbWF0aW9uQ29uZmlnID0ge1xuICBkb21haW46IG51bGwsXG4gIGN1cnJlbnRUaW1lOiBudWxsLFxuICBzcGVlZDogMSxcbiAgaXNBbmltYXRpbmc6IGZhbHNlLFxuICB0aW1lU3RlcHM6IG51bGwsXG4gIHRpbWVGb3JtYXQ6IG51bGwsXG4gIHRpbWV6b25lOiBudWxsLFxuICBkZWZhdWx0VGltZUZvcm1hdDogbnVsbCxcbiAgaGlkZUNvbnRyb2w6IGZhbHNlLFxuICBkdXJhdGlvbjogbnVsbFxufTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRURJVE9SOiBFZGl0b3IgPSB7XG4gIG1vZGU6IEVESVRPUl9NT0RFUy5EUkFXX1BPTFlHT04sXG4gIGZlYXR1cmVzOiBbXSxcbiAgc2VsZWN0ZWRGZWF0dXJlOiBudWxsLFxuICB2aXNpYmxlOiB0cnVlXG59O1xuXG4vKipcbiAqIERlZmF1bHQgaW5pdGlhbCBgdmlzU3RhdGVgXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQGNvbnN0YW50XG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBJTklUSUFMX1ZJU19TVEFURTogVmlzU3RhdGUgPSB7XG4gIC8vIG1hcCBpbmZvXG4gIG1hcEluZm86IHtcbiAgICB0aXRsZTogJycsXG4gICAgZGVzY3JpcHRpb246ICcnXG4gIH0sXG4gIC8vIGxheWVyc1xuICBsYXllcnM6IFtdLFxuICBsYXllckRhdGE6IFtdLFxuICBsYXllclRvQmVNZXJnZWQ6IFtdLFxuICBsYXllck9yZGVyOiBbXSxcblxuICAvLyBmaWx0ZXJzXG4gIGZpbHRlcnM6IFtdLFxuICBmaWx0ZXJUb0JlTWVyZ2VkOiBbXSxcblxuICAvLyBhIGNvbGxlY3Rpb24gb2YgbXVsdGlwbGUgZGF0YXNldFxuICBkYXRhc2V0czoge30sXG4gIGVkaXRpbmdEYXRhc2V0OiB1bmRlZmluZWQsXG5cbiAgLy8gZWZmZWN0c1xuICBlZmZlY3RzOiBbXSxcbiAgZWZmZWN0T3JkZXI6IFtdLFxuXG4gIGludGVyYWN0aW9uQ29uZmlnOiBkZWZhdWx0SW50ZXJhY3Rpb25Db25maWcsXG4gIGludGVyYWN0aW9uVG9CZU1lcmdlZDoge30sXG5cbiAgbGF5ZXJCbGVuZGluZzogJ25vcm1hbCcsXG4gIG92ZXJsYXlCbGVuZGluZzogJ25vcm1hbCcsXG4gIGhvdmVySW5mbzogdW5kZWZpbmVkLFxuICBjbGlja2VkOiB1bmRlZmluZWQsXG4gIG1vdXNlUG9zOiB7fSxcbiAgbWF4RGVmYXVsdFRvb2x0aXBzOiBNQVhfREVGQVVMVF9UT09MVElQUyxcblxuICAvLyB0aGlzIGlzIHVzZWQgd2hlbiB1c2VyIHNwbGl0IG1hcHNcbiAgc3BsaXRNYXBzOiBbXG4gICAgLy8gdGhpcyB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIG9iamVjdHMgdG9cbiAgICAvLyBkZXNjcmliZSB0aGUgc3RhdGUgb2YgbGF5ZXIgYXZhaWxhYmlsaXR5IGFuZCB2aXNpYmlsaXR5IGZvciBlYWNoIG1hcFxuICAgIC8vIFtcbiAgICAvLyAgIHtcbiAgICAvLyAgICAgIGxheWVyczoge2xheWVyX2lkOiB0cnVlIHwgZmFsc2V9XG4gICAgLy8gICB9XG4gICAgLy8gXVxuICBdLFxuICBzcGxpdE1hcHNUb0JlTWVyZ2VkOiBbXSxcbiAgaXNNZXJnaW5nRGF0YXNldHM6IHt9LFxuICAvLyBkZWZhdWx0cyBsYXllciBjbGFzc2VzXG4gIGxheWVyQ2xhc3NlczogTGF5ZXJDbGFzc2VzLFxuXG4gIC8vIGRlZmF1bHQgYW5pbWF0aW9uXG4gIC8vIHRpbWUgaW4gdW5peCB0aW1lc3RhbXAgKG1pbGxpc2Vjb25kcykgKHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBFcG9jaClcbiAgYW5pbWF0aW9uQ29uZmlnOiBERUZBVUxUX0FOSU1BVElPTl9DT05GSUcsXG5cbiAgZWRpdG9yOiBERUZBVUxUX0VESVRPUixcblxuICBmaWxlTG9hZGluZzogZmFsc2UsXG4gIGZpbGVMb2FkaW5nUHJvZ3Jlc3M6IHt9LFxuICAvLyBmb3IgbG9hZGluZyBkYXRhc2V0c1xuICBsb2FkaW5nSW5kaWNhdG9yVmFsdWU6IDAsXG5cbiAgbG9hZGVyczogW10sXG4gIGxvYWRPcHRpb25zOiB7fSxcblxuICAvLyB2aXNTdGF0ZU1lcmdlcnNcbiAgbWVyZ2VyczogVklTX1NUQVRFX01FUkdFUlMsXG5cbiAgLy8ga2VwbGVyIHNjaGVtYXNcbiAgc2NoZW1hOiBLZXBsZXJHTFNjaGVtYVxufTtcblxuZXhwb3J0IGNvbnN0IEFDVElPTl9UQVNLX0ZJVF9CT1VORFMgPSBUYXNrLmZyb21DYWxsYmFjayhcbiAgKF8sIGNiKSA9PiBjYigpLFxuXG4gICdBQ1RJT05fVEFTS19GSVRfQk9VTkRTJ1xuKTtcblxuZXhwb3J0IGNvbnN0IEFDVElPTl9UQVNLX0FERF9OT1RJRklDQVRJT04gPSBUYXNrLmZyb21DYWxsYmFjayhcbiAgKF8sIGNiKSA9PiBjYigpLFxuXG4gICdBQ1RJT05fVEFTS19BRERfTk9USUZJQ0FUSU9OJ1xuKTtcblxudHlwZSBVcGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGFUeXBlID0ge1xuICBsYXllcnM6IExheWVyW107XG4gIGxheWVyRGF0YTogYW55W107XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBzdGF0ZSB3aXRoIHVwZGF0ZWQgbGF5ZXIgYW5kIGxheWVyRGF0YVxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YTxTIGV4dGVuZHMgVXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhVHlwZT4oXG4gIHN0YXRlOiBTLFxuICB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fToge2xheWVyRGF0YT86IGFueTsgbGF5ZXI6IExheWVyOyBpZHg6IG51bWJlcn1cbik6IFMge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogc3RhdGUubGF5ZXJzLm1hcCgobHlyLCBpKSA9PiAoaSA9PT0gaWR4ID8gbGF5ZXIgOiBseXIpKSxcbiAgICBsYXllckRhdGE6IGxheWVyRGF0YVxuICAgICAgPyBzdGF0ZS5sYXllckRhdGEubWFwKChkLCBpKSA9PiAoaSA9PT0gaWR4ID8gbGF5ZXJEYXRhIDogZCkpXG4gICAgICA6IHN0YXRlLmxheWVyRGF0YVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU3RhdGVPbkxheWVyVmlzaWJpbGl0eUNoYW5nZTxTIGV4dGVuZHMgVmlzU3RhdGU+KHN0YXRlOiBTLCBsYXllcjogTGF5ZXIpOiBTIHtcbiAgbGV0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGlmIChzdGF0ZS5zcGxpdE1hcHMubGVuZ3RoKSB7XG4gICAgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNwbGl0TWFwczogbGF5ZXIuY29uZmlnLmlzVmlzaWJsZVxuICAgICAgICA/IGFkZE5ld0xheWVyc1RvU3BsaXRNYXAoc3RhdGUuc3BsaXRNYXBzLCBsYXllcilcbiAgICAgICAgOiByZW1vdmVMYXllckZyb21TcGxpdE1hcHMoc3RhdGUuc3BsaXRNYXBzLCBsYXllcilcbiAgICB9O1xuICB9XG5cbiAgaWYgKGxheWVyLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlZCkge1xuICAgIG5ld1N0YXRlID0gdXBkYXRlQW5pbWF0aW9uRG9tYWluKG5ld1N0YXRlKTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0d28gb2JqZWN0cyAob3IgYXJyYXlzKSBhbmQgcmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBvbmx5IHRoZVxuICogcHJvcGVydGllcyB0aGF0IGhhdmUgY2hhbmdlZCBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcGlja0NoYW5nZWRQcm9wczxUPihwcmV2OiBULCBuZXh0OiBUKTogUGFydGlhbDxUPiB7XG4gIGNvbnN0IGNoYW5nZWRQcm9wczogUGFydGlhbDxUPiA9IHt9O1xuICBjb25zdCBwaWNrUHJvcHNPZiA9IG9iaiA9PiB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hhbmdlZFByb3BzLCBrZXkpICYmXG4gICAgICAgICFpc0VxdWFsKHByZXZba2V5XSwgbmV4dFtrZXldKVxuICAgICAgKSB7XG4gICAgICAgIGNoYW5nZWRQcm9wc1trZXldID0gbmV4dFtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBwaWNrUHJvcHNPZihwcmV2KTtcbiAgcGlja1Byb3BzT2YobmV4dCk7XG4gIHJldHVybiBjaGFuZ2VkUHJvcHM7XG59XG5cbmNvbnN0IFZJU1VBTF9DSEFOTkVMX1BST1BfVFlQRVMgPSBbJ2ZpZWxkJywgJ3NjYWxlJywgJ2RvbWFpbicsICdhZ2dyZWdhdGlvbiddO1xuXG4vKipcbiAqIEFwcGx5IGxheWVyIGNvbmZpZ1xuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHNcbmV4cG9ydCBmdW5jdGlvbiBhcHBseUxheWVyQ29uZmlnVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5BcHBseUxheWVyQ29uZmlnVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7b2xkTGF5ZXJJZCwgbmV3TGF5ZXJDb25maWcsIGxheWVySW5kZXh9ID0gYWN0aW9uO1xuICBjb25zdCBuZXdQYXJzZWRMYXllciA9XG4gICAgLy8gd2lsbCBtb3ZlIHZpc3VhbENoYW5uZWxzIHRvIHRoZSBjb25maWcgcHJvcFxuICAgIHBhcnNlTGF5ZXJDb25maWcoc3RhdGUuc2NoZW1hLCBuZXdMYXllckNvbmZpZyk7XG4gIGNvbnN0IG9sZExheWVyID0gc3RhdGUubGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBvbGRMYXllcklkKTtcbiAgaWYgKCFvbGRMYXllciB8fCAhbmV3UGFyc2VkTGF5ZXIpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKGxheWVySW5kZXggIT09IG51bGwgJiYgbGF5ZXJJbmRleCAhPT0gdW5kZWZpbmVkICYmIHN0YXRlLmxheWVyc1tsYXllckluZGV4XSAhPT0gb2xkTGF5ZXIpIHtcbiAgICAvLyBsYXllckluZGV4IGlzIHByb3ZpZGVkLCBidXQgaXQgZG9lc24ndCBtYXRjaCB0aGUgb2xkTGF5ZXJcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW25ld1BhcnNlZExheWVyLmNvbmZpZy5kYXRhSWRdO1xuICBpZiAoIWRhdGFzZXQpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgLy8gTWFrZSBzdXJlIHRoZSBsYXllciBpcyB2YWxpZCBhbmQgY29udmVydCBpdCB0byBMYXllclxuICBjb25zdCBuZXdMYXllciA9IHZhbGlkYXRlTGF5ZXJXaXRoRGF0YShkYXRhc2V0LCBuZXdQYXJzZWRMYXllciwgc3RhdGUubGF5ZXJDbGFzc2VzKTtcbiAgaWYgKCFuZXdMYXllcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGxldCBuZXh0U3RhdGUgPSBzdGF0ZTtcblxuICBpZiAobmV3TGF5ZXIudHlwZSAmJiBuZXdMYXllci50eXBlICE9PSBvbGRMYXllci50eXBlKSB7XG4gICAgY29uc3Qgb2xkTGF5ZXJJbmRleCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllcklkKTtcbiAgICBpZiAob2xkTGF5ZXJJbmRleCA+PSAwKSB7XG4gICAgICBuZXh0U3RhdGUgPSBsYXllclR5cGVDaGFuZ2VVcGRhdGVyKG5leHRTdGF0ZSwgbGF5ZXJUeXBlQ2hhbmdlKG9sZExheWVyLCBuZXdMYXllci50eXBlKSk7XG4gICAgICAvLyBsYXllclR5cGVDaGFuZ2VVcGRhdGVyIGNoYW5nZXMgdGhlIGlkIG9mIHRoZSBsYXllciwgc28gd2UgbmVlZCB0byBvYnRhaW4gdGhlIG5ldyBpZFxuICAgICAgLy8gYnV0IGZpcnN0IG1ha2Ugc3VyZSB0aGF0IHRoZSBsYXllciB3YXMgbm90IHJlbW92ZWRcbiAgICAgIGlmIChuZXh0U3RhdGUubGF5ZXJzLmxlbmd0aCA9PT0gc3RhdGUubGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBuZXdMYXllcklkID0gbmV4dFN0YXRlLmxheWVyc1tvbGRMYXllckluZGV4XS5pZDtcbiAgICAgICAgbmV4dFN0YXRlID0gYXBwbHlMYXllckNvbmZpZ1VwZGF0ZXIoXG4gICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgIGFwcGx5TGF5ZXJDb25maWcobmV3TGF5ZXJJZCwgey4uLm5ld0xheWVyQ29uZmlnLCBpZDogbmV3TGF5ZXJJZH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH1cblxuICAvLyBzZXJpYWxpemVMYXllcigpIG1pZ2h0IHJldHVybiBudWxsIGlmIHRoZSBvbGQgbGF5ZXIgaXMgbm90IHZhbGlkLFxuICAvLyB3ZSBzaG91bGQgc3RpbGwgYXBwbHkgdGhlIGNoYW5nZXMgaW4gdGhhdCBjYXNlXG4gIGNvbnN0IHNlcmlhbGl6ZWRPbGRMYXllciA9IHNlcmlhbGl6ZUxheWVyKG9sZExheWVyLCBzdGF0ZS5zY2hlbWEpID8/IHtjb25maWc6IHt9fTtcbiAgY29uc3Qgc2VyaWFsaXplZE5ld0xheWVyID0gc2VyaWFsaXplTGF5ZXIobmV3TGF5ZXIsIHN0YXRlLnNjaGVtYSk7XG4gIGlmICghc2VyaWFsaXplZE5ld0xheWVyKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmICghaXNFcXVhbChzZXJpYWxpemVkT2xkTGF5ZXIsIHNlcmlhbGl6ZWROZXdMYXllcikpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gcGlja0NoYW5nZWRQcm9wcyhzZXJpYWxpemVkT2xkTGF5ZXIuY29uZmlnLCBzZXJpYWxpemVkTmV3TGF5ZXIuY29uZmlnKTtcblxuICAgIGlmICgndmlzQ29uZmlnJyBpbiBjaGFuZ2VkKSB7XG4gICAgICBpZiAoY2hhbmdlZC52aXNDb25maWcpIHtcbiAgICAgICAgbmV4dFN0YXRlID0gbGF5ZXJWaXNDb25maWdDaGFuZ2VVcGRhdGVyKFxuICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICBsYXllclZpc0NvbmZpZ0NoYW5nZShvbGRMYXllciwgY2hhbmdlZC52aXNDb25maWcpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWxldGUgY2hhbmdlZC52aXNDb25maWc7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMob2xkTGF5ZXIudmlzdWFsQ2hhbm5lbHMpLmZvckVhY2goY2hhbm5lbE5hbWUgPT4ge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IG9sZExheWVyLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxOYW1lXTtcbiAgICAgIGNvbnN0IGNoYW5uZWxQcm9wTmFtZXMgPSBWSVNVQUxfQ0hBTk5FTF9QUk9QX1RZUEVTLm1hcChwcm9wID0+IGNoYW5uZWxbcHJvcF0pO1xuICAgICAgaWYgKGNoYW5uZWxQcm9wTmFtZXMuc29tZShwcm9wID0+IHByb3AgaW4gY2hhbmdlZCkpIHtcbiAgICAgICAgbmV4dFN0YXRlID0gbGF5ZXJWaXN1YWxDaGFubmVsQ2hhbmdlVXBkYXRlcihcbiAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgbGF5ZXJWaXN1YWxDaGFubmVsQ29uZmlnQ2hhbmdlKFxuICAgICAgICAgICAgb2xkTGF5ZXIsXG4gICAgICAgICAgICBwaWNrKG5ld0xheWVyLmNvbmZpZywgY2hhbm5lbFByb3BOYW1lcyksXG4gICAgICAgICAgICBjaGFubmVsTmFtZVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGNoYW5uZWxQcm9wTmFtZXMpIHtcbiAgICAgICAgICBkZWxldGUgY2hhbmdlZFtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKGNoYW5nZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgIG5leHRTdGF0ZSA9IGxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlcihcbiAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICBsYXllckNvbmZpZ0NoYW5nZShvbGRMYXllciwgcGljayhuZXdMYXllci5jb25maWcsIE9iamVjdC5rZXlzKGNoYW5nZWQpKSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlbGF5ZXJWaXNpYmlsdHkoc3RhdGU6IFZpc1N0YXRlLCBuZXdMYXllcjogTGF5ZXIsIGlzVmlzaWJsZT86IGJvb2xlYW4pOiBWaXNTdGF0ZSB7XG4gIGxldCBuZXdTdGF0ZSA9IHVwZGF0ZVN0YXRlT25MYXllclZpc2liaWxpdHlDaGFuZ2Uoc3RhdGUsIG5ld0xheWVyKTtcbiAgY29uc3QgZmlsdGVySW5kZXggPSBmaWx0ZXJTeW5jZWRXaXRoVGltZWxpbmUoc3RhdGUpO1xuICBpZiAoaXNMYXllckFuaW1hdGFibGUobmV3TGF5ZXIpICYmIGZpbHRlckluZGV4ICE9PSAtMSkge1xuICAgIC8vIGlmIGxheWVyIGlzIGdvaW5nIHRvIGJlIHZpc2libGUgd2Ugc3luYyB3aXRoIGZpbHRlciBvdGhlcndpc2Ugd2UgbmVlZCB0byBjaGVjayB3aGV0aGVyIG90aGVyIGFuaW1hdGFibGUgbGF5ZXJzIGV4aXN0cyBhbmQgYXJlIHZpc2libGVcbiAgICBuZXdTdGF0ZSA9IHN5bmNUaW1lRmlsdGVyV2l0aExheWVyVGltZWxpbmVVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgICBpZHg6IGZpbHRlckluZGV4LFxuICAgICAgZW5hYmxlOiBpc1Zpc2libGUgPyBpc1Zpc2libGUgOiBnZXRBbmltYXRhYmxlVmlzaWJsZUxheWVycyhzdGF0ZS5sYXllcnMpLmxlbmd0aCA+IDBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogVXBkYXRlIGxheWVyIGJhc2UgY29uZmlnOiBkYXRhSWQsIGxhYmVsLCBjb2x1bW4sIGlzVmlzaWJsZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5MYXllckNvbmZpZ0NoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge29sZExheWVyfSA9IGFjdGlvbjtcbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcbiAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhhY3Rpb24ubmV3Q29uZmlnKTtcbiAgaWYgKFxuICAgIHR5cGVvZiBhY3Rpb24ubmV3Q29uZmlnLmRhdGFJZCA9PT0gJ3N0cmluZycgJiZcbiAgICBhY3Rpb24ubmV3Q29uZmlnLmRhdGFJZCAhPT0gb2xkTGF5ZXIuY29uZmlnLmRhdGFJZFxuICApIHtcbiAgICBjb25zdCB7ZGF0YUlkLCAuLi5yZXN0Q29uZmlnfSA9IGFjdGlvbi5uZXdDb25maWc7XG4gICAgY29uc3Qgc3RhdGVXaXRoRGF0YUlkID0gbGF5ZXJEYXRhSWRDaGFuZ2VVcGRhdGVyKHN0YXRlLCB7XG4gICAgICBvbGRMYXllcixcbiAgICAgIG5ld0NvbmZpZzoge2RhdGFJZH1cbiAgICB9KTtcbiAgICBjb25zdCBuZXh0TGF5ZXIgPSBzdGF0ZVdpdGhEYXRhSWQubGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG4gICAgcmV0dXJuIG5leHRMYXllciAmJiBPYmplY3Qua2V5cyhyZXN0Q29uZmlnKS5sZW5ndGhcbiAgICAgID8gbGF5ZXJDb25maWdDaGFuZ2VVcGRhdGVyKHN0YXRlV2l0aERhdGFJZCwge29sZExheWVyOiBuZXh0TGF5ZXIsIG5ld0NvbmZpZzogcmVzdENvbmZpZ30pXG4gICAgICA6IHN0YXRlV2l0aERhdGFJZDtcbiAgfVxuXG4gIGxldCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKGFjdGlvbi5uZXdDb25maWcpO1xuXG4gIGxldCBsYXllckRhdGE7XG5cbiAgaWYgKG5ld0xheWVyLnNob3VsZENhbGN1bGF0ZUxheWVyRGF0YShwcm9wcykpIHtcbiAgICBjb25zdCBvbGRMYXllckRhdGEgPSBzdGF0ZS5sYXllckRhdGFbaWR4XTtcblxuICAgIGNvbnN0IHVwZGF0ZUxheWVyRGF0YVJlc3VsdCA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgc3RhdGUsIG9sZExheWVyRGF0YSk7XG4gICAgbmV3TGF5ZXIgPSB1cGRhdGVMYXllckRhdGFSZXN1bHQubGF5ZXI7XG4gICAgbGF5ZXJEYXRhID0gdXBkYXRlTGF5ZXJEYXRhUmVzdWx0LmxheWVyRGF0YTtcbiAgfVxuXG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBpZiAoJ2lzVmlzaWJsZScgaW4gYWN0aW9uLm5ld0NvbmZpZykge1xuICAgIG5ld1N0YXRlID0gdXBkYXRlbGF5ZXJWaXNpYmlsdHkobmV3U3RhdGUsIG5ld0xheWVyLCBhY3Rpb24ubmV3Q29uZmlnLmlzVmlzaWJsZSk7XG4gIH1cblxuICBpZiAoJ2NvbHVtbnMnIGluIGFjdGlvbi5uZXdDb25maWcgJiYgbmV3TGF5ZXIuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkKSB7XG4gICAgLy8gVE9ETzogU2hhbiwgbWFrZSB0aGUgYW5pbWF0aW9uIGNvbmZpZyBmdW5jdGlvbiBtb3JlIHJvYnVzdFxuICAgIG5ld1N0YXRlID0gdXBkYXRlQW5pbWF0aW9uRG9tYWluKG5ld1N0YXRlKTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEobmV3U3RhdGUsIHtcbiAgICBsYXllcjogbmV3TGF5ZXIsXG4gICAgbGF5ZXJEYXRhLFxuICAgIGlkeFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxheWVyQW5pbWF0aW9uQ2hhbmdlVXBkYXRlcjxTIGV4dGVuZHMgVmlzU3RhdGU+KHN0YXRlOiBTLCBhY3Rpb24pOiBTIHtcbiAgY29uc3Qge29sZExheWVyLCBwcm9wLCB2YWx1ZX0gPSBhY3Rpb247XG4gIGNvbnN0IGlkeCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG5cbiAgY29uc3QgbmV3TGF5ZXIgPSBvbGRMYXllci51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAuLi5vbGRMYXllci5jb25maWcuYW5pbWF0aW9uLFxuICAgICAgW3Byb3BdOiB2YWx1ZVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBzdGF0ZSwgc3RhdGUubGF5ZXJEYXRhW2lkeF0pO1xuXG4gIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXJJZCwgaXNWaXNpYmxlLCBzcGxpdE1hcElkXG4gKiBoYW5kbGVzIHR3byBjYXNlczpcbiAqIDEpIHRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiBsb2NhbCBTcGxpdE1hcCBsYXllciAodmlzU3RhdGUuc3BsaXRNYXAubGF5ZXJzKVxuICogMikgdG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIGdsb2JhbCBsYXllciAodmlzU3RhdGUubGF5ZXJzKVxuXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclRvZ2dsZVZpc2liaWxpdHlVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxheWVyVG9nZ2xlVmlzaWJpbGl0eVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge2xheWVySWQsIGlzVmlzaWJsZSwgc3BsaXRNYXBJZH0gPSBhY3Rpb247XG4gIGNvbnN0IGxheWVyID0gc3RhdGUubGF5ZXJzLmZpbmQoZCA9PiBkLmlkID09PSBsYXllcklkKTtcblxuICBpZiAoIWxheWVyKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgbGV0IG5ld1N0YXRlID0gc3RhdGU7XG5cbiAgaWYgKHNwbGl0TWFwSWQpIHtcbiAgICAvLyBbY2FzZSAxXTogdG9nZ2xlIGxvY2FsIGxheWVyIHZpc2liaWxpdHkgZm9yIGVhY2ggU3BsaXRNYXBcbiAgICBjb25zdCBtYXBJbmRleCA9IG5ld1N0YXRlLnNwbGl0TWFwcy5maW5kSW5kZXgoc20gPT4gc20uaWQgPT09IHNwbGl0TWFwSWQpO1xuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgIC8vIDEpIGlmIHRoZSBsYXllciBpcyBpbnZpc2libGUgZ2xvYmFsbHlcbiAgICAgIC8vIC0+IHNldCBnbG9iYWwgdmlzaWJpbGl0eSB0byB0cnVlXG4gICAgICBuZXdTdGF0ZSA9IGxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlcihuZXdTdGF0ZSwgbGF5ZXJDb25maWdDaGFuZ2UobGF5ZXIsIHtpc1Zpc2libGU6IHRydWV9KSk7XG5cbiAgICAgIC8vIC0+IHNldCBsb2NhbCB2aXNpYmlsaXR5IHRvIHRydWUgYW5kIHRoZSBsb2NhbCB2aXNpYmlsaXRpZXMgb2YgYWxsIG90aGVyIFNwbGl0TWFwcyB0byBmYWxzZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgIHNwbGl0TWFwczogbmV3U3RhdGUuc3BsaXRNYXBzLm1hcChzbSA9PlxuICAgICAgICAgIHNtLmlkICE9PSBzcGxpdE1hcElkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAuLi5zbSxcbiAgICAgICAgICAgICAgICBsYXllcnM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnNtLmxheWVycyxcbiAgICAgICAgICAgICAgICAgIFtsYXllcklkXTogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIC4uLnNtLFxuICAgICAgICAgICAgICAgIGxheWVyczoge1xuICAgICAgICAgICAgICAgICAgLi4uc20ubGF5ZXJzLFxuICAgICAgICAgICAgICAgICAgW2xheWVySWRdOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIDIpIGVsc2Ugd2hlbiB0aGUgbGF5ZXIgaXMgdmlzaWJsZSBnbG9iYWxseVxuICAgIHJldHVybiB0b2dnbGVMYXllckZvck1hcFVwZGF0ZXIobmV3U3RhdGUsIHRvZ2dsZUxheWVyRm9yTWFwKG1hcEluZGV4LCBsYXllcklkKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gW2Nhc2UgMl06IHRvZ2dsZSBnbG9iYWwgbGF5ZXIgdmlzaWJpbGl0eVxuICAgIGNvbnN0IG5ld0xheWVyID0gbGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe2lzVmlzaWJsZX0pO1xuICAgIGNvbnN0IGlkeCA9IG5ld1N0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBsYXllcklkKTtcblxuICAgIG5ld1N0YXRlID0gdXBkYXRlbGF5ZXJWaXNpYmlsdHkobmV3U3RhdGUsIG5ld0xheWVyLCBpc1Zpc2libGUpO1xuICAgIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEobmV3U3RhdGUsIHtcbiAgICAgIGxheWVyOiBuZXdMYXllcixcbiAgICAgIGlkeFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBzdGF0ZVxuICogQHJldHVybnMgaW5kZXggb2YgdGhlIGZpbHRlciBzeW5jZWQgdG8gdGltZWxpbmUgb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmlsdGVyU3luY2VkV2l0aFRpbWVsaW5lKHN0YXRlOiBWaXNTdGF0ZSk6IG51bWJlciB7XG4gIHJldHVybiBzdGF0ZS5maWx0ZXJzLmZpbmRJbmRleChmID0+IChmIGFzIFRpbWVSYW5nZUZpbHRlcikuc3luY2VkV2l0aExheWVyVGltZWxpbmUpO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgaXNWYWxpZCBmbGFnIG9mIGEgbGF5ZXIuXG4gKiBVcGRhdGVzIGlzVmlzaWJsZSBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgaXNWYWxpZC5cbiAqIFRyaWdnZXJzIHVwZGF0ZSBvZiBkYXRhIGZvciB0aGUgbGF5ZXIgaW4gb3JkZXIgdG8gZ2V0IGVycm9ycyBhZ2FpbiBkdXJpbmcgbmV4dCB1cGRhdGUgaXRlcmF0aW9uLlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJTZXRJc1ZhbGlkVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5MYXllclNldElzVmFsaWRVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllciwgaXNWYWxpZH0gPSBhY3Rpb247XG5cbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcbiAgY29uc3QgbGF5ZXJUb1VwZGF0ZSA9IHN0YXRlLmxheWVyc1tpZHhdO1xuICBpZiAobGF5ZXJUb1VwZGF0ZSkge1xuICAgIGxldCBuZXdMYXllcjtcbiAgICBsZXQgbmV3RGF0YSA9IG51bGw7XG5cbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgLy8gVHJpZ2dlciBkYXRhIHVwZGF0ZSBpbiBvcmRlciB0byBzaG93IGVycm9ycyBhZ2FpbiBpZiBwcmVzZW50LlxuICAgICAgY29uc3Qge2xheWVyLCBsYXllckRhdGF9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKGxheWVyVG9VcGRhdGUsIHN0YXRlLCB1bmRlZmluZWQpO1xuICAgICAgbmV3TGF5ZXIgPSBsYXllcjtcbiAgICAgIG5ld0RhdGEgPSBsYXllckRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0xheWVyID0gbGF5ZXJUb1VwZGF0ZS51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgICAgIGlzVmlzaWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgbmV3TGF5ZXIuaXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtpZHgsIGxheWVyOiBuZXdMYXllciwgbGF5ZXJEYXRhOiBuZXdEYXRhfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGFkZE9yUmVtb3ZlVGV4dExhYmVscyhuZXdGaWVsZHMsIHRleHRMYWJlbCwgZGVmYXVsdFRleHRMYWJlbCA9IERFRkFVTFRfVEVYVF9MQUJFTCkge1xuICBsZXQgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLnNsaWNlKCk7XG5cbiAgY29uc3QgY3VycmVudEZpZWxkcyA9IHRleHRMYWJlbC5tYXAodGwgPT4gdGwuZmllbGQgJiYgdGwuZmllbGQubmFtZSkuZmlsdGVyKGQgPT4gZCk7XG5cbiAgY29uc3QgYWRkRmllbGRzID0gbmV3RmllbGRzLmZpbHRlcihmID0+ICFjdXJyZW50RmllbGRzLmluY2x1ZGVzKGYubmFtZSkpO1xuICBjb25zdCBkZWxldGVGaWVsZHMgPSBjdXJyZW50RmllbGRzLmZpbHRlcihmID0+ICFuZXdGaWVsZHMuZmluZChmZCA9PiBmZC5uYW1lID09PSBmKSk7XG5cbiAgLy8gZGVsZXRlXG4gIG5ld1RleHRMYWJlbCA9IG5ld1RleHRMYWJlbC5maWx0ZXIodGwgPT4gdGwuZmllbGQgJiYgIWRlbGV0ZUZpZWxkcy5pbmNsdWRlcyh0bC5maWVsZC5uYW1lKSk7XG4gIG5ld1RleHRMYWJlbCA9ICFuZXdUZXh0TGFiZWwubGVuZ3RoID8gW2RlZmF1bHRUZXh0TGFiZWxdIDogbmV3VGV4dExhYmVsO1xuXG4gIC8vIGFkZFxuICBuZXdUZXh0TGFiZWwgPSBbXG4gICAgLi4ubmV3VGV4dExhYmVsLmZpbHRlcih0bCA9PiB0bC5maWVsZCksXG4gICAgLi4uYWRkRmllbGRzLm1hcChhZiA9PiAoe1xuICAgICAgLi4uZGVmYXVsdFRleHRMYWJlbCxcbiAgICAgIGZpZWxkOiBhZlxuICAgIH0pKVxuICBdO1xuXG4gIHJldHVybiBuZXdUZXh0TGFiZWw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZShpZHgsIHByb3AsIHZhbHVlLCB0ZXh0TGFiZWwpIHtcbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGV4dExhYmVsW2lkeF0sIHByb3ApKSB7XG4gICAgcmV0dXJuIHRleHRMYWJlbDtcbiAgfVxuXG4gIGxldCBuZXdUZXh0TGFiZWwgPSB0ZXh0TGFiZWwuc2xpY2UoKTtcblxuICBpZiAocHJvcCA9PT0gJ2ZpZWxkJyAmJiB2YWx1ZSA9PT0gbnVsbCAmJiB0ZXh0TGFiZWwubGVuZ3RoID4gMSkge1xuICAgIC8vIHJlbW92ZSBsYWJlbCB3aGVuIGZpZWxkIHZhbHVlIGlzIHNldCB0byBudWxsXG4gICAgbmV3VGV4dExhYmVsLnNwbGljZShpZHgsIDEpO1xuICB9IGVsc2UgaWYgKHByb3ApIHtcbiAgICBuZXdUZXh0TGFiZWwgPSB0ZXh0TGFiZWwubWFwKCh0bCwgaSkgPT4gKGkgPT09IGlkeCA/IHsuLi50bCwgW3Byb3BdOiB2YWx1ZX0gOiB0bCkpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1RleHRMYWJlbDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgYmFzZSBjb25maWc6IGRhdGFJZCwgbGFiZWwsIGNvbHVtbiwgaXNWaXNpYmxlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclRleHRMYWJlbENoYW5nZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuTGF5ZXJUZXh0TGFiZWxDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllciwgaWR4LCBwcm9wLCB2YWx1ZX0gPSBhY3Rpb247XG4gIGNvbnN0IHt0ZXh0TGFiZWx9ID0gb2xkTGF5ZXIuY29uZmlnO1xuXG4gIC8vIHdoZW4gYWRkaW5nIGEgbmV3IGVtcHR5IHRleHQgbGFiZWwsXG4gIC8vIHJlbHkgb24gdGhlIGxheWVyJ3MgZGVmYXVsdCBjb25maWcsIG9yIHVzZSB0aGUgY29uc3RhbnQgREVGQVVMVF9URVhUX0xBQkVMXG4gIGNvbnN0IGRlZmF1bHRUZXh0TGFiZWwgPVxuICAgIG9sZExheWVyLmdldERlZmF1bHRMYXllckNvbmZpZyh7ZGF0YUlkOiAnJ30pPy50ZXh0TGFiZWw/LlswXSA/PyBERUZBVUxUX1RFWFRfTEFCRUw7XG5cbiAgbGV0IG5ld1RleHRMYWJlbCA9IHRleHRMYWJlbC5zbGljZSgpO1xuICBpZiAoIXRleHRMYWJlbFtpZHhdICYmIGlkeCA9PT0gdGV4dExhYmVsLmxlbmd0aCkge1xuICAgIC8vIGlmIGlkeCBpcyBzZXQgdG8gbGVuZ3RoLCBhZGQgZW1wdHkgdGV4dCBsYWJlbFxuICAgIG5ld1RleHRMYWJlbCA9IFsuLi50ZXh0TGFiZWwsIGRlZmF1bHRUZXh0TGFiZWxdO1xuICB9XG5cbiAgaWYgKGlkeCA9PT0gJ2FsbCcgJiYgcHJvcCA9PT0gJ2ZpZWxkcycpIHtcbiAgICBuZXdUZXh0TGFiZWwgPSBhZGRPclJlbW92ZVRleHRMYWJlbHModmFsdWUsIHRleHRMYWJlbCwgZGVmYXVsdFRleHRMYWJlbCk7XG4gIH0gZWxzZSB7XG4gICAgbmV3VGV4dExhYmVsID0gdXBkYXRlVGV4dExhYmVsUHJvcEFuZFZhbHVlKGlkeCwgcHJvcCwgdmFsdWUsIG5ld1RleHRMYWJlbCk7XG4gIH1cbiAgLy8gdXBkYXRlIHRleHQgbGFiZWwgcHJvcCBhbmQgdmFsdWVcbiAgcmV0dXJuIGxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlcihzdGF0ZSwge1xuICAgIG9sZExheWVyLFxuICAgIG5ld0NvbmZpZzoge3RleHRMYWJlbDogbmV3VGV4dExhYmVsfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFeGlzdGluZ0xheWVyV2l0aERhdGEoZGF0YXNldCwgbGF5ZXJDbGFzc2VzLCBsYXllciwgc2NoZW1hKSB7XG4gIGNvbnN0IGxvYWRlZExheWVyID0gc2VyaWFsaXplTGF5ZXIobGF5ZXIsIHNjaGVtYSk7XG4gIHJldHVybiBsb2FkZWRMYXllclxuICAgID8gdmFsaWRhdGVMYXllcldpdGhEYXRhKGRhdGFzZXQsIGxvYWRlZExheWVyLCBsYXllckNsYXNzZXMsIHtcbiAgICAgICAgYWxsb3dFbXB0eUNvbHVtbjogdHJ1ZVxuICAgICAgfSlcbiAgICA6IG51bGw7XG59XG5cbi8qKlxuICogVXBkYXRlIGxheWVyIGNvbmZpZyBkYXRhSWRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxheWVyRGF0YUlkQ2hhbmdlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IHtcbiAgICBvbGRMYXllcjogTGF5ZXI7XG4gICAgbmV3Q29uZmlnOiB7XG4gICAgICBkYXRhSWQ6IHN0cmluZztcbiAgICB9O1xuICB9XG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllciwgbmV3Q29uZmlnfSA9IGFjdGlvbjtcbiAgY29uc3Qge2RhdGFJZH0gPSBuZXdDb25maWc7XG5cbiAgaWYgKCFvbGRMYXllciB8fCAhc3RhdGUuZGF0YXNldHNbZGF0YUlkXSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuXG4gIGxldCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtkYXRhSWR9KTtcblxuICAvLyB0aGlzIG1heSBoYXBwZW4gd2hlbiBhIGxheWVyIGlzIG5ldyAodHlwZTogbnVsbCBhbmQgbm8gY29sdW1ucykgYnV0IGl0J3Mgbm90IHJlYWR5IHRvIGJlIHNhdmVkXG4gIGlmIChuZXdMYXllci5pc1ZhbGlkVG9TYXZlKCkpIHtcbiAgICBjb25zdCB2YWxpZGF0ZWQgPSB2YWxpZGF0ZUV4aXN0aW5nTGF5ZXJXaXRoRGF0YShcbiAgICAgIHN0YXRlLmRhdGFzZXRzW2RhdGFJZF0sXG4gICAgICBzdGF0ZS5sYXllckNsYXNzZXMsXG4gICAgICBuZXdMYXllcixcbiAgICAgIHN0YXRlLnNjaGVtYVxuICAgICk7XG4gICAgLy8gaWYgY2FudCB2YWxpZGF0ZSBpdCB3aXRoIGRhdGEgY3JlYXRlIGEgbmV3IG9uZVxuICAgIGlmICghdmFsaWRhdGVkKSB7XG4gICAgICBjb25zdCBvbGRMYXllclR5cGUgPSBvbGRMYXllci50eXBlO1xuICAgICAgaWYgKG9sZExheWVyVHlwZSkge1xuICAgICAgICBuZXdMYXllciA9IG5ldyBzdGF0ZS5sYXllckNsYXNzZXNbb2xkTGF5ZXJUeXBlXSh7ZGF0YUlkLCBpZDogb2xkTGF5ZXIuaWR9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3TGF5ZXIgPSB2YWxpZGF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgbmV3TGF5ZXIgPSBuZXdMYXllci51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgaXNWaXNpYmxlOiBvbGRMYXllci5jb25maWcuaXNWaXNpYmxlLFxuICAgIGlzQ29uZmlnQWN0aXZlOiB0cnVlXG4gIH0pO1xuXG4gIG5ld0xheWVyLnVwZGF0ZUxheWVyRG9tYWluKHN0YXRlLmRhdGFzZXRzKTtcbiAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBzdGF0ZSwgdW5kZWZpbmVkKTtcblxuICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKHN0YXRlLCB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRJbml0aWFsTGF5ZXJDb25maWcobGF5ZXIsIGRhdGFzZXRzLCBsYXllckNsYXNzZXMpOiBMYXllciB7XG4gIGxldCBuZXdMYXllciA9IGxheWVyO1xuICBpZiAoIU9iamVjdC5rZXlzKGRhdGFzZXRzKS5sZW5ndGgpIHtcbiAgICAvLyBubyBkYXRhIGlzIGxvYWRlZFxuICAgIHJldHVybiBsYXllcjtcbiAgfVxuICBpZiAoIWxheWVyLmNvbmZpZy5kYXRhSWQpIHtcbiAgICAvLyBzZXQgbGF5ZXIgZGF0YUlkXG4gICAgbmV3TGF5ZXIgPSBsYXllci51cGRhdGVMYXllckNvbmZpZyh7ZGF0YUlkOiBPYmplY3Qua2V5cyhkYXRhc2V0cylbMF19KTtcbiAgfVxuICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbbmV3TGF5ZXIuY29uZmlnLmRhdGFJZF07XG4gIGlmICghZGF0YXNldCkge1xuICAgIHJldHVybiBsYXllcjtcbiAgfVxuXG4gIC8vIGZpbmQgZGVmYXV0IGxheWVyIHByb3BzXG4gIGNvbnN0IHJlc3VsdCA9XG4gICAgdHlwZW9mIGxheWVyQ2xhc3Nlc1tuZXdMYXllci50eXBlXS5maW5kRGVmYXVsdExheWVyUHJvcHMgPT09ICdmdW5jdGlvbidcbiAgICAgID8gbGF5ZXJDbGFzc2VzW25ld0xheWVyLnR5cGVdLmZpbmREZWZhdWx0TGF5ZXJQcm9wcyhkYXRhc2V0LCBbXSlcbiAgICAgIDoge3Byb3BzOiBbXX07XG5cbiAgLy8gYW4gYXJyYXkgb2YgcG9zc2libGUgcHJvcHMsIHVzZSAxc3Qgb25lXG4gIGNvbnN0IHByb3BzID0gQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0IDogcmVzdWx0LnByb3BzIHx8IFtdO1xuXG4gIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICBuZXdMYXllciA9IG5ldyBsYXllckNsYXNzZXNbbGF5ZXIudHlwZV0oe1xuICAgICAgLi4ucHJvcHNbMF0sXG4gICAgICBsYWJlbDogbmV3TGF5ZXIuY29uZmlnLmxhYmVsLFxuICAgICAgZGF0YUlkOiBuZXdMYXllci5jb25maWcuZGF0YUlkLFxuICAgICAgaXNDb25maWdBY3RpdmU6IG5ld0xheWVyLmNvbmZpZy5pc0NvbmZpZ0FjdGl2ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0eXBlb2YgbmV3TGF5ZXIuc2V0SW5pdGlhbExheWVyQ29uZmlnID09PSAnZnVuY3Rpb24nXG4gICAgPyBuZXdMYXllci5zZXRJbml0aWFsTGF5ZXJDb25maWcoZGF0YXNldClcbiAgICA6IG5ld0xheWVyO1xufVxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgdHlwZS4gUHJldmlld3MgbGF5ZXIgY29uZmlnIHdpbGwgYmUgY29waWVkIGlmIGFwcGxpY2FibGUuXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJUeXBlQ2hhbmdlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5MYXllclR5cGVDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllciwgbmV3VHlwZX0gPSBhY3Rpb247XG4gIGlmICghb2xkTGF5ZXIpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3Qgb2xkSWQgPSBvbGRMYXllci5pZDtcbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZElkKTtcblxuICBpZiAoIXN0YXRlLmxheWVyQ2xhc3Nlc1tuZXdUeXBlXSkge1xuICAgIENvbnNvbGUuZXJyb3IoYCR7bmV3VHlwZX0gaXMgbm90IGEgdmFsaWQgbGF5ZXIgdHlwZWApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBsZXQgbmV3TGF5ZXIgPSBuZXcgc3RhdGUubGF5ZXJDbGFzc2VzW25ld1R5cGVdKHtcbiAgICAvLyBrZWVwIG9sZCBsYXllciBsYWJsZSBhbmQgaXNDb25maWdBY3RpdmVcbiAgICBsYWJlbDogb2xkTGF5ZXIuY29uZmlnLmxhYmVsLFxuICAgIGlzQ29uZmlnQWN0aXZlOiBvbGRMYXllci5jb25maWcuaXNDb25maWdBY3RpdmUsXG4gICAgZGF0YUlkOiBvbGRMYXllci5jb25maWcuZGF0YUlkXG4gIH0pO1xuXG4gIGlmICghb2xkTGF5ZXIudHlwZSkge1xuICAgIC8vIGlmIHNldHRpbmcgbGF5ZXIgdHlwZSBvbiBhbiBlbXB0eSBsYXllclxuICAgIG5ld0xheWVyID0gc2V0SW5pdGlhbExheWVyQ29uZmlnKG5ld0xheWVyLCBzdGF0ZS5kYXRhc2V0cywgc3RhdGUubGF5ZXJDbGFzc2VzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBnZXQgYSBtaW50IGxheWVyLCB3aXRoIG5ldyBpZCBhbmQgdHlwZVxuICAgIC8vIGJlY2F1c2UgZGVjay5nbCB1c2VzIGlkIHRvIG1hdGNoIGJldHdlZW4gbmV3IGFuZCBvbGQgbGF5ZXIuXG4gICAgLy8gSWYgdHlwZSBoYXMgY2hhbmdlZCBidXQgaWQgaXMgdGhlIHNhbWUsIGl0IHdpbGwgYnJlYWtcblxuICAgIGNvbnN0IGRlZmF1bHRMYXllclByb3BzID1cbiAgICAgIHR5cGVvZiBzdGF0ZS5sYXllckNsYXNzZXNbbmV3VHlwZV0uZmluZERlZmF1bHRMYXllclByb3BzID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gc3RhdGUubGF5ZXJDbGFzc2VzW25ld1R5cGVdLmZpbmREZWZhdWx0TGF5ZXJQcm9wcyhzdGF0ZS5kYXRhc2V0c1tuZXdMYXllci5jb25maWcuZGF0YUlkXSlcbiAgICAgICAgOiBudWxsO1xuXG4gICAgbmV3TGF5ZXIuYXNzaWduQ29uZmlnVG9MYXllcihcbiAgICAgIG9sZExheWVyLmNvbmZpZyxcbiAgICAgIG9sZExheWVyLnZpc0NvbmZpZ1NldHRpbmdzLFxuICAgICAgc3RhdGUuZGF0YXNldHMsXG4gICAgICBkZWZhdWx0TGF5ZXJQcm9wc1xuICAgICk7XG4gICAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJEb21haW4oc3RhdGUuZGF0YXNldHMpO1xuICB9XG5cbiAgY29uc3Qge2NsaWNrZWQsIGhvdmVySW5mb30gPSBzdGF0ZTtcblxuICBsZXQgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgY2xpY2tlZDogb2xkTGF5ZXIuaXNMYXllckhvdmVyZWQoY2xpY2tlZCkgPyB1bmRlZmluZWQgOiBjbGlja2VkLFxuICAgIGhvdmVySW5mbzogb2xkTGF5ZXIuaXNMYXllckhvdmVyZWQoaG92ZXJJbmZvKSA/IHVuZGVmaW5lZCA6IGhvdmVySW5mb1xuICB9O1xuXG4gIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgbmV3U3RhdGUpO1xuICBuZXdTdGF0ZSA9IHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShuZXdTdGF0ZSwge2xheWVyRGF0YSwgbGF5ZXIsIGlkeH0pO1xuXG4gIGlmIChsYXllci5jb25maWcuYW5pbWF0aW9uLmVuYWJsZWQgfHwgb2xkTGF5ZXIuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkKSB7XG4gICAgbmV3U3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4obmV3U3RhdGUpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHNwbGl0TWFwIGxheWVyIGlkXG4gIGlmIChzdGF0ZS5zcGxpdE1hcHMubGVuZ3RoKSB7XG4gICAgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgIHNwbGl0TWFwczogbmV3U3RhdGUuc3BsaXRNYXBzLm1hcChzZXR0aW5ncyA9PiB7XG4gICAgICAgIGNvbnN0IHtbb2xkSWRdOiBvbGRMYXllck1hcCwgLi4ub3RoZXJMYXllcnN9ID0gc2V0dGluZ3MubGF5ZXJzO1xuICAgICAgICByZXR1cm4gb2xkSWQgaW4gc2V0dGluZ3MubGF5ZXJzXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICAgICAgICBsYXllcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5vdGhlckxheWVycyxcbiAgICAgICAgICAgICAgICBbbGF5ZXIuaWRdOiBvbGRMYXllck1hcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBzZXR0aW5ncztcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsYXllck9yZGVyIHdpdGggbmV3IGlkXG4gIG5ld1N0YXRlID0ge1xuICAgIC4uLm5ld1N0YXRlLFxuICAgIGxheWVyT3JkZXI6IG5ld1N0YXRlLmxheWVyT3JkZXIubWFwKGxheWVySWQgPT5cbiAgICAgIGxheWVySWQgPT09IG9sZExheWVyLmlkID8gbmV3TGF5ZXIuaWQgOiBsYXllcklkXG4gICAgKVxuICB9O1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgdmlzdWFsIGNoYW5uZWxcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxheWVyVmlzdWFsQ2hhbm5lbENoYW5nZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuTGF5ZXJWaXN1YWxDaGFubmVsQ29uZmlnQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7b2xkTGF5ZXIsIG5ld0NvbmZpZywgbmV3VmlzQ29uZmlnLCBjaGFubmVsfSA9IGFjdGlvbjtcbiAgaWYgKCFvbGRMYXllci5jb25maWcuZGF0YUlkKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW29sZExheWVyLmNvbmZpZy5kYXRhSWRdO1xuXG4gIGNvbnN0IGlkeCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG4gIGxldCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKG5ld0NvbmZpZyk7XG4gIGlmIChuZXdWaXNDb25maWcpIG5ld0xheWVyID0gbmV3TGF5ZXIudXBkYXRlTGF5ZXJWaXNDb25maWcobmV3VmlzQ29uZmlnKTtcblxuICBuZXdMYXllci51cGRhdGVMYXllclZpc3VhbENoYW5uZWwoZGF0YXNldCwgY2hhbm5lbCk7XG5cbiAgLy8gY2FsbGluZyB1cGRhdGUgYW5pbWF0aW9uIGRvbWFpbiBmaXJzdCB0byBtZXJnZSBhbGwgbGF5ZXIgYW5pbWF0aW9uIGRvbWFpblxuICBsZXQgdXBkYXRlZFN0YXRlID0gdXBkYXRlQW5pbWF0aW9uRG9tYWluKHN0YXRlKTtcblxuICBjb25zdCB2aXN1YWxDaGFubmVsID0gb2xkTGF5ZXIudmlzdWFsQ2hhbm5lbHNbY2hhbm5lbF07XG4gIGlmICh2aXN1YWxDaGFubmVsPy5jaGFubmVsU2NhbGVUeXBlID09PSBDSEFOTkVMX1NDQUxFUy5jb2xvciAmJiBuZXdDb25maWdbdmlzdWFsQ2hhbm5lbC5maWVsZF0pIHtcbiAgICAvLyBpZiBjb2xvciBmaWVsZCBjaGFuZ2VkLCBzZXQgY3VzdG9tQnJlYWtzIHRvIGZhbHNlXG4gICAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJDb2xvclVJKHZpc3VhbENoYW5uZWwucmFuZ2UsIHtcbiAgICAgIGNvbG9yUmFuZ2VDb25maWc6IHtcbiAgICAgICAgLi4ubmV3TGF5ZXIuY29uZmlnLmNvbG9yVUlbdmlzdWFsQ2hhbm5lbC5yYW5nZV0uY29sb3JSYW5nZUNvbmZpZyxcbiAgICAgICAgY3VzdG9tQnJlYWtzOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdXBkYXRlZFN0YXRlID0ge1xuICAgICAgLi4udXBkYXRlZFN0YXRlLFxuICAgICAgbGF5ZXJzOiB1cGRhdGVkU3RhdGUubGF5ZXJzLm1hcChsID0+IChsLmlkID09PSBvbGRMYXllci5pZCA/IG5ld0xheWVyIDogbCkpXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IG9sZExheWVyRGF0YSA9IHVwZGF0ZWRTdGF0ZS5sYXllckRhdGFbaWR4XTtcbiAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCB1cGRhdGVkU3RhdGUsIG9sZExheWVyRGF0YSk7XG5cbiAgaWYgKFxuICAgIHZpc3VhbENoYW5uZWw/LmNoYW5uZWxTY2FsZVR5cGUgPT09IENIQU5ORUxfU0NBTEVTLmNvbG9yICYmXG4gICAgbmV3Q29uZmlnW3Zpc3VhbENoYW5uZWw/LnNjYWxlXSA9PT0gU0NBTEVfVFlQRVMuY3VzdG9tT3JkaW5hbCAmJlxuICAgICFuZXdWaXNDb25maWdcbiAgKSB7XG4gICAgLy8gd2hlbiBzd2l0Y2hpbmcgdG8gY3VzdG9tT3JkaW5hbCBzY2FsZSwgY3JlYXRlIGEgY3VzdG9tUGFsZXR0ZSBpbiBjb2xvclVJIHdpdGggdXBkYXRlZCBjb2xvckRvbWFpblxuICAgIGNvbnN0IGN1c3RvbVBhbGV0dGUgPSBpbml0Q3VzdG9tUGFsZXR0ZUJ5Q3VzdG9tU2NhbGUoe1xuICAgICAgc2NhbGU6IFNDQUxFX1RZUEVTLmN1c3RvbU9yZGluYWwsXG4gICAgICBmaWVsZDogbGF5ZXIuY29uZmlnW3Zpc3VhbENoYW5uZWwuZmllbGRdLFxuICAgICAgb3JkaW5hbERvbWFpbjogbGF5ZXIuY29uZmlnW2xheWVyLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdLmRvbWFpbl0sXG4gICAgICByYW5nZTogbGF5ZXIuY29uZmlnLnZpc0NvbmZpZ1t2aXN1YWxDaGFubmVsLnJhbmdlXSxcbiAgICAgIGNvbG9yQnJlYWtzOiBudWxsXG4gICAgfSk7XG4gICAgLy8gdXBkYXRlIGNvbG9yUmFuZ2Ugd2l0aCBuZXcgY3VzdG9tUGFsZXR0ZVxuICAgIGxheWVyLnVwZGF0ZUxheWVyQ29sb3JVSSh2aXN1YWxDaGFubmVsLnJhbmdlLCB7XG4gICAgICBzaG93Q29sb3JDaGFydDogdHJ1ZSxcbiAgICAgIGNvbG9yUmFuZ2VDb25maWc6IHtcbiAgICAgICAgLi4ubGF5ZXIuY29uZmlnLmNvbG9yVUlbdmlzdWFsQ2hhbm5lbC5yYW5nZV0uY29sb3JSYW5nZUNvbmZpZyxcbiAgICAgICAgY3VzdG9tQnJlYWtzOiB0cnVlXG4gICAgICB9LFxuICAgICAgY3VzdG9tUGFsZXR0ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEodXBkYXRlZFN0YXRlLCB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGxheWVyIGB2aXNDb25maWdgXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJWaXNDb25maWdDaGFuZ2VVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxheWVyVmlzQ29uZmlnQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7b2xkTGF5ZXJ9ID0gYWN0aW9uO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKGFjdGlvbi5uZXdWaXNDb25maWcpO1xuXG4gIGNvbnN0IG5ld1Zpc0NvbmZpZyA9IHtcbiAgICAuLi5vbGRMYXllci5jb25maWcudmlzQ29uZmlnLFxuICAgIC4uLmFjdGlvbi5uZXdWaXNDb25maWdcbiAgfTtcblxuICBjb25zdCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHt2aXNDb25maWc6IG5ld1Zpc0NvbmZpZ30pO1xuXG4gIGlmIChuZXdMYXllci5zaG91bGRDYWxjdWxhdGVMYXllckRhdGEocHJvcHMpKSB7XG4gICAgY29uc3Qgb2xkTGF5ZXJEYXRhID0gc3RhdGUubGF5ZXJEYXRhW2lkeF07XG4gICAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBzdGF0ZSwgb2xkTGF5ZXJEYXRhKTtcbiAgICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKHN0YXRlLCB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fSk7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKHN0YXRlLCB7bGF5ZXI6IG5ld0xheWVyLCBpZHh9KTtcbn1cblxuLyoqXG4gKiBSZXNldCBhbmltYXRpb24gY29uZmlnIGN1cnJlbnQgdGltZSB0byBhIHNwZWNpZmllZCB2YWx1ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRMYXllckFuaW1hdGlvblRpbWVVcGRhdGVyID0gPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICB7dmFsdWV9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0TGF5ZXJBbmltYXRpb25UaW1lVXBkYXRlckFjdGlvblxuKTogUyA9PiB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVswXSA6IHZhbHVlO1xuICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgICAuLi5zdGF0ZS5hbmltYXRpb25Db25maWcsXG4gICAgICBjdXJyZW50VGltZVxuICAgIH1cbiAgfTtcbiAgLy8gdXBkYXRlIGFuaW1hdGlvbiBjb25maWcgZm9yIGVhY2ggbGF5ZXJcbiAgcmV0dXJuIHN0YXRlLmxheWVycy5yZWR1Y2UoKGFjY3UsIGwpID0+IHtcbiAgICBpZiAobC5jb25maWcuYW5pbWF0aW9uLmVuYWJsZWQgJiYgbC50eXBlICE9PSAndHJpcCcpIHtcbiAgICAgIHJldHVybiBsYXllckFuaW1hdGlvbkNoYW5nZVVwZGF0ZXIoYWNjdSwge29sZExheWVyOiBsLCBwcm9wOiAnY3VycmVudFRpbWUnLCBjdXJyZW50VGltZX0pO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdTtcbiAgfSwgbmV4dFN0YXRlKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGZpbHRlciBwcm9wZXJ0eVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZpbHRlckFuaW1hdGlvblRpbWVVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlNldEZpbHRlckFuaW1hdGlvblRpbWVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKHN0YXRlLCBhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBmaWx0ZXIgYW5pbWF0aW9uIHdpbmRvd1xuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZpbHRlckFuaW1hdGlvbldpbmRvd1VwZGF0ZXI8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIHtpZCwgYW5pbWF0aW9uV2luZG93fTogVmlzU3RhdGVBY3Rpb25zLlNldEZpbHRlckFuaW1hdGlvbldpbmRvd1VwZGF0ZXJBY3Rpb25cbik6IFMge1xuICBjb25zdCBmaWx0ZXIgPSBzdGF0ZS5maWx0ZXJzLmZpbmQoZiA9PiBmLmlkID09PSBpZCk7XG5cbiAgaWYgKCFmaWx0ZXIpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBuZXdGaWx0ZXIgPSB7XG4gICAgLi4uZmlsdGVyLFxuICAgIGFuaW1hdGlvbldpbmRvd1xuICB9O1xuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGZpbHRlcnM6IHN3YXBfPEZpbHRlcj4obmV3RmlsdGVyKShzdGF0ZS5maWx0ZXJzKVxuICB9O1xuXG4gIGNvbnN0IG5ld1N5bmNUaW1lbGluZU1vZGUgPSBnZXRTeW5jQW5pbWF0aW9uTW9kZShuZXdGaWx0ZXIgYXMgVGltZVJhbmdlRmlsdGVyKTtcblxuICByZXR1cm4gc2V0VGltZUZpbHRlclRpbWVsaW5lTW9kZVVwZGF0ZXIobmV3U3RhdGUsIHtpZCwgbW9kZTogbmV3U3luY1RpbWVsaW5lTW9kZX0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlGaWx0ZXJDb25maWdVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkFwcGx5RmlsdGVyQ29uZmlnVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7ZmlsdGVySWQsIG5ld0ZpbHRlcn0gPSBhY3Rpb247XG4gIGNvbnN0IG9sZEZpbHRlciA9IHN0YXRlLmZpbHRlcnMuZmluZChmID0+IGYuaWQgPT09IGZpbHRlcklkKTtcbiAgaWYgKCFvbGRGaWx0ZXIpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvLyBTZXJpYWxpemUgdGhlIGZpbHRlcnMgdG8gb25seSBjb21wYXJlIHRoZSBzYXZlZCBwcm9wZXJ0aWVzXG4gIGNvbnN0IHNlcmlhbGl6ZWRPbGRGaWx0ZXIgPSBzZXJpYWxpemVGaWx0ZXIob2xkRmlsdGVyLCBzdGF0ZS5zY2hlbWEpID8/IHtjb25maWc6IHt9fTtcbiAgY29uc3Qgc2VyaWFsaXplZE5ld0ZpbHRlciA9IHNlcmlhbGl6ZUZpbHRlcihuZXdGaWx0ZXIsIHN0YXRlLnNjaGVtYSk7XG4gIGlmICghc2VyaWFsaXplZE5ld0ZpbHRlciB8fCBpc0VxdWFsKHNlcmlhbGl6ZWRPbGRGaWx0ZXIsIHNlcmlhbGl6ZWROZXdGaWx0ZXIpKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBjaGFuZ2VzIHRvIHRoZSBmaWx0ZXIsIGFwcGx5IHRoZW1cbiAgY29uc3QgY2hhbmdlZCA9IHBpY2tDaGFuZ2VkUHJvcHMoc2VyaWFsaXplZE9sZEZpbHRlciwgc2VyaWFsaXplZE5ld0ZpbHRlcik7XG4gIGRlbGV0ZSBjaGFuZ2VkWydpZCddOyAvLyBpZCBzaG91bGQgbm90IGJlIGNoYW5nZWRcblxuICBjb25zdCBmaWx0ZXJJbmRleCA9IHN0YXRlLmZpbHRlcnMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gZmlsdGVySWQpO1xuICBpZiAoZmlsdGVySW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKFxuICAgIHN0YXRlLFxuICAgIHNldEZpbHRlcihmaWx0ZXJJbmRleCwgT2JqZWN0LmtleXMoY2hhbmdlZCksIE9iamVjdC52YWx1ZXMoY2hhbmdlZCkpXG4gICk7XG59XG5cbi8qKlxuICogVXBkYXRlIGZpbHRlciBwcm9wZXJ0eVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZpbHRlclVwZGF0ZXI8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlNldEZpbHRlclVwZGF0ZXJBY3Rpb25cbik6IFMge1xuICBjb25zdCB7aWR4LCB2YWx1ZUluZGV4ID0gMH0gPSBhY3Rpb247XG4gIGNvbnN0IG9sZEZpbHRlciA9IHN0YXRlLmZpbHRlcnNbaWR4XTtcbiAgaWYgKCFvbGRGaWx0ZXIpIHtcbiAgICBDb25zb2xlLmVycm9yKGBmaWx0ZXJzLiR7aWR4fSBpcyB1bmRlZmluZWRgKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKFxuICAgIEFycmF5LmlzQXJyYXkoYWN0aW9uLnByb3ApICYmXG4gICAgKCFBcnJheS5pc0FycmF5KGFjdGlvbi52YWx1ZSkgfHwgYWN0aW9uLnByb3AubGVuZ3RoICE9PSBhY3Rpb24udmFsdWUubGVuZ3RoKVxuICApIHtcbiAgICBDb25zb2xlLmVycm9yKCdFeHBlY3RpbmcgdmFsdWUgdG8gYmUgYW4gYXJyYXkgb2YgdGhlIHNhbWUgbGVuZ3RoLCBzaW5jZSBwcm9wIGlzIGFuIGFycmF5Jyk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIC8vIGNvbnZlcnQgcHJvcCBhbmQgdmFsdWUgdG8gYXJyYXlcbiAgY29uc3QgcHJvcHMgPSB0b0FycmF5KGFjdGlvbi5wcm9wKTtcbiAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheShhY3Rpb24ucHJvcCkgPyB0b0FycmF5KGFjdGlvbi52YWx1ZSkgOiBbYWN0aW9uLnZhbHVlXTtcblxuICBsZXQgbmV3RmlsdGVyID0gb2xkRmlsdGVyO1xuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcblxuICBsZXQgZGF0YXNldElkc1RvRmlsdGVyOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgIC8vIFdlIGN1cnJlbnRseSBkbyBub3Qgc3VwcG9ydCBwYXNzaW5nIGluIG5hbWUgYXMgYW4gYXJyYXkgaW50byBfdXBkYXRlRmlsdGVyUHJvcCwgc28gd2UgY2FsbCBpdCBtdWx0aXBsZSB0aW1lcyB3aXRoIGVhY2ggbmFtZVxuICAgIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGVyZSBhcyB0byB3aGF0IHNob3VsZCBiZSBhZGRyZXNzZWRcbiAgICBsZXQgcmVzO1xuICAgIGlmIChwcm9wID09PSAnbmFtZScgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIHJlcyA9IHZhbHVlLnJlZHVjZSgoYWNjdSwgdikgPT4ge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUZpbHRlclByb3AoYWNjdSwgbmV3RmlsdGVyLCBwcm9wLCB2LCB2YWx1ZUluZGV4KTtcbiAgICAgIH0sIG5ld1N0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gX3VwZGF0ZUZpbHRlclByb3AobmV3U3RhdGUsIG5ld0ZpbHRlciwgcHJvcCwgdmFsdWUsIHZhbHVlSW5kZXgpO1xuICAgIH1cbiAgICBuZXdGaWx0ZXIgPSByZXMuZmlsdGVyO1xuICAgIG5ld1N0YXRlID0gcmVzLnN0YXRlO1xuICAgIGRhdGFzZXRJZHNUb0ZpbHRlciA9IGRhdGFzZXRJZHNUb0ZpbHRlci5jb25jYXQocmVzLmRhdGFzZXRJZHNUb0ZpbHRlcik7XG4gIH1cblxuICBjb25zdCBlbmxhcmdlZEZpbHRlciA9IHN0YXRlLmZpbHRlcnMuZmluZChmID0+IGYudmlldyA9PT0gRklMVEVSX1ZJRVdfVFlQRVMuZW5sYXJnZWQpO1xuXG4gIGlmIChlbmxhcmdlZEZpbHRlciAmJiBlbmxhcmdlZEZpbHRlci5pZCAhPT0gbmV3RmlsdGVyLmlkKSB7XG4gICAgLy8gdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGVubGFyZ2VkIGZpbHRlclxuICAgIG5ld0ZpbHRlci52aWV3ID0gRklMVEVSX1ZJRVdfVFlQRVMuc2lkZTtcbiAgfVxuXG4gIC8vIHNhdmUgbmV3IGZpbHRlcnMgdG8gbmV3U3RhdGVcbiAgbmV3U3RhdGUgPSBzZXQoWydmaWx0ZXJzJywgaWR4XSwgbmV3RmlsdGVyLCBuZXdTdGF0ZSk7XG5cbiAgLy8gZmlsdGVyIGRhdGFcbiAgY29uc3QgZmlsdGVyZWREYXRhc2V0cyA9IGFwcGx5RmlsdGVyc1RvRGF0YXNldHMoXG4gICAgdW5pcShkYXRhc2V0SWRzVG9GaWx0ZXIpLFxuICAgIG5ld1N0YXRlLmRhdGFzZXRzLFxuICAgIG5ld1N0YXRlLmZpbHRlcnMsXG4gICAgbmV3U3RhdGUubGF5ZXJzXG4gICk7XG5cbiAgbmV3U3RhdGUgPSBzZXQoWydkYXRhc2V0cyddLCBmaWx0ZXJlZERhdGFzZXRzLCBuZXdTdGF0ZSk7XG5cbiAgLy8gbmVlZCB0byB1cGRhdGUgZmlsdGVyUGxvdCBhZnRlciBmaWx0ZXIgRGF0YXNldCBmb3IgcGxvdCB0byB1cGRhdGUgb24gZmlsdGVyZWQgcmVzdWx0XG4gIGNvbnN0IGZpbHRlcldpdGhQTG90ID0gdXBkYXRlRmlsdGVyUGxvdChuZXdTdGF0ZS5kYXRhc2V0cywgbmV3U3RhdGUuZmlsdGVyc1tpZHhdKTtcblxuICBuZXdTdGF0ZSA9IHNldChbJ2ZpbHRlcnMnLCBpZHhdLCBmaWx0ZXJXaXRoUExvdCwgbmV3U3RhdGUpO1xuXG4gIC8vIGRhdGFJZCBpcyBhbiBhcnJheVxuICAvLyBwYXNzIG9ubHkgdGhlIGRhdGFzZXQgd2UgbmVlZCB0byB1cGRhdGVcbiAgbmV3U3RhdGUgPSB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEobmV3U3RhdGUsIGRhdGFzZXRJZHNUb0ZpbHRlciwgbmV3RmlsdGVyKTtcblxuICAvLyBJZiB0aW1lIHJhbmdlIGZpbHRlciB2YWx1ZSB3YXMgdXBkYXRlZCwgYWRqdXN0IGFuaW1hdGlvbiBjb25maWdcbiAgaWYgKG5ld0ZpbHRlci50eXBlID09PSBGSUxURVJfVFlQRVMudGltZVJhbmdlICYmIHByb3BzLmluY2x1ZGVzKCd2YWx1ZScpKSB7XG4gICAgbmV3U3RhdGUgPSBhZGp1c3RBbmltYXRpb25Db25maWdXaXRoRmlsdGVyKG5ld1N0YXRlLCBhY3Rpb24uaWR4KTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuZnVuY3Rpb24gX3VwZGF0ZUZpbHRlckRhdGFJZEF0VmFsdWVJbmRleChmaWx0ZXIsIHZhbHVlSW5kZXgsIHZhbHVlLCBkYXRhc2V0cykge1xuICBsZXQgbmV3RmlsdGVyID0gZmlsdGVyO1xuICBpZiAoZmlsdGVyLmRhdGFJZFt2YWx1ZUluZGV4XSkge1xuICAgIC8vIGlmIGRhdGFJZCBhbHJlYWR5IGV4aXN0XG4gICAgbmV3RmlsdGVyID0gX3JlbW92ZUZpbHRlckRhdGFJZEF0VmFsdWVJbmRleChmaWx0ZXIsIHZhbHVlSW5kZXgsIGRhdGFzZXRzKTtcbiAgfVxuICBpZiAodmFsdWUpIHtcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBuZXdGaWx0ZXIuZGF0YUlkLnNsaWNlKCk7XG4gICAgbmV4dFZhbHVlW3ZhbHVlSW5kZXhdID0gdmFsdWU7XG4gICAgbmV3RmlsdGVyID0gc2V0KFsnZGF0YUlkJ10sIG5leHRWYWx1ZSwgbmV3RmlsdGVyKTtcbiAgfVxuICByZXR1cm4gbmV3RmlsdGVyO1xufVxuXG5mdW5jdGlvbiBfcmVtb3ZlRmlsdGVyRGF0YUlkQXRWYWx1ZUluZGV4KGZpbHRlciwgdmFsdWVJbmRleCwgZGF0YXNldHMpIHtcbiAgY29uc3QgZGF0YUlkID0gZmlsdGVyLmRhdGFJZFt2YWx1ZUluZGV4XTtcblxuICBpZiAoZmlsdGVyLmRhdGFJZC5sZW5ndGggPT09IDEgJiYgdmFsdWVJbmRleCA9PT0gMCkge1xuICAgIC8vIGlmIHJlbW92ZSB0aGUgb25seSBkYXRhSWQsIGNyZWF0ZSBhbiBlbXB0eSBmaWx0ZXIgaW5zdGVhZDtcbiAgICByZXR1cm4gZ2V0RGVmYXVsdEZpbHRlcih7aWQ6IGZpbHRlci5pZH0pO1xuICB9XG5cbiAgaWYgKGRhdGFJZCkge1xuICAgIGZpbHRlciA9IHJlbW92ZUZpbHRlclBsb3QoZmlsdGVyLCBkYXRhSWQpO1xuICB9XG5cbiAgZm9yIChjb25zdCBwcm9wIG9mIFsnZGF0YUlkJywgJ25hbWUnLCAnZmllbGRJZHgnLCAnZ3B1Q2hhbm5lbCddKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyW3Byb3BdKSkge1xuICAgICAgY29uc3QgbmV4dFZhbCA9IGZpbHRlcltwcm9wXS5zbGljZSgpO1xuICAgICAgbmV4dFZhbC5zcGxpY2UodmFsdWVJbmRleCwgMSk7XG4gICAgICBmaWx0ZXIgPSBzZXQoW3Byb3BdLCBuZXh0VmFsLCBmaWx0ZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1lcmdlRmllbGREb21haW4gZm9yIHRoZSByZW1haW5pbmcgZmllbGRzXG4gIGNvbnN0IGRvbWFpblN0ZXBzID0gbWVyZ2VGaWx0ZXJEb21haW4oZmlsdGVyLCBkYXRhc2V0cyk7XG5cbiAgY29uc3QgbmV4dEZpbHRlciA9IHtcbiAgICAuLi5maWx0ZXIsXG4gICAgLy8gdmFsdWU6IG5leHRWYWx1ZSxcbiAgICAuLi4oZG9tYWluU3RlcHMgPyB7ZG9tYWluOiBkb21haW5TdGVwcz8uZG9tYWluLCBzdGVwOiBkb21haW5TdGVwcz8uc3RlcH0gOiB7fSlcbiAgfTtcblxuICBjb25zdCBuZXh0VmFsdWUgPSBhZGp1c3RWYWx1ZVRvRmlsdGVyRG9tYWluKG5leHRGaWx0ZXIudmFsdWUsIG5leHRGaWx0ZXIpO1xuICByZXR1cm4ge1xuICAgIC4uLm5leHRGaWx0ZXIsXG4gICAgdmFsdWU6IG5leHRWYWx1ZVxuICB9O1xufVxuXG4vKiogKlxuICogVXBkYXRlcyBhIHNpbmdsZSBwcm9wZXJ0eSBvZiBhIGZpbHRlclxuICovXG5mdW5jdGlvbiBfdXBkYXRlRmlsdGVyUHJvcChzdGF0ZSwgZmlsdGVyLCBwcm9wLCB2YWx1ZSwgdmFsdWVJbmRleCwgZGF0YXNldElkcz8pIHtcbiAgbGV0IGRhdGFzZXRJZHNUb0ZpbHRlcjogc3RyaW5nW10gPSBbXTtcbiAgc3dpdGNoIChwcm9wKSB7XG4gICAgLy8gVE9ETzogTmV4dCBQUiBmb3IgVUkgaWYgd2UgdXBkYXRlIGZpbHRlckRhdGFJZCwgd2UgbmVlZCB0byBjb25zaWRlciB0d28gY2FzZXM6XG4gICAgLy8gMS4gZGF0YUlkIGlzIGVtcHR5OiBjcmVhdGUgYSBkZWZhdWx0IGZpbHRlclxuICAgIC8vIDIuIEFkZCBhIG5ldyBkYXRhc2V0IGlkXG4gICAgY2FzZSBGSUxURVJfVVBEQVRFUl9QUk9QUy5kYXRhSWQ6IHtcbiAgICAgIGNvbnN0IG9sZERhdGFJZCA9IFsuLi5maWx0ZXIuZGF0YUlkXTtcbiAgICAgIGZpbHRlciA9IF91cGRhdGVGaWx0ZXJEYXRhSWRBdFZhbHVlSW5kZXgoZmlsdGVyLCB2YWx1ZUluZGV4LCB2YWx1ZSwgc3RhdGUuZGF0YXNldHMpO1xuICAgICAgZGF0YXNldElkc1RvRmlsdGVyID0gdW5pcShbLi4ub2xkRGF0YUlkLCAuLi5maWx0ZXIuZGF0YUlkXSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBGSUxURVJfVVBEQVRFUl9QUk9QUy5uYW1lOiB7XG4gICAgICAvLyB3ZSBhcmUgc3VwcG9ydGluZyB0aGUgY3VycmVudCBmdW5jdGlvbmFsaXR5XG4gICAgICAvLyBUT0RPOiBOZXh0IFBSIGZvciBVSSBmaWx0ZXIgbmFtZSB3aWxsIG9ubHkgdXBkYXRlIGZpbHRlciBuYW1lIGJ1dCBpdCB3b24ndCBoYXZlIHNpZGUgZWZmZWN0c1xuICAgICAgLy8gd2UgYXJlIGdvbm5hIHVzZSBwYWlyIG9mIGRhdGFzZXRzIGFuZCBmaWVsZElkeCB0byB1cGRhdGUgdGhlIGZpbHRlclxuICAgICAgY29uc3QgZGF0YXNldElkID0gZmlsdGVyLmRhdGFJZFt2YWx1ZUluZGV4XTtcbiAgICAgIGNvbnN0IHtmaWx0ZXI6IHVwZGF0ZWRGaWx0ZXIsIGRhdGFzZXQ6IG5ld0RhdGFzZXR9ID0gYXBwbHlGaWx0ZXJGaWVsZE5hbWUoXG4gICAgICAgIGZpbHRlcixcbiAgICAgICAgc3RhdGUuZGF0YXNldHMsXG4gICAgICAgIGRhdGFzZXRJZCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhbHVlSW5kZXgsXG4gICAgICAgIHttZXJnZURvbWFpbjogdmFsdWVJbmRleCA+IDB9XG4gICAgICApO1xuICAgICAgaWYgKHVwZGF0ZWRGaWx0ZXIpIHtcbiAgICAgICAgZmlsdGVyID0gdXBkYXRlZEZpbHRlcjtcbiAgICAgICAgaWYgKGZpbHRlci5ncHUpIHtcbiAgICAgICAgICBmaWx0ZXIgPSBzZXRGaWx0ZXJHcHVNb2RlKGZpbHRlciwgc3RhdGUuZmlsdGVycyk7XG4gICAgICAgICAgZmlsdGVyID0gYXNzaWduR3B1Q2hhbm5lbChmaWx0ZXIsIHN0YXRlLmZpbHRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gc2V0KFsnZGF0YXNldHMnLCBkYXRhc2V0SWRdLCBuZXdEYXRhc2V0LCBzdGF0ZSk7XG4gICAgICAgIC8vIHJlbW92ZSBmaWx0ZXIgUGxvdCBhdCBkYXRhc2V0SWQsIHNvIGl0IHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgIGZpbHRlciA9IHJlbW92ZUZpbHRlclBsb3QoZmlsdGVyLCBkYXRhc2V0SWQpO1xuXG4gICAgICAgIGRhdGFzZXRJZHNUb0ZpbHRlciA9IHVwZGF0ZWRGaWx0ZXIuZGF0YUlkO1xuICAgICAgfVxuICAgICAgLy8gb25seSBmaWx0ZXIgdGhlIGN1cnJlbnQgZGF0YXNldFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBGSUxURVJfVVBEQVRFUl9QUk9QUy5sYXllcklkOiB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHVwZGF0ZSBvbmx5IGRhdGFzZXRJZC9zIGlmIHdlIGhhdmUgYWRkZWQvcmVtb3ZlZCBsYXllcnNcbiAgICAgIC8vIC0gY2hlY2sgZm9yIGxheWVySWQgY2hhbmdlcyAoWE9SIHdvcmtzIGJlY2F1c2Ugb2Ygc3RyaW5nIHZhbHVlcylcbiAgICAgIC8vIGlmIG5vIGRpZmZlcmVuY2VzIGJldHdlZW4gbGF5ZXJJZHMsIGRvbid0IGRvIGFueSBmaWx0ZXJpbmdcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IGxheWVySWREaWZmZXJlbmNlID0geG9yKHZhbHVlLCBmaWx0ZXIubGF5ZXJJZCk7XG5cbiAgICAgIGNvbnN0IGxheWVyRGF0YUlkcyA9IHVuaXE8c3RyaW5nPihcbiAgICAgICAgbGF5ZXJJZERpZmZlcmVuY2VcbiAgICAgICAgICAubWFwKGxpZCA9PlxuICAgICAgICAgICAgZ2V0KFxuICAgICAgICAgICAgICBzdGF0ZS5sYXllcnMuZmluZChsID0+IGwuaWQgPT09IGxpZCksXG4gICAgICAgICAgICAgIFsnY29uZmlnJywgJ2RhdGFJZCddXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICAgIC5maWx0ZXIoZCA9PiBkKSBhcyBzdHJpbmdbXVxuICAgICAgKTtcblxuICAgICAgLy8gb25seSBmaWx0ZXIgZGF0YXNldHNJZHNcbiAgICAgIGRhdGFzZXRJZHNUb0ZpbHRlciA9IGxheWVyRGF0YUlkcztcblxuICAgICAgLy8gVXBkYXRlIG5ld0ZpbHRlciBkYXRhSWRzXG4gICAgICBjb25zdCBuZXdEYXRhSWRzID0gdW5pcTxzdHJpbmc+KFxuICAgICAgICB2YWx1ZVxuICAgICAgICAgID8ubWFwKGxpZCA9PlxuICAgICAgICAgICAgZ2V0KFxuICAgICAgICAgICAgICBzdGF0ZS5sYXllcnMuZmluZChsID0+IGwuaWQgPT09IGxpZCksXG4gICAgICAgICAgICAgIFsnY29uZmlnJywgJ2RhdGFJZCddXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICAgIC5maWx0ZXIoZCA9PiBkKSBhcyBzdHJpbmdbXVxuICAgICAgKTtcblxuICAgICAgZmlsdGVyID0ge1xuICAgICAgICAuLi5maWx0ZXIsXG4gICAgICAgIGxheWVySWQ6IHZhbHVlLFxuICAgICAgICBkYXRhSWQ6IG5ld0RhdGFJZHNcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgZmlsdGVyID0gc2V0KFtwcm9wXSwgdmFsdWUsIGZpbHRlcik7XG4gICAgICBkYXRhc2V0SWRzVG9GaWx0ZXIgPSBbLi4uZmlsdGVyLmRhdGFJZF07XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7ZmlsdGVyLCBkYXRhc2V0SWRzLCBkYXRhc2V0SWRzVG9GaWx0ZXIsIHN0YXRlfTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuLyoqXG4gKiBTZXQgdGhlIHByb3BlcnR5IG9mIGEgZmlsdGVyIHBsb3RcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRGaWx0ZXJQbG90VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7aWR4LCBuZXdQcm9wfTogVmlzU3RhdGVBY3Rpb25zLlNldEZpbHRlclBsb3RVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGlmICghc3RhdGUuZmlsdGVyc1tpZHhdKSB7XG4gICAgQ29uc29sZS5lcnJvcihgZmlsdGVyc1ske2lkeH1dIGlzIHVuZGVmaW5lZGApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBsZXQgbmV3RmlsdGVyID0gc3RhdGUuZmlsdGVyc1tpZHhdO1xuXG4gIGZvciAoY29uc3QgcHJvcCBpbiBuZXdQcm9wKSB7XG4gICAgaWYgKHByb3AgPT09ICdwbG90VHlwZScpIHtcbiAgICAgIG5ld0ZpbHRlciA9IHBpY2tfKCdwbG90VHlwZScpKG1lcmdlXyhuZXdQcm9wLnBsb3RUeXBlKSkobmV3RmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgPT09ICd5QXhpcycpIHtcbiAgICAgIGNvbnN0IGNoYXJ0VHlwZSA9IG5ld1Byb3AueUF4aXMgPyBQTE9UX1RZUEVTLmxpbmVDaGFydCA6IFBMT1RfVFlQRVMuaGlzdG9ncmFtO1xuXG4gICAgICBuZXdGaWx0ZXIgPSBwaWNrXygncGxvdFR5cGUnKShtZXJnZV8oe3R5cGU6IGNoYXJ0VHlwZX0pKShtZXJnZV8obmV3UHJvcCkobmV3RmlsdGVyKSk7XG4gICAgfVxuICB9XG5cbiAgbmV3RmlsdGVyID0gdXBkYXRlRmlsdGVyUGxvdChzdGF0ZS5kYXRhc2V0cywgbmV3RmlsdGVyKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGZpbHRlcnM6IHN0YXRlLmZpbHRlcnMubWFwKChmLCBpKSA9PiAoaSA9PT0gaWR4ID8gbmV3RmlsdGVyIDogZikpXG4gIH07XG59O1xuXG4vKipcbiAqIEFkZCBhIG5ldyBmaWx0ZXJcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRGaWx0ZXJVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkFkZEZpbHRlclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+XG4gICFhY3Rpb24uZGF0YUlkXG4gICAgPyBzdGF0ZVxuICAgIDoge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZmlsdGVyczogWy4uLnN0YXRlLmZpbHRlcnMsIGdldERlZmF1bHRGaWx0ZXIoe2RhdGFJZDogYWN0aW9uLmRhdGFJZCwgaWQ6IGFjdGlvbi5pZH0pXVxuICAgICAgfTtcblxuLyoqXG4gKiBDcmVhdGUgb3IgdXBkYXRlIGEgZmlsdGVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlT3JVcGRhdGVGaWx0ZXJVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkNyZWF0ZU9yVXBkYXRlRmlsdGVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCB7aWQsIGRhdGFJZCwgZmllbGQsIHZhbHVlfSA9IGFjdGlvbjtcblxuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3Qgb3JpZ2luYWxJbmRleCA9IG5ld1N0YXRlLmZpbHRlcnMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gaWQpO1xuICBsZXQgZmlsdGVySW5kZXggPSBvcmlnaW5hbEluZGV4O1xuICBpZiAoIWlkICYmICFkYXRhSWQpIHtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cbiAgaWYgKG9yaWdpbmFsSW5kZXggPCAwICYmIGRhdGFJZCkge1xuICAgIG5ld1N0YXRlID0gYWRkRmlsdGVyVXBkYXRlcihuZXdTdGF0ZSwge2RhdGFJZH0pO1xuICAgIGlmIChuZXdTdGF0ZS5maWx0ZXJzLmxlbmd0aCAhPT0gc3RhdGUuZmlsdGVycy5sZW5ndGggKyAxKSB7XG4gICAgICAvLyBObyBuZXcgZmlsdGVyIHdhcyBhZGRlZFxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAvLyBIZXJlIHdlIGFyZSBhc3N1bWluZyB0aGF0IHRoZSBmaWx0ZXIgd2FzIGFkZGVkIGF0IHRoZSBlbmRcbiAgICBmaWx0ZXJJbmRleCA9IG5ld1N0YXRlLmZpbHRlcnMubGVuZ3RoIC0gMTtcbiAgICBuZXdTdGF0ZS5maWx0ZXJzW2ZpbHRlckluZGV4XSA9IHtcbiAgICAgIC4uLm5ld1N0YXRlLmZpbHRlcnNbZmlsdGVySW5kZXhdLFxuICAgICAgLi4uKGlkID8ge2lkfSA6IG51bGwpXG4gICAgfTtcbiAgfVxuXG4gIC8vIE5vIG5lZWQgdG8gdXBkYXRlIHRoaXMgaWYgaXQncyBhIG5ld2x5IGNyZWF0ZWQgZmlsdGVyXG4gIC8vIEZpcnN0IHdlIG1ha2Ugc3VyZSBhbGwgdGhlIGRhdGFJZHMgdGhhdCBmaWVsZHMgcmVmZXIgdG8gYXJlIHVwZGF0ZWRcbiAgaWYgKG9yaWdpbmFsSW5kZXggPj0gMCAmJiBkYXRhSWQpIHtcbiAgICAvLyBJZiB0aGUgZGF0YUlkIGlzIGFuIGFycmF5LCB3ZSBuZWVkIHRvIHVwZGF0ZSBlYWNoIG9uZSBpbmRpdmlkdWFsbHkgYXMgdGhleSBuZWVkIGEgY29ycmVjdCB2YWx1ZUluZGV4IHBhc3NlZFxuICAgIG5ld1N0YXRlID0gKEFycmF5LmlzQXJyYXkoZGF0YUlkKSA/IGRhdGFJZCA6IFtkYXRhSWRdKS5yZWR1Y2UoKGFjY3UsIGQsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gc2V0RmlsdGVyVXBkYXRlcihhY2N1LCB7XG4gICAgICAgIGlkeDogZmlsdGVySW5kZXgsXG4gICAgICAgIHByb3A6ICdkYXRhSWQnLFxuICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgdmFsdWVJbmRleDogaW5kZXhcbiAgICAgIH0pO1xuICAgIH0sIG5ld1N0YXRlKTtcbiAgfVxuICAvLyBUaGVuIHdlIHVwZGF0ZSB0aGUgZmllbGRzXG4gIGlmIChmaWVsZCkge1xuICAgIC8vIElmIHRoZSBmaWVsZCBpcyBhbiBhcnJheSwgd2UgbmVlZCB0byB1cGRhdGUgZWFjaCBmaWVsZCBpbmRpdmlkdWFsbHkgYXMgdGhleSBuZWVkIGEgY29ycmVjdCB2YWx1ZUluZGV4IHBhc3NlZFxuICAgIG5ld1N0YXRlID0gKEFycmF5LmlzQXJyYXkoZmllbGQpID8gZmllbGQgOiBbZmllbGRdKS5yZWR1Y2UoKGFjY3UsIGYsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gc2V0RmlsdGVyVXBkYXRlcihhY2N1LCB7XG4gICAgICAgIGlkeDogZmlsdGVySW5kZXgsXG4gICAgICAgIHByb3A6ICduYW1lJyxcbiAgICAgICAgdmFsdWU6IGYsXG4gICAgICAgIHZhbHVlSW5kZXg6IGluZGV4XG4gICAgICB9KTtcbiAgICB9LCBuZXdTdGF0ZSk7XG4gIH1cbiAgLy8gVGhlbiB3ZSB1cGRhdGUgdGhlIHZhbHVlIHNlcGFyYXRlbHlcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuZXdTdGF0ZSA9IHNldEZpbHRlclVwZGF0ZXIobmV3U3RhdGUsIHtpZHg6IGZpbHRlckluZGV4LCBwcm9wOiAndmFsdWUnLCB2YWx1ZX0pO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufTtcblxuLyoqXG4gKiBTZXQgbGF5ZXIgY29sb3IgcGFsZXR0ZSB1aSBzdGF0ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGxheWVyQ29sb3JVSUNoYW5nZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge29sZExheWVyLCBwcm9wLCBuZXdDb25maWd9OiBWaXNTdGF0ZUFjdGlvbnMuTGF5ZXJDb2xvclVJQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBvbGRWaXhDb25maWcgPSBvbGRMYXllci5jb25maWcudmlzQ29uZmlnW3Byb3BdO1xuICBjb25zdCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29sb3JVSShwcm9wLCBuZXdDb25maWcpO1xuICBjb25zdCBuZXdWaXNDb25maWcgPSBuZXdMYXllci5jb25maWcudmlzQ29uZmlnW3Byb3BdO1xuICBpZiAob2xkVml4Q29uZmlnICE9PSBuZXdWaXNDb25maWcpIHtcbiAgICByZXR1cm4gbGF5ZXJWaXNDb25maWdDaGFuZ2VVcGRhdGVyKHN0YXRlLCB7XG4gICAgICBvbGRMYXllcixcbiAgICAgIG5ld1Zpc0NvbmZpZzoge1xuICAgICAgICBbcHJvcF06IG5ld1Zpc0NvbmZpZ1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBzdGF0ZS5sYXllcnMubWFwKGwgPT4gKGwuaWQgPT09IG9sZExheWVyLmlkID8gbmV3TGF5ZXIgOiBsKSlcbiAgfTtcbn07XG5cbi8qKlxuICogU3RhcnQgYW5kIGVuZCBmaWx0ZXIgYW5pbWF0aW9uXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlRmlsdGVyQW5pbWF0aW9uVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Ub2dnbGVGaWx0ZXJBbmltYXRpb25VcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoKGYsIGkpID0+IChpID09PSBhY3Rpb24uaWR4ID8gey4uLmYsIGlzQW5pbWF0aW5nOiAhZi5pc0FuaW1hdGluZ30gOiBmKSlcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNGaWx0ZXJBbmltYXRpb25Db25maWcoY29uZmlnOiBBbmltYXRpb25Db25maWcgfCBGaWx0ZXJBbmltYXRpb25Db25maWcpOiBib29sZWFuIHtcbiAgcmV0dXJuICdkYXRhSWQnIGluIGNvbmZpZyAmJiAnYW5pbWF0aW9uV2luZG93JyBpbiBjb25maWc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRBbmltYXRpb25Db25maWdVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlNldEFuaW1hdGlvbkNvbmZpZ1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge2NvbmZpZ30gPSBhY3Rpb247XG4gIGlmIChpc0ZpbHRlckFuaW1hdGlvbkNvbmZpZyhjb25maWcpKSB7XG4gICAgLy8gRmluZCBmaWx0ZXIgdXNlZCBmb3IgYW5pbWF0aW9uXG4gICAgLy8gQXNzdW1pbmcgdGhlcmUncyBvbmx5IG9uZSBmaWx0ZXIgdXNlZCBmb3IgYW5pbWF0aW9uLCBzZWUgc2V0RmlsdGVyVmlld1VwZGF0ZXJcbiAgICBjb25zdCBmaWx0ZXIgPSBzdGF0ZS5maWx0ZXJzLmZpbmQoZiA9PiAhaXNTaWRlRmlsdGVyKGYpKTtcbiAgICBpZiAoIWZpbHRlcikge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCBuZXdGaWx0ZXIgPSB7Li4uZmlsdGVyLCAuLi5jb25maWd9O1xuICAgIHJldHVybiBhcHBseUZpbHRlckNvbmZpZ1VwZGF0ZXIoc3RhdGUsIGFwcGx5RmlsdGVyQ29uZmlnKGZpbHRlci5pZCwgbmV3RmlsdGVyKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVMYXllckFuaW1hdGlvblVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Ub2dnbGVMYXllckFuaW1hdGlvblVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBhbmltYXRpb25Db25maWc6IHtcbiAgICAuLi5zdGF0ZS5hbmltYXRpb25Db25maWcsXG4gICAgaXNBbmltYXRpbmc6ICFzdGF0ZS5hbmltYXRpb25Db25maWcuaXNBbmltYXRpbmdcbiAgfVxufSk7XG5cbi8qKlxuICogSGlkZSBhbmQgc2hvdyBsYXllciBhbmltYXRpb24gY29udHJvbFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUxheWVyQW5pbWF0aW9uQ29udHJvbFVwZGF0ZXIgPSAoc3RhdGU6IFZpc1N0YXRlKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICBoaWRlQ29udHJvbDogIXN0YXRlLmFuaW1hdGlvbkNvbmZpZy5oaWRlQ29udHJvbFxuICB9XG59KTtcblxuLyoqXG4gKiBDaGFuZ2UgZmlsdGVyIGFuaW1hdGlvbiBzcGVlZFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUZpbHRlckFuaW1hdGlvblNwZWVkVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVGaWx0ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT4gKGkgPT09IGFjdGlvbi5pZHggPyB7Li4uZiwgc3BlZWQ6IGFjdGlvbi5zcGVlZH0gOiBmKSlcbn0pO1xuXG4vKipcbiAqIFVwZGF0ZSBhbmltYXRpb24gc3BlZWQgd2l0aCB0aGUgdmVydGljYWwgc3BlZWQgc2xpZGVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUxheWVyQW5pbWF0aW9uU3BlZWRVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtzcGVlZH06IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVMYXllckFuaW1hdGlvblNwZWVkVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgc3BlZWRcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFNob3cgbGFyZ2VyIHRpbWUgZmlsdGVyIGF0IGJvdHRvbSBmb3IgdGltZSBwbGF5YmFjayAoYXBwbHkgdG8gdGltZSBmaWx0ZXIgb25seSlcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRGaWx0ZXJWaWV3VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5TZXRGaWx0ZXJWaWV3VXBkYXRlckFjdGlvblxuKSA9PiB7XG4gIGNvbnN0IHt2aWV3LCBpZHh9ID0gYWN0aW9uO1xuICBjb25zdCBzaG91bGRSZXNldE90aGVyRmlsdGVyc1ZpZXcgPSB2aWV3ID09PSBGSUxURVJfVklFV19UWVBFUy5lbmxhcmdlZDtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT5cbiAgICAgIGkgPT09IGlkeFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLmYsXG4gICAgICAgICAgICB2aWV3XG4gICAgICAgICAgfVxuICAgICAgICA6IHNob3VsZFJlc2V0T3RoZXJGaWx0ZXJzVmlld1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLmYsXG4gICAgICAgICAgICB2aWV3OiBGSUxURVJfVklFV19UWVBFUy5zaWRlXG4gICAgICAgICAgfVxuICAgICAgICA6IGZcbiAgICApXG4gIH07XG59O1xuXG4vKipcbiAqIFRvZ2dsZXMgZmlsdGVyIGZlYXR1cmUgdmlzaWJpbGl0eVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUZpbHRlckZlYXR1cmVVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlRvZ2dsZUZpbHRlckZlYXR1cmVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IGZpbHRlciA9IHN0YXRlLmZpbHRlcnNbYWN0aW9uLmlkeF07XG4gIGNvbnN0IGlzVmlzaWJsZSA9IGdldChmaWx0ZXIsIFsndmFsdWUnLCAncHJvcGVydGllcycsICdpc1Zpc2libGUnXSk7XG5cbiAgbGV0IG5ld1N0YXRlID0gc2V0RmlsdGVyVXBkYXRlcihzdGF0ZSwge1xuICAgIGlkeDogYWN0aW9uLmlkeCxcbiAgICBwcm9wOiAnZW5hYmxlZCcsXG4gICAgdmFsdWU6ICFpc1Zpc2libGVcbiAgfSk7XG5cbiAgbmV3U3RhdGUgPSBzZXRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgaWR4OiBhY3Rpb24uaWR4LFxuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZlYXR1cmVUb0ZpbHRlclZhbHVlKGZpbHRlci52YWx1ZSwgZmlsdGVyLmlkLCB7XG4gICAgICBpc1Zpc2libGU6ICFpc1Zpc2libGVcbiAgICB9KVxuICB9KTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGZpbHRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUZpbHRlclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuUmVtb3ZlRmlsdGVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCB7aWR4fSA9IGFjdGlvbjtcbiAgY29uc3Qge2RhdGFJZCwgaWR9ID0gc3RhdGUuZmlsdGVyc1tpZHhdO1xuXG4gIGNvbnN0IG5ld0ZpbHRlcnMgPSBbXG4gICAgLi4uc3RhdGUuZmlsdGVycy5zbGljZSgwLCBpZHgpLFxuICAgIC4uLnN0YXRlLmZpbHRlcnMuc2xpY2UoaWR4ICsgMSwgc3RhdGUuZmlsdGVycy5sZW5ndGgpXG4gIF07XG5cbiAgY29uc3QgZmlsdGVyZWREYXRhc2V0cyA9IGFwcGx5RmlsdGVyc1RvRGF0YXNldHMoZGF0YUlkLCBzdGF0ZS5kYXRhc2V0cywgbmV3RmlsdGVycywgc3RhdGUubGF5ZXJzKTtcbiAgY29uc3QgbmV3RWRpdG9yID1cbiAgICBnZXRGaWx0ZXJJZEluRmVhdHVyZShzdGF0ZS5lZGl0b3Iuc2VsZWN0ZWRGZWF0dXJlKSA9PT0gaWRcbiAgICAgID8ge1xuICAgICAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgICAgICBzZWxlY3RlZEZlYXR1cmU6IG51bGxcbiAgICAgICAgfVxuICAgICAgOiBzdGF0ZS5lZGl0b3I7XG5cbiAgbGV0IG5ld1N0YXRlID0gc2V0KFsnZmlsdGVycyddLCBuZXdGaWx0ZXJzLCBzdGF0ZSk7XG4gIG5ld1N0YXRlID0gc2V0KFsnZGF0YXNldHMnXSwgZmlsdGVyZWREYXRhc2V0cywgbmV3U3RhdGUpO1xuICBuZXdTdGF0ZSA9IHNldChbJ2VkaXRvciddLCBuZXdFZGl0b3IsIG5ld1N0YXRlKTtcblxuICByZXR1cm4gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhKG5ld1N0YXRlLCBkYXRhSWQsIHVuZGVmaW5lZCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG5ldyBsYXllclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZExheWVyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5BZGRMYXllclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgbGV0IG5ld0xheWVyO1xuICBsZXQgbmV3TGF5ZXJEYXRhO1xuICBpZiAoYWN0aW9uLmNvbmZpZykge1xuICAgIG5ld0xheWVyID0gY3JlYXRlTGF5ZXJGcm9tQ29uZmlnKHN0YXRlLCBhY3Rpb24uY29uZmlnKTtcbiAgICBpZiAoIW5ld0xheWVyKSB7XG4gICAgICBDb25zb2xlLndhcm4oXG4gICAgICAgICdGYWlsZWQgdG8gY3JlYXRlIGxheWVyIGZyb20gY29uZmlnLCBpdCB1c3VhbGx5IG1lYW5zIHRoZSBjb25maWcgaXMgbm90IGJlIGluIGNvcnJlY3QgZm9ybWF0JyxcbiAgICAgICAgYWN0aW9uLmNvbmZpZ1xuICAgICAgKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlKTtcbiAgICBuZXdMYXllciA9IHJlc3VsdC5sYXllcjtcbiAgICBuZXdMYXllckRhdGEgPSByZXN1bHQubGF5ZXJEYXRhO1xuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBsYXllciB3aXRoIGEgc3BlY2lmaWMgZGF0YXNldCBvciBhIGRlZmF1bHQgb25lXG4gICAgY29uc3QgZGVmYXVsdERhdGFzZXQgPSBhY3Rpb24uZGF0YXNldElkID8/IE9iamVjdC5rZXlzKHN0YXRlLmRhdGFzZXRzKVswXTtcbiAgICBuZXdMYXllciA9IG5ldyBMYXllcih7XG4gICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICBpc0NvbmZpZ0FjdGl2ZTogdHJ1ZSxcbiAgICAgIGRhdGFJZDogZGVmYXVsdERhdGFzZXRcbiAgICB9KTtcbiAgICBuZXdMYXllckRhdGEgPSB7fTtcbiAgfVxuXG4gIGxldCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IFsuLi5zdGF0ZS5sYXllcnMsIG5ld0xheWVyXSxcbiAgICBsYXllckRhdGE6IFsuLi5zdGF0ZS5sYXllckRhdGEsIG5ld0xheWVyRGF0YV0sXG4gICAgLy8gYWRkIG5ldyBsYXllciBhdCB0aGUgdG9wXG4gICAgbGF5ZXJPcmRlcjogW25ld0xheWVyLmlkLCAuLi5zdGF0ZS5sYXllck9yZGVyXSxcbiAgICBzcGxpdE1hcHM6IGFkZE5ld0xheWVyc1RvU3BsaXRNYXAoc3RhdGUuc3BsaXRNYXBzLCBuZXdMYXllcilcbiAgfTtcblxuICBpZiAobmV3TGF5ZXIuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkKSB7XG4gICAgbmV3U3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4obmV3U3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufTtcblxuLyoqXG4gKiByZW1vdmUgbGF5ZXJcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMYXllclVwZGF0ZXI8VCBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFQsXG4gIHtpZH06IFZpc1N0YXRlQWN0aW9ucy5SZW1vdmVMYXllclVwZGF0ZXJBY3Rpb25cbik6IFQge1xuICBjb25zdCBpZHggPSBOdW1iZXIuaXNGaW5pdGUoaWQpXG4gICAgPyAvLyBzdXBwb3J0IG9sZGVyIEFQSSwgcmVtb3ZlIGxheWVyIGJ5IGlkeFxuICAgICAgTnVtYmVyKGlkKVxuICAgIDogc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IGlkKTtcbiAgaWYgKGlkeCA8IDAgfHwgaWR4ID49IHN0YXRlLmxheWVycy5sZW5ndGgpIHtcbiAgICAvLyBpbnZhbGlkIGluZGV4XG4gICAgQ29uc29sZS53YXJuKGBjYW4gbm90IHJlbW92ZSBsYXllciB3aXRoIGludmFsaWQgaWR8aWR4ICR7aWR9YCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qge2xheWVycywgbGF5ZXJEYXRhLCBsYXllck9yZGVyLCBjbGlja2VkLCBob3ZlckluZm99ID0gc3RhdGU7XG4gIGNvbnN0IGxheWVyVG9SZW1vdmUgPSBsYXllcnNbaWR4XTtcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBmaWx0ZXJPdXRCeUlkKGxheWVyVG9SZW1vdmUuaWQpKGxheWVycyksXG4gICAgbGF5ZXJEYXRhOiByZW1vdmVFbGVtZW50QXRJbmRleChpZHgpKGxheWVyRGF0YSksXG4gICAgbGF5ZXJPcmRlcjogbGF5ZXJPcmRlci5maWx0ZXIobGF5ZXJJZCA9PiBsYXllcklkICE9PSBsYXllclRvUmVtb3ZlLmlkKSxcbiAgICBjbGlja2VkOiBsYXllclRvUmVtb3ZlLmlzTGF5ZXJIb3ZlcmVkKGNsaWNrZWQpID8gdW5kZWZpbmVkIDogY2xpY2tlZCxcbiAgICBob3ZlckluZm86IGxheWVyVG9SZW1vdmUuaXNMYXllckhvdmVyZWQoaG92ZXJJbmZvKSA/IHVuZGVmaW5lZCA6IGhvdmVySW5mbyxcbiAgICBzcGxpdE1hcHM6IHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyhzdGF0ZS5zcGxpdE1hcHMsIGxheWVyVG9SZW1vdmUpXG4gICAgLy8gVE9ETzogdXBkYXRlIGZpbHRlcnMsIGNyZWF0ZSBoZWxwZXIgdG8gcmVtb3ZlIGxheWVyIGZvcm0gZmlsdGVyIChyZW1vdmUgbGF5ZXJpZCBhbmQgZGF0YWlkKSBpZiBtYXBwZWRcbiAgfTtcblxuICByZXR1cm4gdXBkYXRlQW5pbWF0aW9uRG9tYWluKG5ld1N0YXRlKTtcbn1cblxuLyoqXG4gKiBSZW9yZGVyIGxheWVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVvcmRlckxheWVyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7b3JkZXJ9OiBWaXNTdGF0ZUFjdGlvbnMuUmVvcmRlckxheWVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGxheWVyT3JkZXI6IG9yZGVyXG59KTtcblxuLyoqXG4gKiBkdXBsaWNhdGUgbGF5ZXJcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBkdXBsaWNhdGVMYXllclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2lkfTogVmlzU3RhdGVBY3Rpb25zLkR1cGxpY2F0ZUxheWVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBpZHggPSBOdW1iZXIuaXNGaW5pdGUoaWQpXG4gICAgPyAvLyBzdXBwb3J0IG9sZGVyIEFQSSwgcmVtb3ZlIGxheWVyIGJ5IGlkeFxuICAgICAgTnVtYmVyKGlkKVxuICAgIDogc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IGlkKTtcbiAgaWYgKGlkeCA8IDAgfHwgIXN0YXRlLmxheWVyc1tpZHhdKSB7XG4gICAgQ29uc29sZS53YXJuKGBsYXllciAke2lkeH0gbm90IGZvdW5kIGluIGxheWVyT3JkZXJgKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB7bGF5ZXJzfSA9IHN0YXRlO1xuICBjb25zdCBvcmlnaW5hbCA9IGxheWVyc1tpZHhdO1xuXG4gIGNvbnN0IG9yaWdpbmFsTGF5ZXJPcmRlcklkeCA9IHN0YXRlLmxheWVyT3JkZXIuZmluZEluZGV4KGxpZCA9PiBsaWQgPT09IG9yaWdpbmFsLmlkKTtcbiAgbGV0IG5ld0xhYmVsID0gYENvcHkgb2YgJHtvcmlnaW5hbC5jb25maWcubGFiZWx9YDtcbiAgbGV0IHBvc3RmaXggPSAwO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gIHdoaWxlIChsYXllcnMuZmluZChsID0+IGwuY29uZmlnLmxhYmVsID09PSBuZXdMYWJlbCkpIHtcbiAgICBuZXdMYWJlbCA9IGBDb3B5IG9mICR7b3JpZ2luYWwuY29uZmlnLmxhYmVsfSAkeysrcG9zdGZpeH1gO1xuICB9XG5cbiAgLy8gY29sbGVjdCBsYXllciBjb25maWcgZnJvbSBvcmlnaW5hbFxuICBjb25zdCBsb2FkZWRMYXllciA9IHNlcmlhbGl6ZUxheWVyKG9yaWdpbmFsLCBzdGF0ZS5zY2hlbWEpO1xuXG4gIC8vIGFzc2lnbiBuZXcgaWQgYW5kIGxhYmVsIHRvIGNvcGllZCBsYXllclxuICBpZiAoIWxvYWRlZExheWVyPy5jb25maWcpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgbG9hZGVkTGF5ZXIuY29uZmlnLmxhYmVsID0gbmV3TGFiZWw7XG4gIGxvYWRlZExheWVyLmlkID0gZ2VuZXJhdGVIYXNoSWQoTEFZRVJfSURfTEVOR1RIKTtcblxuICAvLyBhZGQgbGF5ZXIgdG8gc3RhdGVcbiAgbGV0IG5leHRTdGF0ZSA9IGFkZExheWVyVXBkYXRlcihzdGF0ZSwge2NvbmZpZzogbG9hZGVkTGF5ZXJ9KTtcbiAgLy8gcmV0cmlldmUgbmV3bHkgY3JlYXRlZCBsYXllclxuICBjb25zdCBuZXdMYXllciA9IG5leHRTdGF0ZS5sYXllcnNbbmV4dFN0YXRlLmxheWVycy5sZW5ndGggLSAxXTtcbiAgLy8gdXBkYXRlIGxheWVyIG9yZGVyIHdpdGggbmV3THlhZXIuaWRcbiAgY29uc3QgbmV3TGF5ZXJPcmRlciA9IGFycmF5SW5zZXJ0KFxuICAgIG5leHRTdGF0ZS5sYXllck9yZGVyLnNsaWNlKDEsIG5leHRTdGF0ZS5sYXllck9yZGVyLmxlbmd0aCksXG4gICAgb3JpZ2luYWxMYXllck9yZGVySWR4LFxuICAgIG5ld0xheWVyLmlkXG4gICk7XG5cbiAgbmV4dFN0YXRlID0gcmVvcmRlckxheWVyVXBkYXRlcihuZXh0U3RhdGUsIHtvcmRlcjogbmV3TGF5ZXJPcmRlcn0pO1xuXG4gIHJldHVybiB1cGRhdGVBbmltYXRpb25Eb21haW4obmV4dFN0YXRlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGVmZmVjdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEVmZmVjdFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuQWRkRWZmZWN0VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBpZiAoXG4gICAgYWN0aW9uLmNvbmZpZz8udHlwZSA9PT0gTElHSFRfQU5EX1NIQURPV19FRkZFQ1QudHlwZSAmJlxuICAgIHN0YXRlLmVmZmVjdHMuc29tZShlZmZlY3QgPT4gZWZmZWN0LnR5cGUgPT09IExJR0hUX0FORF9TSEFET1dfRUZGRUNULnR5cGUpXG4gICkge1xuICAgIENvbnNvbGUud2FybihgQ2FuJ3QgYWRkIG1vcmUgdGhhbiBvbmUgJHtMSUdIVF9BTkRfU0hBRE9XX0VGRkVDVC5uYW1lfSBlZmZlY3RgKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBuZXdFZmZlY3QgPSBjcmVhdGVFZmZlY3QoYWN0aW9uLmNvbmZpZyk7XG5cbiAgLy8gY29sbGFwc2UgY29uZmlndXJhdG9ycyBmb3Igb3RoZXIgZWZmZWN0c1xuICBzdGF0ZS5lZmZlY3RzLmZvckVhY2goZWZmZWN0ID0+IGVmZmVjdC5zZXRQcm9wcyh7aXNDb25maWdBY3RpdmU6IGZhbHNlfSkpO1xuXG4gIGNvbnN0IGVmZmVjdHMgPSBbLi4uc3RhdGUuZWZmZWN0cywgbmV3RWZmZWN0XTtcbiAgY29uc3QgZWZmZWN0T3JkZXIgPSBmaXhFZmZlY3RPcmRlcihlZmZlY3RzLCBbbmV3RWZmZWN0LmlkLCAuLi5zdGF0ZS5lZmZlY3RPcmRlcl0pO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWZmZWN0cyxcbiAgICBlZmZlY3RPcmRlclxuICB9O1xufTtcblxuLyoqXG4gKiByZW1vdmUgZWZmZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRWZmZWN0VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7aWR9OiBWaXNTdGF0ZUFjdGlvbnMuUmVtb3ZlRWZmZWN0VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBpZHggPSBzdGF0ZS5lZmZlY3RzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IGlkKTtcbiAgaWYgKGlkeCA8IDAgfHwgaWR4ID49IHN0YXRlLmVmZmVjdHMubGVuZ3RoKSB7XG4gICAgQ29uc29sZS53YXJuKGBjYW4gbm90IHJlbW92ZSBlZmZlY3Qgd2l0aCBpbnZhbGlkIGlkICR7aWR9YCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qge2VmZmVjdHMsIGVmZmVjdE9yZGVyfSA9IHN0YXRlO1xuICBjb25zdCBlZmZlY3RUb1JlbW92ZSA9IGVmZmVjdHNbaWR4XTtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZpeGVkIGluIHRzXG4gICAgZWZmZWN0czogZmlsdGVyT3V0QnlJZChlZmZlY3RUb1JlbW92ZS5pZCkoZWZmZWN0cyksXG4gICAgZWZmZWN0T3JkZXI6IGVmZmVjdE9yZGVyLmZpbHRlcihlZmZlY3RJZCA9PiBlZmZlY3RJZCAhPT0gZWZmZWN0VG9SZW1vdmUuaWQpXG4gIH07XG59O1xuXG4vKipcbiAqIFJlb3JkZXIgZWZmZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVvcmRlckVmZmVjdFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge29yZGVyfTogVmlzU3RhdGVBY3Rpb25zLlJlb3JkZXJFZmZlY3RVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZWZmZWN0T3JkZXI6IGZpeEVmZmVjdE9yZGVyKHN0YXRlLmVmZmVjdHMsIFsuLi5vcmRlcl0pXG59KTtcblxuLyoqXG4gKiBVcGRhdGUgZWZmZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlRWZmZWN0VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7aWQsIHByb3BzfTogVmlzU3RhdGVBY3Rpb25zLlVwZGF0ZUVmZmVjdFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgY29uc3QgaWR4ID0gc3RhdGUuZWZmZWN0cy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBpZCk7XG4gIGlmIChpZHggPCAwIHx8IGlkeCA+PSBzdGF0ZS5lZmZlY3RzLmxlbmd0aCkge1xuICAgIENvbnNvbGUud2FybihgY2FuIG5vdCB1cGRhdGUgZWZmZWN0IHdpdGggaW52YWxpZCBpZCAke2lkfWApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGxldCBlZmZlY3RPcmRlciA9IHN0YXRlLmVmZmVjdE9yZGVyO1xuICBpZiAocHJvcHMuaWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5pZCAhPT0gaWQpIHtcbiAgICBjb25zdCBpZHgyID0gc3RhdGUuZWZmZWN0cy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBwcm9wcy5pZCk7XG4gICAgaWYgKGlkeDIgPj0gMCkge1xuICAgICAgQ29uc29sZS53YXJuKGBjYW4gbm90IHVwZGF0ZSBlZmZlY3Qgd2l0aCBleGlzdGluZyBlZmZlY3QgaWQgJHtpZH1gKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBlZmZlY3RPcmRlciA9IGVmZmVjdE9yZGVyLm1hcChlZmZlY3RPcmRlcklkID0+XG4gICAgICBlZmZlY3RPcmRlcklkID09PSBpZCA/IChwcm9wcy5pZCBhcyBzdHJpbmcpIDogZWZmZWN0T3JkZXJJZFxuICAgICk7XG4gIH1cblxuICBjb25zdCBuZXdFZmZlY3RzID0gWy4uLnN0YXRlLmVmZmVjdHNdO1xuICBuZXdFZmZlY3RzW2lkeF0uc2V0UHJvcHMocHJvcHMpO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWZmZWN0czogbmV3RWZmZWN0cyxcbiAgICBlZmZlY3RPcmRlclxuICB9O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBkYXRhc2V0IGFuZCBhbGwgbGF5ZXJzLCBmaWx0ZXJzLCB0b29sdGlwIGNvbmZpZ3MgdGhhdCBiYXNlZCBvbiBpdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZURhdGFzZXRVcGRhdGVyPFQgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBULFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5SZW1vdmVEYXRhc2V0VXBkYXRlckFjdGlvblxuKTogVCB7XG4gIC8vIGV4dHJhY3QgZGF0YXNldCBrZXlcbiAgY29uc3Qge2RhdGFJZDogZGF0YXNldEtleX0gPSBhY3Rpb247XG4gIGNvbnN0IHtkYXRhc2V0c30gPSBzdGF0ZTtcblxuICAvLyBjaGVjayBpZiBkYXRhc2V0IGlzIHByZXNlbnRcbiAgaWYgKCFkYXRhc2V0c1tkYXRhc2V0S2V5XSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBsYXllcnMsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGRhdGFzZXRzOiB7W2RhdGFzZXRLZXldOiBkYXRhc2V0LCAuLi5uZXdEYXRhc2V0c31cbiAgfSA9IHN0YXRlO1xuXG4gIGNvbnN0IGxheWVyc1RvUmVtb3ZlID0gbGF5ZXJzLmZpbHRlcihsID0+IGwuY29uZmlnLmRhdGFJZCA9PT0gZGF0YXNldEtleSkubWFwKGwgPT4gbC5pZCk7XG5cbiAgLy8gcmVtb3ZlIGxheWVycyBhbmQgZGF0YXNldHNcbiAgbGV0IG5ld1N0YXRlID0gbGF5ZXJzVG9SZW1vdmUucmVkdWNlKChhY2N1LCBpZCkgPT4gcmVtb3ZlTGF5ZXJVcGRhdGVyKGFjY3UsIHtpZH0pLCB7XG4gICAgLi4uc3RhdGUsXG4gICAgZGF0YXNldHM6IG5ld0RhdGFzZXRzXG4gIH0pO1xuXG4gIC8vIHVwZGF0ZSBmaWx0ZXJzXG4gIGNvbnN0IGZpbHRlcnM6IEZpbHRlcltdID0gW107XG4gIGZvciAoY29uc3QgZmlsdGVyIG9mIG5ld1N0YXRlLmZpbHRlcnMpIHtcbiAgICBjb25zdCB2YWx1ZUluZGV4ID0gZmlsdGVyLmRhdGFJZC5pbmRleE9mKGRhdGFzZXRLZXkpO1xuICAgIGlmICh2YWx1ZUluZGV4ID49IDAgJiYgZmlsdGVyLmRhdGFJZC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBvbmx5IHJlbW92ZSBvbmUgc3luY2VkIGRhdGFzZXQgZnJvbSB0aGUgZmlsdGVyXG4gICAgICBmaWx0ZXJzLnB1c2goX3JlbW92ZUZpbHRlckRhdGFJZEF0VmFsdWVJbmRleChmaWx0ZXIsIHZhbHVlSW5kZXgsIGRhdGFzZXRzKSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZUluZGV4IDwgMCkge1xuICAgICAgLy8gbGVhdmUgdGhlIGZpbHRlciBhcyBpc1xuICAgICAgZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgfVxuICB9XG5cbiAgbmV3U3RhdGUgPSB7Li4ubmV3U3RhdGUsIGZpbHRlcnN9O1xuXG4gIHJldHVybiByZW1vdmVEYXRhc2V0RnJvbUludGVyYWN0aW9uQ29uZmlnKG5ld1N0YXRlLCB7ZGF0YUlkOiBkYXRhc2V0S2V5fSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURhdGFzZXRGcm9tSW50ZXJhY3Rpb25Db25maWcoc3RhdGUsIHtkYXRhSWR9KSB7XG4gIGxldCB7aW50ZXJhY3Rpb25Db25maWd9ID0gc3RhdGU7XG4gIGNvbnN0IHt0b29sdGlwfSA9IGludGVyYWN0aW9uQ29uZmlnO1xuICBpZiAodG9vbHRpcCkge1xuICAgIGNvbnN0IHtjb25maWd9ID0gdG9vbHRpcDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgY29uc3Qge1tkYXRhSWRdOiBmaWVsZHMsIC4uLmZpZWxkc1RvU2hvd30gPSBjb25maWcuZmllbGRzVG9TaG93O1xuICAgIGludGVyYWN0aW9uQ29uZmlnID0ge1xuICAgICAgLi4uaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICB0b29sdGlwOiB7Li4udG9vbHRpcCwgY29uZmlnOiB7Li4uY29uZmlnLCBmaWVsZHNUb1Nob3d9fVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gey4uLnN0YXRlLCBpbnRlcmFjdGlvbkNvbmZpZ307XG59XG4vKipcbiAqIHVwZGF0ZSBsYXllciBibGVuZGluZyBtb2RlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlTGF5ZXJCbGVuZGluZ1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVXBkYXRlTGF5ZXJCbGVuZGluZ1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBsYXllckJsZW5kaW5nOiBhY3Rpb24ubW9kZVxufSk7XG5cbi8qKlxuICogdXBkYXRlIG92ZXJsYXkgYmxlbmRpbmcgbW9kZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZU92ZXJsYXlCbGVuZGluZ1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVXBkYXRlT3ZlcmxheUJsZW5kaW5nVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIG92ZXJsYXlCbGVuZGluZzogYWN0aW9uLm1vZGVcbn0pO1xuXG4vKipcbiAqIERpc3BsYXkgZGF0YXNldCB0YWJsZSBpbiBhIG1vZGFsXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgc2hvd0RhdGFzZXRUYWJsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuU2hvd0RhdGFzZXRUYWJsZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0aW5nRGF0YXNldDogYWN0aW9uLmRhdGFJZFxuICB9O1xufTtcblxuLyoqXG4gKiBBZGQgY3VzdG9tIGNvbG9yIGZvciBkYXRhc2V0cyBhbmQgbGF5ZXJzXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlVGFibGVDb2xvclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVXBkYXRlRGF0YXNldENvbG9yVXBkYXRlclxuKTogVmlzU3RhdGUgPT4ge1xuICByZXR1cm4gdXBkYXRlRGF0YXNldFByb3BzVXBkYXRlcihzdGF0ZSwge2RhdGFJZDogYWN0aW9uLmRhdGFJZCwgcHJvcHM6IHtjb2xvcjogYWN0aW9uLm5ld0NvbG9yfX0pO1xufTtcblxuLyoqXG4gKiByZXNldCB2aXNTdGF0ZSB0byBpbml0aWFsIFN0YXRlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVzZXRNYXBDb25maWdVcGRhdGVyID0gKHN0YXRlOiBWaXNTdGF0ZSk6IFZpc1N0YXRlID0+ICh7XG4gIC4uLklOSVRJQUxfVklTX1NUQVRFLFxuICAuLi5zdGF0ZS5pbml0aWFsU3RhdGUsXG4gIGluaXRpYWxTdGF0ZTogc3RhdGUuaW5pdGlhbFN0YXRlXG59KTtcblxuLyoqXG4gKiBQcm9wYWdhdGUgYHZpc1N0YXRlYCByZWR1Y2VyIHdpdGggYSBuZXcgY29uZmlndXJhdGlvbi4gQ3VycmVudCBjb25maWcgd2lsbCBiZSBvdmVycmlkZS5cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZWNlaXZlTWFwQ29uZmlnVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7XG4gICAgcGF5bG9hZDoge2NvbmZpZyA9IHt9LCBvcHRpb25zID0ge319XG4gIH06IHtcbiAgICB0eXBlPzogdHlwZW9mIEFjdGlvblR5cGVzLlJFQ0VJVkVfTUFQX0NPTkZJRztcbiAgICBwYXlsb2FkOiBSZWNlaXZlTWFwQ29uZmlnUGF5bG9hZDtcbiAgfVxuKTogVmlzU3RhdGUgPT4ge1xuICBpZiAoIWNvbmZpZy52aXNTdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHtrZWVwRXhpc3RpbmdDb25maWd9ID0gb3B0aW9ucztcblxuICAvLyByZXNldCBjb25maWcgaWYga2VlcEV4aXN0aW5nQ29uZmlnIGlzIGZhbHN5XG4gIGxldCBtZXJnZWRTdGF0ZSA9ICFrZWVwRXhpc3RpbmdDb25maWcgPyByZXNldE1hcENvbmZpZ1VwZGF0ZXIoc3RhdGUpIDogc3RhdGU7XG4gIGZvciAoY29uc3QgbWVyZ2VyIG9mIHN0YXRlLm1lcmdlcnMpIHtcbiAgICBpZiAoaXNWYWxpZE1lcmdlcihtZXJnZXIpICYmIGhhc1Byb3BzVG9NZXJnZShjb25maWcudmlzU3RhdGUsIG1lcmdlci5wcm9wKSkge1xuICAgICAgbWVyZ2VkU3RhdGUgPSBtZXJnZXIubWVyZ2UoXG4gICAgICAgIG1lcmdlZFN0YXRlLFxuICAgICAgICBnZXRQcm9wVmFsdWVUb01lcmdlcihjb25maWcudmlzU3RhdGUsIG1lcmdlci5wcm9wLCBtZXJnZXIudG9NZXJnZVByb3ApLFxuICAgICAgICAvLyBmcm9tQ29uZmlnXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlZFN0YXRlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGxheWVyIGhvdmVyIGV2ZW50IHdpdGggaG92ZXJlZCBvYmplY3RcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBsYXllckhvdmVyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5PbkxheWVySG92ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgaG92ZXJJbmZvOiB7XG4gICAgLy8gZGVjay5nbCBpbmZvIGlzIG11dGFibGVcbiAgICAuLi5hY3Rpb24uaW5mbyxcbiAgICAuLi4oTnVtYmVyLmlzRmluaXRlKGFjdGlvbi5tYXBJbmRleCkgPyB7bWFwSW5kZXg6IGFjdGlvbi5tYXBJbmRleH0gOiB7fSlcbiAgfVxufSk7XG5cbi8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuLyoqXG4gKiBVcGRhdGUgYGludGVyYWN0aW9uQ29uZmlnYFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyYWN0aW9uQ29uZmlnQ2hhbmdlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5JbnRlcmFjdGlvbkNvbmZpZ0NoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge2NvbmZpZ30gPSBhY3Rpb247XG5cbiAgY29uc3QgaW50ZXJhY3Rpb25Db25maWcgPSB7XG4gICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWcsXG4gICAgLi4ue1tjb25maWcuaWRdOiBjb25maWd9XG4gIH07XG5cbiAgLy8gRG9uJ3QgZW5hYmxlIHRvb2x0aXAgYW5kIGJydXNoIGF0IHRoZSBzYW1lIHRpbWVcbiAgLy8gYnV0IGNvb3JkaW5hdGVzIGNhbiBiZSBzaG93biBhdCBhbGwgdGltZVxuICBjb25zdCBjb250cmFkaWN0ID0gWydicnVzaCcsICd0b29sdGlwJ107XG5cbiAgaWYgKFxuICAgIGNvbnRyYWRpY3QuaW5jbHVkZXMoY29uZmlnLmlkKSAmJlxuICAgIGNvbmZpZy5lbmFibGVkICYmXG4gICAgIXN0YXRlLmludGVyYWN0aW9uQ29uZmlnW2NvbmZpZy5pZF0uZW5hYmxlZFxuICApIHtcbiAgICAvLyBvbmx5IGVuYWJsZSBvbmUgaW50ZXJhY3Rpb24gYXQgYSB0aW1lXG4gICAgY29udHJhZGljdC5mb3JFYWNoKGsgPT4ge1xuICAgICAgaWYgKGsgIT09IGNvbmZpZy5pZCkge1xuICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZ1trXSA9IHsuLi5pbnRlcmFjdGlvbkNvbmZpZ1trXSwgZW5hYmxlZDogZmFsc2V9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgaW50ZXJhY3Rpb25Db25maWdcbiAgfTtcblxuICBpZiAoY29uZmlnLmlkID09PSAnZ2VvY29kZXInICYmICFjb25maWcuZW5hYmxlZCkge1xuICAgIHJldHVybiByZW1vdmVEYXRhc2V0VXBkYXRlcihuZXdTdGF0ZSwge2RhdGFJZDogJ2dlb2NvZGVyX2RhdGFzZXQnfSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogVHJpZ2dlciBsYXllciBjbGljayBldmVudCB3aXRoIGNsaWNrZWQgb2JqZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbGF5ZXJDbGlja1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuT25MYXllckNsaWNrVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIG1vdXNlUG9zOiBzdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZy5jb29yZGluYXRlLmVuYWJsZWRcbiAgICA/IHtcbiAgICAgICAgLi4uc3RhdGUubW91c2VQb3MsXG4gICAgICAgIHBpbm5lZDogc3RhdGUubW91c2VQb3MucGlubmVkID8gbnVsbCA6IGNsb25lRGVlcChzdGF0ZS5tb3VzZVBvcylcbiAgICAgIH1cbiAgICA6IHN0YXRlLm1vdXNlUG9zLFxuICBjbGlja2VkOiBhY3Rpb24uaW5mbyAmJiBhY3Rpb24uaW5mby5waWNrZWQgPyBhY3Rpb24uaW5mbyA6IG51bGxcbn0pO1xuXG4vKipcbiAqIFRyaWdnZXIgbWFwIGNsaWNrIGV2ZW50LCB1bnNlbGVjdCBjbGlja2VkIG9iamVjdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcENsaWNrVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLk9uTWFwQ2xpY2tVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgY2xpY2tlZDogbnVsbFxuICB9O1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIG1hcCBtb3ZlIGV2ZW50XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbW91c2VNb3ZlVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZXZ0fTogVmlzU3RhdGVBY3Rpb25zLk9uTW91c2VNb3ZlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBpZiAoT2JqZWN0LnZhbHVlcyhzdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZykuc29tZShjb25maWcgPT4gY29uZmlnLmVuYWJsZWQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgbW91c2VQb3M6IHtcbiAgICAgICAgLi4uc3RhdGUubW91c2VQb3MsXG4gICAgICAgIC4uLihBcnJheS5pc0FycmF5KGV2dC5wb2ludCkgPyB7bW91c2VQb3NpdGlvbjogWy4uLmV2dC5wb2ludF19IDoge30pLFxuICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShldnQubG5nTGF0KSA/IHtjb29yZGluYXRlOiBbLi4uZXZ0LmxuZ0xhdF19IDoge30pXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn07XG4vKipcbiAqIFRvZ2dsZSB2aXNpYmlsaXR5IG9mIGEgbGF5ZXIgZm9yIGEgc3BsaXQgbWFwXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlU3BsaXRNYXBVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogTWFwU3RhdGVBY3Rpb25zLlRvZ2dsZVNwbGl0TWFwVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT5cbiAgc3RhdGUuc3BsaXRNYXBzICYmIHN0YXRlLnNwbGl0TWFwcy5sZW5ndGggPT09IDBcbiAgICA/IHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIC8vIG1heWJlIHdlIHNob3VsZCB1c2UgYW4gYXJyYXkgdG8gc3RvcmUgc3RhdGUgZm9yIGEgc2luZ2xlIG1hcCBhcyB3ZWxsXG4gICAgICAgIC8vIGlmIGN1cnJlbnQgbWFwcyBsZW5ndGggaXMgZXF1YWwgdG8gMCBpdCBtZWFucyB0aGF0IHdlIGFyZSBhYm91dCB0byBzcGxpdCB0aGUgdmlld1xuICAgICAgICBzcGxpdE1hcHM6IGNvbXB1dGVTcGxpdE1hcExheWVycyhzdGF0ZS5sYXllcnMsIHtkdXBsaWNhdGU6IGZhbHNlfSlcbiAgICAgIH1cbiAgICA6IGNsb3NlU3BlY2lmaWNNYXBBdEluZGV4KHN0YXRlLCBhY3Rpb24pO1xuXG4vKipcbiAqIFRvZ2dsZSB2aXNpYmlsaXR5IG9mIGEgbGF5ZXIgaW4gYSBzcGxpdCBtYXBcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVMYXllckZvck1hcFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge21hcEluZGV4LCBsYXllcklkfTogVmlzU3RhdGVBY3Rpb25zLlRvZ2dsZUxheWVyRm9yTWFwVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCB7c3BsaXRNYXBzfSA9IHN0YXRlO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3BsaXRNYXBzOiBzcGxpdE1hcHMubWFwKChzbSwgaSkgPT5cbiAgICAgIGkgPT09IG1hcEluZGV4XG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uc3BsaXRNYXBzW2ldLFxuICAgICAgICAgICAgbGF5ZXJzOiB7XG4gICAgICAgICAgICAgIC4uLnNwbGl0TWFwc1tpXS5sYXllcnMsXG4gICAgICAgICAgICAgIC8vIGlmIGxheWVySWQgbm90IGluIGxheWVycywgc2V0IGl0IHRvIHZpc2libGVcbiAgICAgICAgICAgICAgW2xheWVySWRdOiAhc3BsaXRNYXBzW2ldLmxheWVyc1tsYXllcklkXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgOiBzbVxuICAgIClcbiAgfTtcbn07XG5cbi8qKlxuICogQWRkIG5ldyBkYXRhc2V0IHRvIGB2aXNTdGF0ZWAsIHdpdGggb3B0aW9uIHRvIGxvYWQgYSBtYXAgY29uZmlnIGFsb25nIHdpdGggdGhlIGRhdGFzZXRzXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGNvbnN0IHVwZGF0ZVZpc0RhdGFVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlVwZGF0ZVZpc0RhdGFVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIC8vIGRhdGFzZXRzIGNhbiBiZSBhIHNpbmdsZSBkYXRhIGVudHJpZXMgb3IgYW4gYXJyYXkgb2YgbXVsdGlwbGUgZGF0YSBlbnRyaWVzXG4gIGNvbnN0IHtjb25maWcsIG9wdGlvbnN9ID0gYWN0aW9uO1xuXG4gIC8vIGFwcGx5IGNvbmZpZyBpZiBwYXNzZWQgZnJvbSBhY3Rpb25cbiAgLy8gVE9ETzogd2UgZG9uJ3QgaGFuZGxlIGFzeW5jIG1lcmdlcnMgaGVyZSB5ZXRcbiAgbGV0IHVwZGF0ZWRTdGF0ZSA9IGNvbmZpZ1xuICAgID8gcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIoc3RhdGUsIHtcbiAgICAgICAgcGF5bG9hZDoge2NvbmZpZywgb3B0aW9uc31cbiAgICAgIH0pXG4gICAgOiBzdGF0ZTtcblxuICBjb25zdCBkYXRhc2V0cyA9IHRvQXJyYXkoYWN0aW9uLmRhdGFzZXRzKTtcbiAgaWYgKCFkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdXBkYXRlZFN0YXRlO1xuICB9XG5cbiAgY29uc3QgY3JlYXRlRGF0YXNldFRhc2tzOiBUYXNrW10gPSBbXTtcbiAgY29uc3Qgbm90aWZpY2F0aW9uVGFza3M6IFRhc2tbXSA9IFtdO1xuXG4gIGRhdGFzZXRzLmZvckVhY2goKHtpbmZvID0ge30sIC4uLnJlc3R9LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICBjb25zdCB0YXNrID0gY3JlYXRlTmV3RGF0YUVudHJ5KHtpbmZvLCAuLi5yZXN0fSwgc3RhdGUuZGF0YXNldHMpO1xuICAgIGlmICh0YXNrKSB7XG4gICAgICBjcmVhdGVEYXRhc2V0VGFza3MucHVzaCh0YXNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aWZpY2F0aW9uVGFza3MucHVzaChcbiAgICAgICAgQUNUSU9OX1RBU0tfQUREX05PVElGSUNBVElPTigpLm1hcCgoKSA9PlxuICAgICAgICAgIGFkZE5vdGlmaWNhdGlvbihcbiAgICAgICAgICAgIGVycm9yTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byBjcmVhdGUgYSBuZXcgZGF0YXNldCBkdWUgdG8gZGF0YSB2ZXJpZmljYXRpb24gZXJyb3JzYCxcbiAgICAgICAgICAgICAgaWQ6IGBkYXRhc2V0LWZhaWxlZC0ke2RhdGFzZXRJbmRleH1gXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGRhdGFzZXRzQWxsU2V0dGxlZFRhc2sgPSBjcmVhdGVEYXRhc2V0VGFza3MubGVuZ3RoXG4gICAgPyBUYXNrLmFsbFNldHRsZWQoY3JlYXRlRGF0YXNldFRhc2tzKS5tYXAocmVzdWx0cyA9PlxuICAgICAgICBjcmVhdGVOZXdEYXRhc2V0U3VjY2Vzcyh7cmVzdWx0cywgYWRkVG9NYXBPcHRpb25zOiBvcHRpb25zfSlcbiAgICAgIClcbiAgICA6IG51bGw7XG5cbiAgaWYgKGRhdGFzZXRzQWxsU2V0dGxlZFRhc2spIHtcbiAgICB1cGRhdGVkU3RhdGUgPSBzZXRMb2FkaW5nSW5kaWNhdG9yVXBkYXRlcih1cGRhdGVkU3RhdGUsIHBheWxvYWRfKHtjaGFuZ2U6IDEsIHR5cGU6ICcnfSkpO1xuICB9XG5cbiAgcmV0dXJuIHdpdGhUYXNrKHVwZGF0ZWRTdGF0ZSwgW1xuICAgIC4uLihkYXRhc2V0c0FsbFNldHRsZWRUYXNrID8gW2RhdGFzZXRzQWxsU2V0dGxlZFRhc2tdIDogW10pLFxuICAgIC4uLm5vdGlmaWNhdGlvblRhc2tzXG4gIF0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU5ld0RhdGFzZXRTdWNjZXNzVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFBheWxvYWRBY3Rpb248Q3JlYXRlTmV3RGF0YXNldFN1Y2Nlc3NQYXlsb2FkPlxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCB7cmVzdWx0cywgYWRkVG9NYXBPcHRpb25zfSA9IGFjdGlvbi5wYXlsb2FkO1xuICBjb25zdCBub3RpZmljYXRpb25UYXNrczogVGFza1tdID0gW107XG5cbiAgY29uc3QgbmV3RGF0YUVudHJpZXMgPSByZXN1bHRzLnJlZHVjZSgoYWNjdSwgcmVzdWx0LCBpZHgpID0+IHtcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSByZXN1bHQudmFsdWU7XG4gICAgICByZXR1cm4gey4uLmFjY3UsIFtkYXRhc2V0LmlkXTogZGF0YXNldH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNob3cgZXJyb3Igbm90aWZpY2F0aW9uIG9uIFVJXG4gICAgICBub3RpZmljYXRpb25UYXNrcy5wdXNoKFxuICAgICAgICBBQ1RJT05fVEFTSygpLm1hcCgoKSA9PlxuICAgICAgICAgIGFkZE5vdGlmaWNhdGlvbihcbiAgICAgICAgICAgIGVycm9yTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYERhdGFzZXQgZXJyb3I6IEZhaWxlZCB0byBjcmVhdGUgYSBuZXcgZGF0YXNldDpcbiAgICAgICAgICAgICAgJHtyZXN1bHQucmVhc29uIHx8IChyZXN1bHQgYXMgYW55KS52YWx1ZX1gLFxuICAgICAgICAgICAgICBpZDogYGRhdGFzZXQtY3JlYXRlLWZhaWxlZC0ke2lkeH1gXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBhY2N1O1xuICAgIH1cbiAgfSwge30gYXMgRGF0YXNldHMpO1xuICAvLyBzYXZlIG5ldyBkYXRhc2V0IGVudHJ5IHRvIHN0YXRlXG4gIGNvbnN0IG1lcmdlZFN0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGRhdGFzZXRzOiBtZXJnZURhdGFzZXRzQnlPcmRlcihzdGF0ZSwgbmV3RGF0YUVudHJpZXMpXG4gIH07XG5cbiAgLy8gbWVyZ2Ugc3RhdGUgd2l0aCBjb25maWcgdG8gYmUgbWVyZ2VkXG4gIGNvbnN0IGxheWVyTWVyZ2VycyA9IHN0YXRlLm1lcmdlcnMuZmlsdGVyKG0gPT4gbS53YWl0Rm9yTGF5ZXJEYXRhKTtcbiAgY29uc3QgZGF0YXNldE1lcmdlcnMgPSBzdGF0ZS5tZXJnZXJzLmZpbHRlcihtID0+ICFsYXllck1lcmdlcnMuaW5jbHVkZXMobSkpO1xuXG4gIGNvbnN0IG5ld0RhdGFJZHMgPSBPYmplY3Qua2V5cyhuZXdEYXRhRW50cmllcyk7XG4gIGNvbnN0IHBvc3RNZXJnZXJQYXlsb2FkID0ge1xuICAgIG5ld0RhdGFJZHMsXG4gICAgb3B0aW9uczogYWRkVG9NYXBPcHRpb25zLFxuICAgIGxheWVyTWVyZ2Vyc1xuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZWRTdGF0ZSA9IGFwcGx5TWVyZ2Vyc1VwZGF0ZXIobWVyZ2VkU3RhdGUsIHtcbiAgICBtZXJnZXJzOiBkYXRhc2V0TWVyZ2VycyxcbiAgICBwb3N0TWVyZ2VyUGF5bG9hZFxuICB9KTtcblxuICByZXR1cm4gd2l0aFRhc2soXG4gICAgc2V0TG9hZGluZ0luZGljYXRvclVwZGF0ZXIodXBkYXRlZFN0YXRlLCBwYXlsb2FkXyh7Y2hhbmdlOiAtMX0pKSxcbiAgICBub3RpZmljYXRpb25UYXNrc1xuICApO1xufTtcblxuLyoqXG4gKiBBZGQgbmV3IGRhdGFzZXQgdG8gYHZpc1N0YXRlYCwgd2l0aCBvcHRpb24gdG8gbG9hZCBhIG1hcCBjb25maWcgYWxvbmcgd2l0aCB0aGUgZGF0YXNldHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TWVyZ2Vyc1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiB7XG4gICAgbWVyZ2VyczogTWVyZ2VyPGFueT5bXTtcbiAgICBwb3N0TWVyZ2VyUGF5bG9hZDogUG9zdE1lcmdlclBheWxvYWQ7XG4gIH1cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge21lcmdlcnMsIHBvc3RNZXJnZXJQYXlsb2FkfSA9IGFjdGlvbjtcblxuICAvLyBtZXJnZSBzdGF0ZSB3aXRoIGNvbmZpZyB0byBiZSBtZXJnZWRcbiAgY29uc3QgbWVyZ2VTdGF0ZVJlc3VsdCA9IG1lcmdlU3RhdGVGcm9tTWVyZ2VycyhcbiAgICBzdGF0ZSxcbiAgICB7XG4gICAgICAuLi5JTklUSUFMX1ZJU19TVEFURSxcbiAgICAgIC4uLnN0YXRlLmluaXRpYWxTdGF0ZVxuICAgIH0sXG4gICAgbWVyZ2VycyxcbiAgICAvLyBuZXdEYXRhSWRzLFxuICAgIHBvc3RNZXJnZXJQYXlsb2FkXG4gICk7XG5cbiAgLy8gaWYgYWxsIG1lcmdlZCwga2lja3VwIHBvc3QgbWVyZ2UgcHJvY2Vzc1xuICAvLyBpZiBub3Qgd2FpdFxuICByZXR1cm4gbWVyZ2VTdGF0ZVJlc3VsdC5hbGxNZXJnZWRcbiAgICA/IHBvc3RNZXJnZVVwZGF0ZXIobWVyZ2VTdGF0ZVJlc3VsdC5tZXJnZWRTdGF0ZSwgcG9zdE1lcmdlclBheWxvYWQpXG4gICAgOiBtZXJnZVN0YXRlUmVzdWx0Lm1lcmdlZFN0YXRlO1xufVxuXG4vKipcbiAqIEFkZCBuZXcgZGF0YXNldCB0byBgdmlzU3RhdGVgLCB3aXRoIG9wdGlvbiB0byBsb2FkIGEgbWFwIGNvbmZpZyBhbG9uZyB3aXRoIHRoZSBkYXRhc2V0c1xuICovXG5mdW5jdGlvbiBwb3N0TWVyZ2VVcGRhdGVyKG1lcmdlZFN0YXRlOiBWaXNTdGF0ZSwgcG9zdE1lcmdlclBheWxvYWQ6IFBvc3RNZXJnZXJQYXlsb2FkKTogVmlzU3RhdGUge1xuICBjb25zdCB7bmV3RGF0YUlkcywgb3B0aW9ucywgbGF5ZXJNZXJnZXJzfSA9IHBvc3RNZXJnZXJQYXlsb2FkO1xuICBjb25zdCBuZXdGaWx0ZXJzID0gbWVyZ2VkU3RhdGUuZmlsdGVycy5maWx0ZXIoZiA9PlxuICAgIGYuZGF0YUlkLmZpbmQoZkRhdGFJZCA9PiBuZXdEYXRhSWRzLmluY2x1ZGVzKGZEYXRhSWQpKVxuICApO1xuICBjb25zdCBkYXRhc2V0RmlsdGVyZWQ6IHN0cmluZ1tdID0gdW5pcShcbiAgICBuZXdGaWx0ZXJzLnJlZHVjZSgoYWNjdSwgZikgPT4gWy4uLmFjY3UsIC4uLmYuZGF0YUlkXSwgW10gYXMgc3RyaW5nW10pXG4gICk7XG4gIGNvbnN0IGRhdGFFbXB0eSA9IG5ld0RhdGFJZHMubGVuZ3RoIDwgMTtcblxuICBsZXQgbmV3TGF5ZXJzID0gIWRhdGFFbXB0eVxuICAgID8gbWVyZ2VkU3RhdGUubGF5ZXJzLmZpbHRlcihsID0+IGwuY29uZmlnLmRhdGFJZCAmJiBuZXdEYXRhSWRzLmluY2x1ZGVzKGwuY29uZmlnLmRhdGFJZCkpXG4gICAgOiBbXTtcblxuICBjb25zdCBuZXdEYXRhRW50cmllcyA9IG5ld0RhdGFJZHMucmVkdWNlKFxuICAgIChhY2N1LCBpZCkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICBbaWRdOiBtZXJnZWRTdGF0ZS5kYXRhc2V0c1tpZF1cbiAgICB9KSxcbiAgICB7fVxuICApO1xuXG4gIGlmICghbmV3TGF5ZXJzLmxlbmd0aCAmJiAob3B0aW9ucyB8fCB7fSkuYXV0b0NyZWF0ZUxheWVycyAhPT0gZmFsc2UpIHtcbiAgICAvLyBubyBsYXllciBtZXJnZWQsIGZpbmQgZGVmYXVsdHNcbiAgICBjb25zdCByZXN1bHQgPSBhZGREZWZhdWx0TGF5ZXJzKG1lcmdlZFN0YXRlLCBuZXdEYXRhRW50cmllcyk7XG4gICAgbWVyZ2VkU3RhdGUgPSByZXN1bHQuc3RhdGU7XG4gICAgbmV3TGF5ZXJzID0gcmVzdWx0Lm5ld0xheWVycztcbiAgfVxuXG4gIGlmIChtZXJnZWRTdGF0ZS5zcGxpdE1hcHMubGVuZ3RoKSB7XG4gICAgLy8gaWYgbWFwIGlzIHNwbGl0LCBhZGQgbmV3IGxheWVycyB0byBzcGxpdE1hcHNcbiAgICBuZXdMYXllcnMgPSBtZXJnZWRTdGF0ZS5sYXllcnMuZmlsdGVyKFxuICAgICAgbCA9PiBsLmNvbmZpZy5kYXRhSWQgJiYgbmV3RGF0YUlkcy5pbmNsdWRlcyhsLmNvbmZpZy5kYXRhSWQpXG4gICAgKTtcbiAgICBtZXJnZWRTdGF0ZSA9IHtcbiAgICAgIC4uLm1lcmdlZFN0YXRlLFxuICAgICAgc3BsaXRNYXBzOiBhZGROZXdMYXllcnNUb1NwbGl0TWFwKG1lcmdlZFN0YXRlLnNwbGl0TWFwcywgbmV3TGF5ZXJzKVxuICAgIH07XG4gIH1cblxuICAvLyBpZiBubyB0b29sdGlwcyBtZXJnZWQgYWRkIGRlZmF1bHQgdG9vbHRpcHNcbiAgbmV3RGF0YUlkcy5mb3JFYWNoKGRhdGFJZCA9PiB7XG4gICAgY29uc3QgdG9vbHRpcEZpZWxkcyA9IG1lcmdlZFN0YXRlLmludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmZpZWxkc1RvU2hvd1tkYXRhSWRdO1xuICAgIC8vIGxvYWRpbmcgZGF0YXNldDogYXV0b0NyZWF0ZVRvb2x0aXBzIGlzIGZhbHNlIGFuZCB3ZSBkb24ndCB3YW50IHRvIHJ1biBhZGREZWZhdWx0VG9vbHRpcHMgd2hlbiB0b29sdGlwRmllbGRzIGlzIGVtcHR5XG4gICAgaWYgKFxuICAgICAgb3B0aW9ucz8uYXV0b0NyZWF0ZVRvb2x0aXBzICE9PSBmYWxzZSAmJlxuICAgICAgKCFBcnJheS5pc0FycmF5KHRvb2x0aXBGaWVsZHMpIHx8ICF0b29sdGlwRmllbGRzLmxlbmd0aClcbiAgICApIHtcbiAgICAgIC8vIGFkZGluZyBkYXRhc2V0OiBhdXRvQ3JlYXRlVG9vbHRpcHMgaXMgdHJ1ZVxuICAgICAgbWVyZ2VkU3RhdGUgPSBhZGREZWZhdWx0VG9vbHRpcHMobWVyZ2VkU3RhdGUsIG5ld0RhdGFFbnRyaWVzW2RhdGFJZF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdXBkYXRlZERhdGFzZXRzID0gZGF0YUVtcHR5XG4gICAgPyBPYmplY3Qua2V5cyhtZXJnZWRTdGF0ZS5kYXRhc2V0cylcbiAgICA6IHVuaXEoT2JqZWN0LmtleXMobmV3RGF0YUVudHJpZXMpLmNvbmNhdChkYXRhc2V0RmlsdGVyZWQpKTtcblxuICBsZXQgdXBkYXRlZFN0YXRlID0gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhKG1lcmdlZFN0YXRlLCB1cGRhdGVkRGF0YXNldHMsIHVuZGVmaW5lZCk7XG5cbiAgLy8gcmVnaXN0ZXIgbGF5ZXIgYW5pbWF0aW9uIGRvbWFpbixcbiAgLy8gbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXIgbGF5ZXIgZGF0YSBpcyBjYWxjdWxhdGVkXG4gIHVwZGF0ZWRTdGF0ZSA9IHVwZGF0ZUFuaW1hdGlvbkRvbWFpbih1cGRhdGVkU3RhdGUpO1xuXG4gIC8vIHRyeSB0byBwcm9jZXNzIGxheWVyTWVyZ2VycyBhZnRlciBkYXRhc2V0K2RhdGFzZXRNZXJnZXJzXG4gIHVwZGF0ZWRTdGF0ZSA9XG4gICAgbGF5ZXJNZXJnZXJzICYmIGxheWVyTWVyZ2Vycy5sZW5ndGggPiAwXG4gICAgICA/IGFwcGx5TWVyZ2Vyc1VwZGF0ZXIodXBkYXRlZFN0YXRlLCB7XG4gICAgICAgICAgbWVyZ2VyczogbGF5ZXJNZXJnZXJzLFxuICAgICAgICAgIHBvc3RNZXJnZXJQYXlsb2FkOiB7Li4ucG9zdE1lcmdlclBheWxvYWQsIGxheWVyTWVyZ2VyczogW119XG4gICAgICAgIH0pXG4gICAgICA6IHVwZGF0ZWRTdGF0ZTtcblxuICAvLyBjZW50ZXIgdGhlIG1hcCBvbmNlIHRoZSBkYXRhc2V0IGlzIGNyZWF0ZWRcbiAgaWYgKG5ld0xheWVycy5sZW5ndGggJiYgKG9wdGlvbnMgfHwge30pLmNlbnRlck1hcCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IGZpbmRNYXBCb3VuZHMobmV3TGF5ZXJzKTtcbiAgICBpZiAoYm91bmRzKSB7XG4gICAgICBjb25zdCBmaXRCb3VuZHNUYXNrID0gQUNUSU9OX1RBU0tfRklUX0JPVU5EUygpLm1hcCgoKSA9PiB7XG4gICAgICAgIHJldHVybiBmaXRNYXBCb3VuZHMoYm91bmRzKTtcbiAgICAgIH0pO1xuICAgICAgdXBkYXRlZFN0YXRlID0gd2l0aFRhc2sodXBkYXRlZFN0YXRlLCBmaXRCb3VuZHNUYXNrKTtcbiAgICB9XG4gIH1cblxuICAvLyBuZWVkIHRvIGNlbnRlciBtYXAgaGVyZSBpZiB3ZSBoYXZlIG5ldyBsYXllcnNcbiAgcmV0dXJuIHVwZGF0ZWRTdGF0ZTtcbn1cblxuLyoqXG4gKiBSZW5hbWUgYW4gZXhpc3RpbmcgZGF0YXNldCBpbiBgdmlzU3RhdGVgXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuYW1lRGF0YXNldFVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuUmVuYW1lRGF0YXNldFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgcmV0dXJuIHVwZGF0ZURhdGFzZXRQcm9wc1VwZGF0ZXIoc3RhdGUsIHtkYXRhSWQ6IGFjdGlvbi5kYXRhSWQsIHByb3BzOiB7bGFiZWw6IGFjdGlvbi5sYWJlbH19KTtcbn1cblxuY29uc3QgQUxMT1dFRF9VUERBVEVfREFUQVNFVF9QUk9QUyA9IFsnbGFiZWwnLCAnY29sb3InLCAnbWV0YWRhdGEnXTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgcHJvcGVydGllcyBiZWZvcmUgdXBkYXRpbmcgdGhlIGRhdGFzZXQuXG4gKiBNYWtlcyBzdXJlIGVhY2ggcHJvcGVydHkgaXMgaW4gdGhlIGFsbG93ZWQgbGlzdFxuICogTWFrZXMgc3VyZSBjb2xvciB2YWx1ZSBpcyBSR0JcbiAqIFBlcmZvcm1zIGRlZXAgbWVyZ2Ugd2hlbiB1cGRhdGluZyBtZXRhZGF0YVxuICovXG5jb25zdCB2YWxpZGF0ZURhdGFzZXRVcGRhdGVQcm9wcyA9IChwcm9wcywgZGF0YXNldCkgPT4ge1xuICBjb25zdCB2YWxpZGF0ZWRQcm9wcyA9IE9iamVjdC5lbnRyaWVzKHByb3BzKS5yZWR1Y2UoKGFjYywgZW50cnkpID0+IHtcbiAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcbiAgICAvLyBpcyBpdCBhbGxvd2VkID9cbiAgICBpZiAoIUFMTE9XRURfVVBEQVRFX0RBVEFTRVRfUFJPUFMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBhcmUgYWRkaW5nIGEgY29sb3IgYnV0IGl0IGlzIG5vdCBSR0Igd2UgZG9uJ3QgYWNjZXB0IHRoZSB2YWx1ZVxuICAgIC8vIGluIHRoZSBmdXR1cmUgYXMgd2UgYWRkIG1vcmUgcHJvcHMgd2Ugc2hvdWxkIGNoYW5nZSB0aGlzIGlmIGludG8gYSBzd2l0Y2hcbiAgICBpZiAoa2V5ID09PSAnY29sb3InICYmICFpc1JnYkNvbG9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICAvLyBkbyB3ZSBuZWVkIGRlZXAgbWVyZ2UgP1xuICAgIHJldHVybiB7Li4uYWNjLCBba2V5XTogaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyBkZWVwbWVyZ2UoZGF0YXNldFtrZXldIHx8IHt9LCB2YWx1ZSkgOiB2YWx1ZX07XG4gIH0sIHt9KTtcblxuICByZXR1cm4gdmFsaWRhdGVkUHJvcHM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBEYXRhc2V0IHByb3BzIChsYWJlbCwgY29sb3IsIG1ldGEpLiBEbyBub3QgdXNlIHRvIHVwZGF0ZSBkYXRhIG9yIGFueSByZWxhdGVkIHByb3BlcnRpZXNcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEYXRhc2V0UHJvcHNVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlVwZGF0ZURhdGFzZXRQcm9wc1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge2RhdGFJZCwgcHJvcHN9ID0gYWN0aW9uO1xuICBjb25zdCB7ZGF0YXNldHN9ID0gc3RhdGU7XG4gIGNvbnN0IGV4aXN0aW5nID0gZGF0YXNldHNbZGF0YUlkXTtcblxuICBpZiAoZXhpc3RpbmcpIHtcbiAgICBjb25zdCB2YWxpZGF0ZWRQcm9wcyA9IHZhbGlkYXRlRGF0YXNldFVwZGF0ZVByb3BzKHByb3BzLCBleGlzdGluZyk7XG4gICAgLy8gIHZhbGlkYXRlIHByb3BzOiBqdXN0IGNvbG9yIGZvciBub3dcbiAgICAvLyAgd2Ugb25seSBhbGxvdyBsYWJlbCwgY29sb3IgYW5kIG1ldGEgdG8gYmUgdXBkYXRlZFxuICAgIC8vIGNvbnN0IG5ld1RhYmxlID0gY29weVRhYmxlQW5kVXBkYXRlKGV4aXN0aW5nLCB2YWxpZGF0ZWRQcm9wcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZGF0YXNldHM6IHtcbiAgICAgICAgLi4uZGF0YXNldHMsXG4gICAgICAgIFtkYXRhSWRdOiBjb3B5VGFibGVBbmRVcGRhdGUoZXhpc3RpbmcsIHZhbGlkYXRlZFByb3BzKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogV2hlbiBhIHVzZXIgY2xpY2tzIG9uIHRoZSBzcGVjaWZpYyBtYXAgY2xvc2luZyBpY29uXG4gKiB0aGUgYXBwbGljYXRpb24gd2lsbCBjbG9zZSB0aGUgc2VsZWN0ZWQgbWFwXG4gKiBhbmQgd2lsbCBtZXJnZSB0aGUgcmVtYWluaW5nIG9uZSB3aXRoIHRoZSBnbG9iYWwgc3RhdGVcbiAqIFRPRE86IGkgdGhpbmsgaW4gdGhlIGZ1dHVyZSB0aGlzIGFjdGlvbiBzaG91bGQgYmUgY2FsbGVkIG1lcmdlIG1hcCBsYXllcnMgd2l0aCBnbG9iYWwgc2V0dGluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZVNwZWNpZmljTWFwQXRJbmRleDxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgYWN0aW9uOiBNYXBTdGF0ZUFjdGlvbnMuVG9nZ2xlU3BsaXRNYXBVcGRhdGVyQWN0aW9uXG4pOiBTIHtcbiAgLy8gcmV0cmlldmUgbGF5ZXJzIG1ldGEgZGF0YSBmcm9tIHRoZSByZW1haW5pbmcgbWFwIHRoYXQgd2UgbmVlZCB0byBrZWVwXG4gIGNvbnN0IGluZGV4VG9SZXRyaWV2ZSA9IDEgLSBhY3Rpb24ucGF5bG9hZDtcbiAgY29uc3QgbWFwTGF5ZXJzID0gc3RhdGUuc3BsaXRNYXBzW2luZGV4VG9SZXRyaWV2ZV0/LmxheWVycztcbiAgY29uc3Qge2xheWVyc30gPSBzdGF0ZTtcblxuICAvLyB1cGRhdGUgbGF5ZXIgdmlzaWJpbGl0eVxuICBjb25zdCBuZXdMYXllcnMgPSBsYXllcnMubWFwKGxheWVyID0+XG4gICAgbWFwTGF5ZXJzICYmICFtYXBMYXllcnNbbGF5ZXIuaWRdICYmIGxheWVyLmNvbmZpZy5pc1Zpc2libGVcbiAgICAgID8gbGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgICAgICAgIC8vIGlmIGxheWVyLmlkIGlzIG5vdCBpbiBtYXBMYXllcnMsIGl0IHNob3VsZCBiZSBpblZpc2libGVcbiAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICA6IGxheWVyXG4gICk7XG5cbiAgLy8gZGVsZXRlIG1hcFxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogbmV3TGF5ZXJzLFxuICAgIHNwbGl0TWFwczogW11cbiAgfTtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGZpbGUgbG9hZGluZyBkaXNwYXRjaCBgYWRkRGF0YVRvTWFwYCBpZiBzdWNjZWVkLCBvciBgbG9hZEZpbGVzRXJyYCBpZiBmYWlsZWRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBsb2FkRmlsZXNVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxvYWRGaWxlc1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgY29uc3Qge2ZpbGVzLCBvbkZpbmlzaCA9IGxvYWRGaWxlc1N1Y2Nlc3N9ID0gYWN0aW9uO1xuICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IGZpbGVMb2FkaW5nUHJvZ3Jlc3MgPSBBcnJheS5mcm9tKGZpbGVzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGYsIGkpID0+IG1lcmdlXyhpbml0aWFsRmlsZUxvYWRpbmdQcm9ncmVzcyhmLCBpKSkoYWNjdSksXG4gICAge31cbiAgKTtcblxuICBjb25zdCBmaWxlTG9hZGluZyA9IHtcbiAgICBmaWxlQ2FjaGU6IFtdLFxuICAgIGZpbGVzVG9Mb2FkOiBmaWxlcyxcbiAgICBvbkZpbmlzaFxuICB9O1xuXG4gIGNvbnN0IG5leHRTdGF0ZSA9IG1lcmdlXyh7ZmlsZUxvYWRpbmdQcm9ncmVzcywgZmlsZUxvYWRpbmd9KShzdGF0ZSk7XG5cbiAgcmV0dXJuIGxvYWROZXh0RmlsZVVwZGF0ZXIobmV4dFN0YXRlKTtcbn07XG5cbi8qKlxuICogU3VjZXNzZnVsbHkgbG9hZGVkIG9uZSBmaWxlLCBtb3ZlIG9uIHRvIHRoZSBuZXh0IG9uZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRGaWxlU3RlcFN1Y2Nlc3NVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxvYWRGaWxlU3RlcFN1Y2Nlc3NBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgaWYgKCFzdGF0ZS5maWxlTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7ZmlsZU5hbWUsIGZpbGVDYWNoZX0gPSBhY3Rpb247XG4gIGNvbnN0IHtmaWxlc1RvTG9hZCwgb25GaW5pc2h9ID0gc3RhdGUuZmlsZUxvYWRpbmc7XG4gIGNvbnN0IHN0YXRlV2l0aFByb2dyZXNzID0gdXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIoc3RhdGUsIHtcbiAgICBmaWxlTmFtZSxcbiAgICBwcm9ncmVzczoge3BlcmNlbnQ6IDEsIG1lc3NhZ2U6ICdEb25lJ31cbiAgfSk7XG5cbiAgLy8gc2F2ZSBwcm9jZXNzZWQgZmlsZSB0byBmaWxlQ2FjaGVcbiAgY29uc3Qgc3RhdGVXaXRoQ2FjaGUgPSBwaWNrXygnZmlsZUxvYWRpbmcnKShtZXJnZV8oe2ZpbGVDYWNoZX0pKShzdGF0ZVdpdGhQcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHdpdGhUYXNrKFxuICAgIHN0YXRlV2l0aENhY2hlLFxuICAgIERFTEFZX1RBU0soMjAwKS5tYXAoZmlsZXNUb0xvYWQubGVuZ3RoID8gbG9hZE5leHRGaWxlIDogKCkgPT4gb25GaW5pc2goZmlsZUNhY2hlKSlcbiAgKTtcbn1cblxuLy8gd2l0aFRhc2s8VD4oc3RhdGU6IFQsIHRhc2s6IGFueSk6IFRcblxuLyoqXG4gKlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWROZXh0RmlsZVVwZGF0ZXIoc3RhdGU6IFZpc1N0YXRlKTogVmlzU3RhdGUge1xuICBpZiAoIXN0YXRlLmZpbGVMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHtmaWxlc1RvTG9hZH0gPSBzdGF0ZS5maWxlTG9hZGluZztcbiAgY29uc3QgW2ZpbGUsIC4uLnJlbWFpbmluZ0ZpbGVzVG9Mb2FkXSA9IGZpbGVzVG9Mb2FkO1xuXG4gIC8vIHNhdmUgZmlsZXNUb0xvYWQgdG8gc3RhdGVcbiAgY29uc3QgbmV4dFN0YXRlID0gcGlja18oJ2ZpbGVMb2FkaW5nJykobWVyZ2VfKHtmaWxlc1RvTG9hZDogcmVtYWluaW5nRmlsZXNUb0xvYWR9KSkoc3RhdGUpO1xuXG4gIGNvbnN0IHN0YXRlV2l0aFByb2dyZXNzID0gdXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIobmV4dFN0YXRlLCB7XG4gICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICBwcm9ncmVzczoge3BlcmNlbnQ6IDAsIG1lc3NhZ2U6ICdsb2FkaW5nLi4uJ31cbiAgfSk7XG5cbiAgY29uc3Qge2xvYWRlcnMsIGxvYWRPcHRpb25zfSA9IHN0YXRlO1xuICByZXR1cm4gd2l0aFRhc2soXG4gICAgc3RhdGVXaXRoUHJvZ3Jlc3MsXG4gICAgbWFrZUxvYWRGaWxlVGFzayhcbiAgICAgIGZpbGUsXG4gICAgICBuZXh0U3RhdGUuZmlsZUxvYWRpbmcgJiYgbmV4dFN0YXRlLmZpbGVMb2FkaW5nLmZpbGVDYWNoZSxcbiAgICAgIGxvYWRlcnMsXG4gICAgICBsb2FkT3B0aW9uc1xuICAgIClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VMb2FkRmlsZVRhc2soZmlsZSwgZmlsZUNhY2hlLCBsb2FkZXJzOiBMb2FkZXJbXSA9IFtdLCBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBMT0FEX0ZJTEVfVEFTSyh7ZmlsZSwgZmlsZUNhY2hlLCBsb2FkZXJzLCBsb2FkT3B0aW9uc30pLmJpbWFwKFxuICAgIC8vIHByZXR0aWVyIGlnbm9yZVxuICAgIC8vIHN1Y2Nlc3NcbiAgICBnZW4gPT5cbiAgICAgIG5leHRGaWxlQmF0Y2goe1xuICAgICAgICBnZW4sXG4gICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgIG9uRmluaXNoOiByZXN1bHQgPT5cbiAgICAgICAgICBwcm9jZXNzRmlsZUNvbnRlbnQoe1xuICAgICAgICAgICAgY29udGVudDogcmVzdWx0LFxuICAgICAgICAgICAgZmlsZUNhY2hlXG4gICAgICAgICAgfSlcbiAgICAgIH0pLFxuXG4gICAgLy8gZXJyb3JcbiAgICBlcnIgPT4gbG9hZEZpbGVzRXJyKGZpbGUubmFtZSwgZXJyKVxuICApO1xufVxuXG4vKipcbiAqXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVDb250ZW50VXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Qcm9jZXNzRmlsZUNvbnRlbnRVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtjb250ZW50LCBmaWxlQ2FjaGV9ID0gYWN0aW9uLnBheWxvYWQ7XG5cbiAgY29uc3Qgc3RhdGVXaXRoUHJvZ3Jlc3MgPSB1cGRhdGVGaWxlTG9hZGluZ1Byb2dyZXNzVXBkYXRlcihzdGF0ZSwge1xuICAgIGZpbGVOYW1lOiBjb250ZW50LmZpbGVOYW1lLFxuICAgIHByb2dyZXNzOiB7cGVyY2VudDogMSwgbWVzc2FnZTogJ3Byb2Nlc3NpbmcuLi4nfVxuICB9KTtcblxuICByZXR1cm4gd2l0aFRhc2soXG4gICAgc3RhdGVXaXRoUHJvZ3Jlc3MsXG4gICAgUFJPQ0VTU19GSUxFX0RBVEEoe2NvbnRlbnQsIGZpbGVDYWNoZX0pLmJpbWFwKFxuICAgICAgcmVzdWx0ID0+IGxvYWRGaWxlU3RlcFN1Y2Nlc3Moe2ZpbGVOYW1lOiBjb250ZW50LmZpbGVOYW1lLCBmaWxlQ2FjaGU6IHJlc3VsdH0pLFxuICAgICAgZXJyID0+IGxvYWRGaWxlc0Vycihjb250ZW50LmZpbGVOYW1lLCBlcnIpXG4gICAgKVxuICApO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQcm9ncmVzcyhwcmV2UHJvZ3Jlc3MgPSB7fSwgcHJvZ3Jlc3MpIHtcbiAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gcmVjZWl2aW5nIHF1ZXJ5IG1ldGFkYXRhIG9yIG90aGVyIGNhc2VzIHdlIGRvbid0XG4gIC8vIGhhdmUgYW4gdXBkYXRlIGZvciB0aGUgdXNlci5cbiAgaWYgKCFwcm9ncmVzcyB8fCAhcHJvZ3Jlc3MucGVyY2VudCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGVyY2VudDogcHJvZ3Jlc3MucGVyY2VudFxuICB9O1xufVxuXG4vKipcbiAqIGdldHMgY2FsbGVkIHdpdGggcGF5bG9hZCA9IEFzeW5jR2VuZXJhdG9yPD8/Pz5cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBuZXh0RmlsZUJhdGNoVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7XG4gICAgcGF5bG9hZDoge2dlbiwgZmlsZU5hbWUsIHByb2dyZXNzLCBhY2N1bXVsYXRlZCwgb25GaW5pc2h9XG4gIH06IFZpc1N0YXRlQWN0aW9ucy5OZXh0RmlsZUJhdGNoVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBzdGF0ZVdpdGhQcm9ncmVzcyA9IHVwZGF0ZUZpbGVMb2FkaW5nUHJvZ3Jlc3NVcGRhdGVyKHN0YXRlLCB7XG4gICAgZmlsZU5hbWUsXG4gICAgcHJvZ3Jlc3M6IHBhcnNlUHJvZ3Jlc3Moc3RhdGUuZmlsZUxvYWRpbmdQcm9ncmVzc1tmaWxlTmFtZV0sIHByb2dyZXNzKVxuICB9KTtcblxuICByZXR1cm4gd2l0aFRhc2soc3RhdGVXaXRoUHJvZ3Jlc3MsIFtcbiAgICAuLi4oZ2V0QXBwbGljYXRpb25Db25maWcoKS51c2VBcnJvd1Byb2dyZXNzaXZlTG9hZGluZyAmJlxuICAgIGZpbGVOYW1lLmVuZHNXaXRoKCdhcnJvdycpICYmXG4gICAgYWNjdW11bGF0ZWQ/LmRhdGE/Lmxlbmd0aCA+IDBcbiAgICAgID8gW1xuICAgICAgICAgIFBST0NFU1NfRklMRV9EQVRBKHtjb250ZW50OiBhY2N1bXVsYXRlZCwgZmlsZUNhY2hlOiBbXX0pLmJpbWFwKFxuICAgICAgICAgICAgcmVzdWx0ID0+IGxvYWRGaWxlc1N1Y2Nlc3MocmVzdWx0KSxcbiAgICAgICAgICAgIGVyciA9PiBsb2FkRmlsZXNFcnIoZmlsZU5hbWUsIGVycilcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIDogW10pLFxuICAgIFVOV1JBUF9UQVNLKGdlbi5uZXh0KCkpLmJpbWFwKFxuICAgICAgKHt2YWx1ZSwgZG9uZX0pID0+IHtcbiAgICAgICAgcmV0dXJuIGRvbmVcbiAgICAgICAgICA/IG9uRmluaXNoKGFjY3VtdWxhdGVkKVxuICAgICAgICAgIDogbmV4dEZpbGVCYXRjaCh7XG4gICAgICAgICAgICAgIGdlbixcbiAgICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgICAgIHByb2dyZXNzOiB2YWx1ZS5wcm9ncmVzcyxcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZWQ6IHZhbHVlLFxuICAgICAgICAgICAgICBvbkZpbmlzaFxuICAgICAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXJyID0+IGxvYWRGaWxlc0VycihmaWxlTmFtZSwgZXJyKVxuICAgIClcbiAgXSk7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgbG9hZGluZyBmaWxlIGVycm9yXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbG9hZEZpbGVzRXJyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZXJyb3IsIGZpbGVOYW1lfTogVmlzU3RhdGVBY3Rpb25zLkxvYWRGaWxlc0VyclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgLy8gdXBkYXRlIHVpIHdpdGggZXJyb3IgbWVzc2FnZVxuICBDb25zb2xlLndhcm4oZXJyb3IpO1xuICBpZiAoIXN0YXRlLmZpbGVMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHtmaWxlc1RvTG9hZCwgb25GaW5pc2gsIGZpbGVDYWNoZX0gPSBzdGF0ZS5maWxlTG9hZGluZztcblxuICBjb25zdCBuZXh0U3RhdGUgPSB1cGRhdGVGaWxlTG9hZGluZ1Byb2dyZXNzVXBkYXRlcihzdGF0ZSwge1xuICAgIGZpbGVOYW1lLFxuICAgIHByb2dyZXNzOiB7ZXJyb3J9XG4gIH0pO1xuXG4gIC8vIGtpY2sgb2ZmIG5leHQgZmlsZSBvciBmaW5pc2hcbiAgcmV0dXJuIHdpdGhUYXNrKFxuICAgIG5leHRTdGF0ZSxcbiAgICBERUxBWV9UQVNLKDIwMCkubWFwKGZpbGVzVG9Mb2FkLmxlbmd0aCA/IGxvYWROZXh0RmlsZSA6ICgpID0+IG9uRmluaXNoKGZpbGVDYWNoZSkpXG4gICk7XG59O1xuXG4vKipcbiAqIFdoZW4gc2VsZWN0IGRhdGFzZXQgZm9yIGV4cG9ydCwgYXBwbHkgY3B1IGZpbHRlciB0byBzZWxlY3RlZCBkYXRhc2V0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYXBwbHlDUFVGaWx0ZXJVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtkYXRhSWR9OiBWaXNTdGF0ZUFjdGlvbnMuQXBwbHlDUFVGaWx0ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIC8vIGFwcGx5IGNwdUZpbHRlclxuICBjb25zdCBkYXRhSWRzID0gdG9BcnJheShkYXRhSWQpO1xuXG4gIHJldHVybiBkYXRhSWRzLnJlZHVjZSgoYWNjdSwgaWQpID0+IGZpbHRlckRhdGFzZXRDUFUoYWNjdSwgaWQpLCBzdGF0ZSk7XG59O1xuXG4vKipcbiAqIFVzZXIgaW5wdXQgdG8gdXBkYXRlIHRoZSBpbmZvIG9mIHRoZSBtYXBcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRNYXBJbmZvVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5TZXRNYXBJbmZvVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIG1hcEluZm86IHtcbiAgICAuLi5zdGF0ZS5tYXBJbmZvLFxuICAgIC4uLmFjdGlvbi5pbmZvXG4gIH1cbn0pO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gdXBkYXRlIEFsbCBsYXllciBkb21haW4gYW5kIGxheWVyIGRhdGEgb2Ygc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZERlZmF1bHRMYXllcnMoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgZGF0YXNldHM6IERhdGFzZXRzXG4pOiB7c3RhdGU6IFZpc1N0YXRlOyBuZXdMYXllcnM6IExheWVyW119IHtcbiAgY29uc3QgZW1wdHk6IExheWVyW10gPSBbXTtcbiAgY29uc3QgZGVmYXVsdExheWVycyA9IE9iamVjdC52YWx1ZXMoZGF0YXNldHMpLnJlZHVjZSgoYWNjdTogTGF5ZXJbXSwgZGF0YXNldCkgPT4ge1xuICAgIGNvbnN0IGZvdW5kTGF5ZXJzID0gZmluZERlZmF1bHRMYXllcihkYXRhc2V0LCBzdGF0ZS5sYXllckNsYXNzZXMpO1xuICAgIHJldHVybiBmb3VuZExheWVycyAmJiBmb3VuZExheWVycy5sZW5ndGggPyBhY2N1LmNvbmNhdChmb3VuZExheWVycykgOiBhY2N1O1xuICB9LCBlbXB0eSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0ZToge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBsYXllcnM6IFsuLi5zdGF0ZS5sYXllcnMsIC4uLmRlZmF1bHRMYXllcnNdLFxuICAgICAgbGF5ZXJPcmRlcjogW1xuICAgICAgICAvLyBwdXQgbmV3IGxheWVycyBvbiB0b3Agb2Ygb2xkIG9uZXMgaW4gcmV2ZXJzZVxuICAgICAgICAuLi5nZXRMYXllck9yZGVyRnJvbUxheWVycyhkZWZhdWx0TGF5ZXJzKSxcbiAgICAgICAgLi4uc3RhdGUubGF5ZXJPcmRlclxuICAgICAgXVxuICAgIH0sXG4gICAgbmV3TGF5ZXJzOiBkZWZhdWx0TGF5ZXJzXG4gIH07XG59XG5cbi8qKlxuICogaGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgZGVmYXVsdCB0b29sdGlwc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YXNldFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGREZWZhdWx0VG9vbHRpcHMoc3RhdGUsIGRhdGFzZXQpIHtcbiAgY29uc3QgdG9vbHRpcEZpZWxkcyA9IGZpbmRGaWVsZHNUb1Nob3coe1xuICAgIC4uLmRhdGFzZXQsXG4gICAgbWF4RGVmYXVsdFRvb2x0aXBzOiBzdGF0ZS5tYXhEZWZhdWx0VG9vbHRpcHNcbiAgfSk7XG4gIGNvbnN0IG1lcmdlZCA9IHtcbiAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmNvbmZpZy5maWVsZHNUb1Nob3csXG4gICAgLi4udG9vbHRpcEZpZWxkc1xuICB9O1xuXG4gIHJldHVybiBzZXQoWydpbnRlcmFjdGlvbkNvbmZpZycsICd0b29sdGlwJywgJ2NvbmZpZycsICdmaWVsZHNUb1Nob3cnXSwgbWVyZ2VkLCBzdGF0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsRmlsZUxvYWRpbmdQcm9ncmVzcyhmaWxlLCBpbmRleCkge1xuICBjb25zdCBmaWxlTmFtZSA9IGZpbGUubmFtZSB8fCBgVW50aXRsZWQgRmlsZSAke2luZGV4fWA7XG4gIHJldHVybiB7XG4gICAgW2ZpbGVOYW1lXToge1xuICAgICAgLy8gcGVyY2VudCBvZiBjdXJyZW50IGZpbGVcbiAgICAgIHBlcmNlbnQ6IDAsXG4gICAgICBtZXNzYWdlOiAnJyxcbiAgICAgIGZpbGVOYW1lLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGaWxlTG9hZGluZ1Byb2dyZXNzVXBkYXRlcihzdGF0ZSwge2ZpbGVOYW1lLCBwcm9ncmVzc30pIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICByZXR1cm4gcGlja18oJ2ZpbGVMb2FkaW5nUHJvZ3Jlc3MnKShwaWNrXyhmaWxlTmFtZSkobWVyZ2VfKHByb2dyZXNzKSkpKHN0YXRlKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHVwZGF0ZSBsYXllciBkb21haW5zIGZvciBhbiBhcnJheSBvZiBkYXRhc2V0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBkYXRhSWQ6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB1cGRhdGVkRmlsdGVyPzogRmlsdGVyXG4pOiBTIHtcbiAgY29uc3QgZGF0YUlkcyA9IHR5cGVvZiBkYXRhSWQgPT09ICdzdHJpbmcnID8gW2RhdGFJZF0gOiBkYXRhSWQ7XG4gIGNvbnN0IG5ld0xheWVyczogTGF5ZXJbXSA9IFtdO1xuICBjb25zdCBuZXdMYXllckRhdGE6IGFueVtdID0gW107XG5cbiAgc3RhdGUubGF5ZXJzLmZvckVhY2goKG9sZExheWVyLCBpKSA9PiB7XG4gICAgaWYgKG9sZExheWVyLmNvbmZpZy5kYXRhSWQgJiYgZGF0YUlkcy5pbmNsdWRlcyhvbGRMYXllci5jb25maWcuZGF0YUlkKSkge1xuICAgICAgLy8gTm8gbmVlZCB0byByZWNhbGN1bGF0ZSBsYXllciBkb21haW4gaWYgZmlsdGVyIGhhcyBmaXhlZCBkb21haW5cbiAgICAgIGNvbnN0IG5ld0xheWVyID1cbiAgICAgICAgdXBkYXRlZEZpbHRlciAmJiB1cGRhdGVkRmlsdGVyLmZpeGVkRG9tYWluXG4gICAgICAgICAgPyBvbGRMYXllclxuICAgICAgICAgIDogb2xkTGF5ZXIudXBkYXRlTGF5ZXJEb21haW4oc3RhdGUuZGF0YXNldHMsIHVwZGF0ZWRGaWx0ZXIpO1xuXG4gICAgICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlLCBzdGF0ZS5sYXllckRhdGFbaV0pO1xuXG4gICAgICBuZXdMYXllcnMucHVzaChsYXllcik7XG4gICAgICBuZXdMYXllckRhdGEucHVzaChsYXllckRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdMYXllcnMucHVzaChvbGRMYXllcik7XG4gICAgICBuZXdMYXllckRhdGEucHVzaChzdGF0ZS5sYXllckRhdGFbaV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBuZXdMYXllcnMsXG4gICAgbGF5ZXJEYXRhOiBuZXdMYXllckRhdGFcbiAgfTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVBbmltYXRpb25Eb21haW48UyBleHRlbmRzIFZpc1N0YXRlPihzdGF0ZTogUyk6IFMge1xuICAvLyBtZXJnZSBhbGwgYW5pbWF0YWJsZSBsYXllciBkb21haW4gYW5kIHVwZGF0ZSBnbG9iYWwgY29uZmlnXG4gIGNvbnN0IGFuaW1hdGFibGVMYXllcnMgPSBnZXRBbmltYXRhYmxlVmlzaWJsZUxheWVycyhzdGF0ZS5sYXllcnMpO1xuXG4gIGlmICghYW5pbWF0YWJsZUxheWVycy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgICBkb21haW46IG51bGwsXG4gICAgICAgIGlzQW5pbWF0aW5nOiBmYWxzZSxcbiAgICAgICAgdGltZVN0ZXBzOiBudWxsLFxuICAgICAgICBkZWZhdWx0VGltZUZvcm1hdDogbnVsbFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjb25zdCBsYXllckRvbWFpbnMgPSBhbmltYXRhYmxlTGF5ZXJzLm1hcChsID0+IGwuY29uZmlnLmFuaW1hdGlvbi5kb21haW4gfHwgW10pO1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG1lcmdlZERvbWFpbiA9IG1lcmdlVGltZURvbWFpbnMobGF5ZXJEb21haW5zKTtcbiAgY29uc3QgZGVmYXVsdFRpbWVGb3JtYXQgPSBnZXRUaW1lV2lkZ2V0VGl0bGVGb3JtYXR0ZXIobWVyZ2VkRG9tYWluKTtcblxuICAvLyBtZXJnZSB0aW1lU3RlcHNcbiAgbGV0IG1lcmdlZFRpbWVTdGVwczogbnVtYmVyW10gfCBudWxsID0gdW5pcTxudW1iZXI+KFxuICAgIGFuaW1hdGFibGVMYXllcnMucmVkdWNlKChhY2N1LCBsYXllcikgPT4ge1xuICAgICAgYWNjdS5wdXNoKC4uLihsYXllci5jb25maWcuYW5pbWF0aW9uLnRpbWVTdGVwcyB8fCBbXSkpO1xuICAgICAgcmV0dXJuIGFjY3U7XG4gICAgfSwgW10pXG4gICkuc29ydCgpO1xuXG4gIG1lcmdlZFRpbWVTdGVwcyA9IG1lcmdlZFRpbWVTdGVwcy5sZW5ndGggPyBtZXJnZWRUaW1lU3RlcHMgOiBudWxsO1xuXG4gIC8vIFRPRE86IGJldHRlciBoYW5kbGluZyBvZiBkdXJhdGlvbiBjYWxjdWxhdGlvblxuICBjb25zdCBkdXJhdGlvbiA9IG1lcmdlZFRpbWVTdGVwc1xuICAgID8gKEJBU0VfU1BFRUQgKiAoMTAwMCAvIEZQUykpIC8gbWVyZ2VkVGltZVN0ZXBzLmxlbmd0aCAvIChzdGF0ZS5hbmltYXRpb25Db25maWcuc3BlZWQgfHwgMSlcbiAgICA6IG51bGw7XG5cbiAgY29uc3QgbmV4dFN0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgZG9tYWluOiBtZXJnZWREb21haW4sXG4gICAgICBkZWZhdWx0VGltZUZvcm1hdCxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdGltZVN0ZXBzOiBtZXJnZWRUaW1lU3RlcHNcbiAgICB9XG4gIH07XG5cbiAgLy8gcmVzZXQgY3VycmVudFRpbWUgYmFzZWQgb24gbmV3IGRvbWFpblxuICBjb25zdCBzeW5jZWRGaWx0ZXIgPSBzdGF0ZS5maWx0ZXJzPy5maW5kKGYgPT4gKGYgYXMgVGltZVJhbmdlRmlsdGVyKS5zeW5jZWRXaXRoTGF5ZXJUaW1lbGluZSkgYXNcbiAgICB8IFRpbWVSYW5nZUZpbHRlclxuICAgIHwgdW5kZWZpbmVkO1xuXG4gIC8vIGlmIHN5bmNlZCBmaWx0ZXIgZXhpc3Qgd2VlIG5lZWQgdG8gbWVyZ2UgYW5pbWF0aW9uQ29uZmlnIGFuZCBmaWx0ZXIgZG9tYWluc1xuICAvLyBhbmQgdmFsaWRhdGUgdGhlIGN1cnJlbnQgdGltZSBhZ2FpbnN0IHRoZSBuZXcgbWVyZ2VkIGRvbWFpblxuICBjb25zdCBuZXdBbmltYXRpb25Eb21haW4gPSBzeW5jZWRGaWx0ZXJcbiAgICA/IG1lcmdlVGltZURvbWFpbnMoW21lcmdlZERvbWFpbiwgc3luY2VkRmlsdGVyLmRvbWFpbl0pXG4gICAgOiBtZXJnZWREb21haW47XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gaXNJblJhbmdlKHN0YXRlLmFuaW1hdGlvbkNvbmZpZy5jdXJyZW50VGltZSwgbmV3QW5pbWF0aW9uRG9tYWluKVxuICAgID8gc3RhdGUuYW5pbWF0aW9uQ29uZmlnLmN1cnJlbnRUaW1lXG4gICAgOiBuZXdBbmltYXRpb25Eb21haW5bMF07XG5cbiAgaWYgKGN1cnJlbnRUaW1lICE9PSBzdGF0ZS5hbmltYXRpb25Db25maWcuY3VycmVudFRpbWUpIHtcbiAgICAvLyBpZiBjdXJyZW50VGltZSBjaGFuZ2VkLCBuZWVkIHRvIGNhbGwgYW5pbWF0aW9uVGltZVVwZGF0ZXIgdG8gcmUgY2FsbCBmb3JtYXRMYXllckRhdGFcbiAgICByZXR1cm4gc2V0TGF5ZXJBbmltYXRpb25UaW1lVXBkYXRlcihuZXh0U3RhdGUsIHt2YWx1ZTogY3VycmVudFRpbWV9KTtcbiAgfVxuXG4gIHJldHVybiBuZXh0U3RhdGU7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBzdGF0dXMgb2YgdGhlIGVkaXRvclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEVkaXRvck1vZGVVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHttb2RlfTogVmlzU3RhdGVBY3Rpb25zLlNldEVkaXRvck1vZGVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZWRpdG9yOiB7XG4gICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgIG1vZGUsXG4gICAgc2VsZWN0ZWRGZWF0dXJlOiBudWxsXG4gIH1cbn0pO1xuXG4vLyBjb25zdCBmZWF0dXJlVG9GaWx0ZXJWYWx1ZSA9IChmZWF0dXJlKSA9PiAoey4uLmZlYXR1cmUsIGlkOiBmZWF0dXJlLmlkfSk7XG4vKipcbiAqIFVwZGF0ZSBlZGl0b3IgZmVhdHVyZXNcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRGZWF0dXJlc1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2ZlYXR1cmVzID0gW119OiBWaXNTdGF0ZUFjdGlvbnMuU2V0RmVhdHVyZXNVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IGxhc3RGZWF0dXJlID0gZmVhdHVyZXMubGVuZ3RoICYmIGZlYXR1cmVzW2ZlYXR1cmVzLmxlbmd0aCAtIDFdO1xuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjoge1xuICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgLy8gb25seSBzYXZlIG5vbmUgZmlsdGVyIGZlYXR1cmVzIHRvIGVkaXRvclxuICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzLmZpbHRlcihmID0+ICFnZXRGaWx0ZXJJZEluRmVhdHVyZShmKSksXG4gICAgICBtb2RlOiBsYXN0RmVhdHVyZSAmJiBsYXN0RmVhdHVyZS5wcm9wZXJ0aWVzPy5pc0Nsb3NlZCA/IEVESVRPUl9NT0RFUy5FRElUIDogc3RhdGUuZWRpdG9yLm1vZGVcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgZXhpc3RpbmcgZmVhdHVyZVxuICBjb25zdCB7c2VsZWN0ZWRGZWF0dXJlfSA9IHN0YXRlLmVkaXRvcjtcblxuICAvLyBJZiBubyBmZWF0dXJlIGlzIHNlbGVjdGVkIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHNpbmNlIG5vIG9wZXJhdGlvbnNcbiAgaWYgKCFzZWxlY3RlZEZlYXR1cmUpIHtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cblxuICAvLyBUT0RPOiBjaGVjayBpZiB0aGUgZmVhdHVyZSBoYXMgY2hhbmdlZFxuICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXMuZmluZChmID0+IGYuaWQgPT09IHNlbGVjdGVkRmVhdHVyZS5pZCk7XG5cbiAgLy8gaWYgZmVhdHVyZSBpcyBwYXJ0IG9mIGEgZmlsdGVyXG4gIGNvbnN0IGZpbHRlcklkID0gZmVhdHVyZSAmJiBnZXRGaWx0ZXJJZEluRmVhdHVyZShmZWF0dXJlKTtcbiAgaWYgKGZpbHRlcklkICYmIGZlYXR1cmUpIHtcbiAgICAvLyBhZGQgYmJveCBmb3IgcG9seWdvbiBmaWx0ZXIgdG8gc3BlZWQgdXAgZmlsdGVyaW5nXG4gICAgaWYgKGZlYXR1cmUucHJvcGVydGllcykgZmVhdHVyZS5wcm9wZXJ0aWVzLmJib3ggPSBiYm94KGZlYXR1cmUpO1xuICAgIGNvbnN0IGZlYXR1cmVWYWx1ZSA9IGZlYXR1cmVUb0ZpbHRlclZhbHVlKGZlYXR1cmUsIGZpbHRlcklkKTtcbiAgICBjb25zdCBmaWx0ZXJJZHggPSBzdGF0ZS5maWx0ZXJzLmZpbmRJbmRleChmaWwgPT4gZmlsLmlkID09PSBmaWx0ZXJJZCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgICBpZHg6IGZpbHRlcklkeCxcbiAgICAgIHByb3A6ICd2YWx1ZScsXG4gICAgICB2YWx1ZTogZmVhdHVyZVZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IHNlbGVjdGVkIGZlYXR1cmVcbiAqIEBtZW1iZXJvZiB1aVN0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldFNlbGVjdGVkRmVhdHVyZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2ZlYXR1cmUsIHNlbGVjdGlvbkNvbnRleHR9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0U2VsZWN0ZWRGZWF0dXJlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICAvLyBhZGQgYmJveCBmb3IgcG9seWdvbiBmaWx0ZXIgdG8gc3BlZWQgdXAgZmlsdGVyaW5nXG4gIGxldCBzZWxlY3RlZEZlYXR1cmUgPSBmZWF0dXJlO1xuICBpZiAoZmVhdHVyZT8ucHJvcGVydGllcykge1xuICAgIHNlbGVjdGVkRmVhdHVyZSA9IHtcbiAgICAgIC4uLmZlYXR1cmUsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC4uLmZlYXR1cmUucHJvcGVydGllcyxcbiAgICAgICAgYmJveDogYmJveChmZWF0dXJlKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0b3I6IHtcbiAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgIHNlbGVjdGVkRmVhdHVyZSxcbiAgICAgIHNlbGVjdGlvbkNvbnRleHRcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIERlbGV0ZSBleGlzdGluZyBmZWF0dXJlIGZyb20gZmlsdGVyc1xuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZUZlYXR1cmVVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtmZWF0dXJlfTogVmlzU3RhdGVBY3Rpb25zLkRlbGV0ZUZlYXR1cmVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGlmICghZmVhdHVyZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjoge1xuICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgc2VsZWN0ZWRGZWF0dXJlOiBudWxsXG4gICAgfVxuICB9O1xuXG4gIGlmIChnZXRGaWx0ZXJJZEluRmVhdHVyZShmZWF0dXJlKSkge1xuICAgIGNvbnN0IGZpbHRlcklkeCA9IG5ld1N0YXRlLmZpbHRlcnMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gZ2V0RmlsdGVySWRJbkZlYXR1cmUoZmVhdHVyZSkpO1xuXG4gICAgcmV0dXJuIGZpbHRlcklkeCA+IC0xID8gcmVtb3ZlRmlsdGVyVXBkYXRlcihuZXdTdGF0ZSwge2lkeDogZmlsdGVySWR4fSkgOiBuZXdTdGF0ZTtcbiAgfVxuXG4gIC8vIG1vZGlmeSBlZGl0b3Igb2JqZWN0XG4gIGNvbnN0IG5ld0VkaXRvciA9IHtcbiAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgZmVhdHVyZXM6IHN0YXRlLmVkaXRvci5mZWF0dXJlcy5maWx0ZXIoZiA9PiBmLmlkICE9PSBmZWF0dXJlLmlkKSxcbiAgICBzZWxlY3RlZEZlYXR1cmU6IG51bGxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjogbmV3RWRpdG9yXG4gIH07XG59XG5cbi8qKlxuICogVG9nZ2xlIGZlYXR1cmUgYXMgbGF5ZXIgZmlsdGVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9seWdvbkZpbHRlckxheWVyVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBwYXlsb2FkOiBWaXNTdGF0ZUFjdGlvbnMuU2V0UG9seWdvbkZpbHRlckxheWVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7bGF5ZXIsIGZlYXR1cmV9ID0gcGF5bG9hZDtcbiAgY29uc3QgZmlsdGVySWQgPSBnZXRGaWx0ZXJJZEluRmVhdHVyZShmZWF0dXJlKTtcblxuICAvLyBsZXQgbmV3RmlsdGVyID0gbnVsbDtcbiAgbGV0IGZpbHRlcklkeDtcbiAgbGV0IG5ld0xheWVySWQgPSBbbGF5ZXIuaWRdO1xuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgLy8gSWYgcG9seWdvbiBmaWx0ZXIgYWxyZWFkeSBleGlzdHMsIHdlIG5lZWQgdG8gZmluZCBvdXQgaWYgdGhlIGN1cnJlbnQgbGF5ZXIgaXMgYWxyZWFkeSBpbmNsdWRlZFxuICBpZiAoZmlsdGVySWQpIHtcbiAgICBmaWx0ZXJJZHggPSBzdGF0ZS5maWx0ZXJzLmZpbmRJbmRleChmID0+IGYuaWQgPT09IGZpbHRlcklkKTtcblxuICAgIGlmICghc3RhdGUuZmlsdGVyc1tmaWx0ZXJJZHhdKSB7XG4gICAgICAvLyB3aGF0IGlmIGZpbHRlciBkb2Vzbid0IGV4aXN0Py4uLiBub3QgcG9zc2libGUuXG4gICAgICAvLyBiZWNhdXNlIGZlYXR1cmVzIGluIHRoZSBlZGl0b3IgaXMgcGFzc2VkIGluIGZyb20gZmlsdGVycyBhbmQgZWRpdG9ycy5cbiAgICAgIC8vIGJ1dCB3ZSB3aWxsIG1vdmUgdGhpcyBmZWF0dXJlIGJhY2sgdG8gZWRpdG9yIGp1c3QgaW4gY2FzZVxuICAgICAgY29uc3Qgbm9uZUZpbHRlckZlYXR1cmUgPSB7XG4gICAgICAgIC4uLmZlYXR1cmUsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAuLi5mZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICAgICAgZmlsdGVySWQ6IG51bGxcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGVkaXRvcjoge1xuICAgICAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgICAgICBmZWF0dXJlczogWy4uLnN0YXRlLmVkaXRvci5mZWF0dXJlcywgbm9uZUZpbHRlckZlYXR1cmVdLFxuICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZTogbm9uZUZpbHRlckZlYXR1cmVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyID0gc3RhdGUuZmlsdGVyc1tmaWx0ZXJJZHhdO1xuICAgIGNvbnN0IHtsYXllcklkID0gW119ID0gZmlsdGVyO1xuICAgIGNvbnN0IGlzTGF5ZXJJbmNsdWRlZCA9IGxheWVySWQuaW5jbHVkZXMobGF5ZXIuaWQpO1xuXG4gICAgbmV3TGF5ZXJJZCA9IGlzTGF5ZXJJbmNsdWRlZFxuICAgICAgPyAvLyBpZiBsYXllciBpcyBpbmNsdWRlZCwgcmVtb3ZlIGl0XG4gICAgICAgIGxheWVySWQuZmlsdGVyKGwgPT4gbCAhPT0gbGF5ZXIuaWQpXG4gICAgICA6IFsuLi5sYXllcklkLCBsYXllci5pZF07XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgd2UgaGF2ZW4ndCBjcmVhdGUgdGhlIHBvbHlnb24gZmlsdGVyLCBjcmVhdGUgaXRcbiAgICBjb25zdCBuZXdGaWx0ZXIgPSBnZW5lcmF0ZVBvbHlnb25GaWx0ZXIoW10sIGZlYXR1cmUpO1xuICAgIGZpbHRlcklkeCA9IHN0YXRlLmZpbHRlcnMubGVuZ3RoO1xuXG4gICAgLy8gYWRkIGZlYXR1cmUsIHJlbW92ZSBmZWF0dXJlIGZyb20gZWlkdG9yXG4gICAgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGZpbHRlcnM6IFsuLi5zdGF0ZS5maWx0ZXJzLCBuZXdGaWx0ZXJdLFxuICAgICAgZWRpdG9yOiB7XG4gICAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgICAgZmVhdHVyZXM6IHN0YXRlLmVkaXRvci5mZWF0dXJlcy5maWx0ZXIoZiA9PiBmLmlkICE9PSBmZWF0dXJlLmlkKSxcbiAgICAgICAgc2VsZWN0ZWRGZWF0dXJlOiBuZXdGaWx0ZXIudmFsdWVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHNldEZpbHRlclVwZGF0ZXIobmV3U3RhdGUsIHtcbiAgICBpZHg6IGZpbHRlcklkeCxcbiAgICBwcm9wOiAnbGF5ZXJJZCcsXG4gICAgdmFsdWU6IG5ld0xheWVySWRcbiAgfSk7XG59XG5cbi8qKlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnRUYWJsZUNvbHVtblVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2RhdGFJZCwgY29sdW1uLCBtb2RlfTogVmlzU3RhdGVBY3Rpb25zLlNvcnRUYWJsZUNvbHVtblVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW2RhdGFJZF07XG4gIGlmICghZGF0YXNldCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBsZXQgc29ydE1vZGUgPSBtb2RlO1xuICBpZiAoIXNvcnRNb2RlKSB7XG4gICAgY29uc3QgY3VycmVudE1vZGUgPSBnZXQoZGF0YXNldCwgWydzb3J0Q29sdW1uJywgY29sdW1uXSk7XG4gICAgLy8gQHRzLWlnbm9yZSAtIHNob3VsZCBiZSBmaXhhYmxlIGluIGEgVFMgZmlsZVxuICAgIHNvcnRNb2RlID0gY3VycmVudE1vZGVcbiAgICAgID8gT2JqZWN0LmtleXMoU09SVF9PUkRFUikuZmluZChtID0+IG0gIT09IGN1cnJlbnRNb2RlKVxuICAgICAgOiBTT1JUX09SREVSLkFTQ0VORElORztcbiAgfVxuXG4gIGNvbnN0IHNvcnRlZCA9IHNvcnREYXRhc2V0QnlDb2x1bW4oZGF0YXNldCwgY29sdW1uLCBzb3J0TW9kZSk7XG4gIHJldHVybiBzZXQoWydkYXRhc2V0cycsIGRhdGFJZF0sIHNvcnRlZCwgc3RhdGUpO1xufVxuXG4vKipcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaW5UYWJsZUNvbHVtblVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2RhdGFJZCwgY29sdW1ufTogVmlzU3RhdGVBY3Rpb25zLlBpblRhYmxlQ29sdW1uVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IG5ld0RhdGFzZXQgPSBwaW5UYWJsZUNvbHVtbnMoZGF0YXNldCwgY29sdW1uKTtcblxuICByZXR1cm4gc2V0KFsnZGF0YXNldHMnLCBkYXRhSWRdLCBuZXdEYXRhc2V0LCBzdGF0ZSk7XG59XG5cbi8qKlxuICogQ29weSBjb2x1bW4gY29udGVudCBhcyBzdHJpbmdzXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29weVRhYmxlQ29sdW1uVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZGF0YUlkLCBjb2x1bW59OiBWaXNTdGF0ZUFjdGlvbnMuQ29weVRhYmxlQ29sdW1uVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IGZpZWxkSWR4ID0gZGF0YXNldC5maWVsZHMuZmluZEluZGV4KGYgPT4gZi5uYW1lID09PSBjb2x1bW4pO1xuICBpZiAoZmllbGRJZHggPCAwKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHt0eXBlfSA9IGRhdGFzZXQuZmllbGRzW2ZpZWxkSWR4XTtcbiAgY29uc3QgdGV4dCA9IGRhdGFzZXQuZGF0YUNvbnRhaW5lclxuICAgIC5tYXAocm93ID0+IHBhcnNlRmllbGRWYWx1ZShyb3cudmFsdWVBdChmaWVsZElkeCksIHR5cGUpLCB0cnVlKVxuICAgIC5qb2luKCdcXG4nKTtcblxuICBjb3B5KHRleHQpO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBTZXQgZGlzcGxheSBmb3JtYXQgZnJvbSBjb2x1bW5zIGZyb20gdXNlciBzZWxlY3Rpb25cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb2x1bW5EaXNwbGF5Rm9ybWF0VXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZGF0YUlkLCBmb3JtYXRzfTogVmlzU3RhdGVBY3Rpb25zLlNldENvbHVtbkRpc3BsYXlGb3JtYXRVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdO1xuICBpZiAoIWRhdGFzZXQpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgbGV0IG5ld0ZpZWxkcyA9IGRhdGFzZXQuZmllbGRzO1xuICBPYmplY3Qua2V5cyhmb3JtYXRzKS5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgY29uc3QgZmllbGRJZHggPSBkYXRhc2V0LmZpZWxkcy5maW5kSW5kZXgoZiA9PiBmLm5hbWUgPT09IGNvbHVtbik7XG4gICAgaWYgKGZpZWxkSWR4ID49IDApIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlGb3JtYXQgPSBmb3JtYXRzW2NvbHVtbl07XG4gICAgICBjb25zdCBmaWVsZCA9IG5ld0ZpZWxkc1tmaWVsZElkeF07XG4gICAgICBuZXdGaWVsZHMgPSBzd2FwXyhtZXJnZV8oe2Rpc3BsYXlGb3JtYXR9KShmaWVsZCkgYXMge2lkOiBzdHJpbmd9KShcbiAgICAgICAgbmV3RmllbGRzIGFzIHtpZDogc3RyaW5nfVtdXG4gICAgICApIGFzIEZpZWxkW107XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBuZXdEYXRhc2V0ID0gY29weVRhYmxlQW5kVXBkYXRlKGRhdGFzZXQsIHtmaWVsZHM6IG5ld0ZpZWxkcyBhcyBGaWVsZFtdfSk7XG4gIGxldCBuZXdTdGF0ZSA9IHBpY2tfKCdkYXRhc2V0cycpKG1lcmdlXyh7W2RhdGFJZF06IG5ld0RhdGFzZXR9KSkoc3RhdGUpO1xuXG4gIC8vIHVwZGF0ZSBjb2xvckZpZWxkIGRpc3BsYXlGb3JtYXRcbiAgbmV3U3RhdGUgPSB7XG4gICAgLi4ubmV3U3RhdGUsXG4gICAgbGF5ZXJzOiBuZXdTdGF0ZS5sYXllcnMubWFwKGxheWVyID0+XG4gICAgICBsYXllci5jb25maWc/LmNvbG9yRmllbGQ/Lm5hbWUgJiYgbGF5ZXIuY29uZmlnLmNvbG9yRmllbGQubmFtZSBpbiBmb3JtYXRzXG4gICAgICAgID8gbGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgICAgICAgICAgY29sb3JGaWVsZDoge1xuICAgICAgICAgICAgICAuLi5sYXllci5jb25maWcuY29sb3JGaWVsZCxcbiAgICAgICAgICAgICAgZGlzcGxheUZvcm1hdDogZm9ybWF0c1tsYXllci5jb25maWcuY29sb3JGaWVsZC5uYW1lXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIDogbGF5ZXJcbiAgICApXG4gIH07XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBlZGl0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUVkaXRvclZpc2liaWxpdHlVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVG9nZ2xlRWRpdG9yVmlzaWJpbGl0eVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0b3I6IHtcbiAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgIHZpc2libGU6ICFzdGF0ZS5lZGl0b3IudmlzaWJsZVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEZpbHRlckFuaW1hdGlvblRpbWVDb25maWdVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtpZHgsIGNvbmZpZ306IFZpc1N0YXRlQWN0aW9ucy5TZXRGaWx0ZXJBbmltYXRpb25UaW1lQ29uZmlnQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IG9sZEZpbHRlciA9IHN0YXRlLmZpbHRlcnNbaWR4XTtcbiAgaWYgKCFvbGRGaWx0ZXIpIHtcbiAgICBDb25zb2xlLmVycm9yKGBmaWx0ZXJzLiR7aWR4fSBpcyB1bmRlZmluZWRgKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKG9sZEZpbHRlci50eXBlICE9PSBGSUxURVJfVFlQRVMudGltZVJhbmdlKSB7XG4gICAgQ29uc29sZS5lcnJvcihcbiAgICAgIGBzZXRGaWx0ZXJBbmltYXRpb25UaW1lQ29uZmlnIGNhbiBvbmx5IGJlIGNhbGxlZCB0byB1cGRhdGUgYSB0aW1lIGZpbHRlci4gY2hlY2sgZmlsdGVyLnR5cGUgPT09ICd0aW1lUmFuZ2UnYFxuICAgICk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3QgdXBkYXRlcyA9IGNoZWNrVGltZUNvbmZpZ0FyZ3MoY29uZmlnKTtcblxuICByZXR1cm4gcGlja18oJ2ZpbHRlcnMnKShzd2FwXyhtZXJnZV8odXBkYXRlcykob2xkRmlsdGVyKSkpKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tUaW1lQ29uZmlnQXJncyhjb25maWcpIHtcbiAgY29uc3QgYWxsb3dlZCA9IFsndGltZUZvcm1hdCcsICd0aW1lem9uZSddO1xuICByZXR1cm4gT2JqZWN0LmtleXMoY29uZmlnKS5yZWR1Y2UoKGFjY3UsIHByb3ApID0+IHtcbiAgICBpZiAoIWFsbG93ZWQuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgIENvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBzZXRMYXllckFuaW1hdGlvblRpbWVDb25maWcgdGFrZXMgdGltZUZvcm1hdCBhbmQvb3IgdGltZXpvbmUgYXMgb3B0aW9ucywgZm91bmQgJHtwcm9wfWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gYWNjdTtcbiAgICB9XG5cbiAgICAvLyBoZXJlIHdlIGFyZSBOT1QgY2hlY2tpbmcgaWYgdGltZXpvbmUgb3IgdGltZUZvcm1hdCBpbnB1dCBpcyB2YWxpZFxuICAgIGFjY3VbcHJvcF0gPSBjb25maWdbcHJvcF07XG4gICAgcmV0dXJuIGFjY3U7XG4gIH0sIHt9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgZWRpdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRMYXllckFuaW1hdGlvblRpbWVDb25maWdVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtjb25maWd9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0TGF5ZXJBbmltYXRpb25UaW1lQ29uZmlnQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHVwZGF0ZXMgPSBjaGVja1RpbWVDb25maWdBcmdzKGNvbmZpZyk7XG4gIHJldHVybiBwaWNrXygnYW5pbWF0aW9uQ29uZmlnJykobWVyZ2VfKHVwZGF0ZXMpKShzdGF0ZSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGVkaXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJGaWx0ZXJlZEl0ZW1zQ2hhbmdlVXBkYXRlcjxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuTGF5ZXJGaWx0ZXJlZEl0ZW1zQ2hhbmdlQWN0aW9uXG4pOiBTIHtcbiAgY29uc3Qge2V2ZW50LCBsYXllcn0gPSBhY3Rpb247XG4gIGNvbnN0IHtpZDogZGVja2dsTGF5ZXJJZCwgY291bnR9ID0gZXZlbnQ7XG4gIGlmICghbGF5ZXIpIHtcbiAgICBDb25zb2xlLndhcm4oYGxheWVyRmlsdGVyZWRJdGVtcyBsYXllciBkb2VzbnQgZXhpc3RzYCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmIChsYXllci5maWx0ZXJlZEl0ZW1Db3VudD8uW2RlY2tnbExheWVySWRdID09PSBjb3VudCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGxheWVyLmZpbHRlcmVkSXRlbUNvdW50ID0ge1xuICAgIC4uLmxheWVyLmZpbHRlcmVkSXRlbUNvdW50LFxuICAgIFtkZWNrZ2xMYXllcklkXTogY291bnRcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogc3dhcF8obGF5ZXIpKHN0YXRlLmxheWVycylcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG5leHBvcnQgZnVuY3Rpb24gc3luY1RpbWVGaWx0ZXJXaXRoTGF5ZXJUaW1lbGluZVVwZGF0ZXI8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlN5bmNUaW1lRmlsdGVyV2l0aExheWVyVGltZWxpbmVBY3Rpb25cbik6IFMge1xuICBjb25zdCB7aWR4OiBmaWx0ZXJJZHgsIGVuYWJsZSA9IGZhbHNlfSA9IGFjdGlvbjtcblxuICBjb25zdCBmaWx0ZXIgPSBzdGF0ZS5maWx0ZXJzW2ZpbHRlcklkeF0gYXMgVGltZVJhbmdlRmlsdGVyO1xuXG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBsZXQgbmV3RmlsdGVyID0gZmlsdGVyO1xuXG4gIC8vIGlmIHdlIGVuYWJsZSBzeW5jIHdlIGFyZSBnb2luZyB0byBtZXJnZSBmaWx0ZXIgYW5kIGFuaW1hdGlvbkNvbmZpZyBkb21haW5zIGFuZCBzdG9yZSBpbnRvIGZpbHRlci5kb21haW5cbiAgaWYgKGVuYWJsZSkge1xuICAgIGNvbnN0IGFuaW1hdGFibGVMYXllcnMgPSBnZXRBbmltYXRhYmxlVmlzaWJsZUxheWVycyhuZXdTdGF0ZS5sYXllcnMpO1xuICAgIC8vIGlmIG5vIGFuaW1hdGFibGVMYXllcnMgYXJlIHByZXNlbnQgd2Ugc2ltcGx5IHJldHVyblxuICAgIGlmICghYW5pbWF0YWJsZUxheWVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcnZhbEJhc2VkQW5pbWF0aW9uTGF5ZXJzID0gZ2V0SW50ZXJ2YWxCYXNlZEFuaW1hdGlvbkxheWVycyhhbmltYXRhYmxlTGF5ZXJzKTtcbiAgICBjb25zdCBoYXNJbnRlcnZhbEJhc2VkQW5pbWF0aW9uTGF5ZXIgPSBCb29sZWFuKGludGVydmFsQmFzZWRBbmltYXRpb25MYXllcnMubGVuZ3RoKTtcblxuICAgIGNvbnN0IG5ld0ZpbHRlckRvbWFpbiA9IG1lcmdlVGltZURvbWFpbnMoW2ZpbHRlci5kb21haW4sIG5ld1N0YXRlLmFuaW1hdGlvbkNvbmZpZy5kb21haW5dKTtcblxuICAgIC8vIHdlIG9ubHkgdXBkYXRlIGFuaW1hdGlvbldpbmRvdyBpZiB3ZSBoYXZlIGludGVydmFsIGJhc2VkIGFuaW1hdGlvbiBsYXllcnMgd2l0aCBkZWZpbmVkIGludGVydmFscyBhbmQgdGhlIGN1cnJlbnQgZmlsdGVyIGFuaW1hdGlvbiB3aW5kb3cgaXMgbm90IGludGVydmFsXG4gICAgaWYgKGhhc0ludGVydmFsQmFzZWRBbmltYXRpb25MYXllcikge1xuICAgICAgaWYgKGZpbHRlci5hbmltYXRpb25XaW5kb3cgIT09IEFOSU1BVElPTl9XSU5ET1cuaW50ZXJ2YWwpIHtcbiAgICAgICAgbmV3U3RhdGUgPSBzZXRGaWx0ZXJBbmltYXRpb25XaW5kb3dVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgICAgICAgaWQ6IGZpbHRlci5pZCxcbiAgICAgICAgICBhbmltYXRpb25XaW5kb3c6IEFOSU1BVElPTl9XSU5ET1cuaW50ZXJ2YWxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG5ld0ZpbHRlciA9IG5ld1N0YXRlLmZpbHRlcnNbZmlsdGVySWR4XSBhcyBUaW1lUmFuZ2VGaWx0ZXI7XG5cbiAgICAgIC8vIGFkanVzdCB0aW1lIGZpbHRlciBpbnRlcnZhbFxuICAgICAgbmV3RmlsdGVyID0gYWRqdXN0VGltZUZpbHRlckludGVydmFsKG5ld1N0YXRlLCBuZXdGaWx0ZXIpO1xuXG4gICAgICAvLyByZXBsYWNlIGZpbHRlciBpbiBzdGF0ZSB3aXRoIG5ld0ZpbHRlclxuICAgICAgbmV3U3RhdGUgPSB7XG4gICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICBmaWx0ZXJzOiBzd2FwXzxGaWx0ZXI+KG5ld0ZpbHRlcikobmV3U3RhdGUuZmlsdGVycylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmV3RmlsdGVyID0gbmV3U3RhdGUuZmlsdGVyc1tmaWx0ZXJJZHhdIGFzIFRpbWVSYW5nZUZpbHRlcjtcblxuICAgIC8vIGFkanVzdCB2YWx1ZSBiYXNlZCBvbiBuZXcgZG9tYWluXG4gICAgY29uc3QgbmV3RmlsdGVyVmFsdWUgPSBhZGp1c3RWYWx1ZVRvRmlsdGVyRG9tYWluKFxuICAgICAgbmV3RmlsdGVyLmFuaW1hdGlvbldpbmRvdyA9PT0gQU5JTUFUSU9OX1dJTkRPVy5pbnRlcnZhbFxuICAgICAgICA/IFtuZXdGaWx0ZXJEb21haW5bMF0sIG5ld0ZpbHRlckRvbWFpblswXV1cbiAgICAgICAgOiBuZXdGaWx0ZXJEb21haW4sXG4gICAgICB7Li4ubmV3RmlsdGVyLCBkb21haW46IG5ld0ZpbHRlckRvbWFpbn1cbiAgICApO1xuXG4gICAgbmV3U3RhdGUgPSBzZXRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgICBpZHg6IGZpbHRlcklkeCxcbiAgICAgIHByb3A6ICd2YWx1ZScsXG4gICAgICB2YWx1ZTogbmV3RmlsdGVyVmFsdWVcbiAgICB9KTtcblxuICAgIG5ld0ZpbHRlciA9IHtcbiAgICAgIC4uLihuZXdTdGF0ZS5maWx0ZXJzW2ZpbHRlcklkeF0gYXMgVGltZVJhbmdlRmlsdGVyKSxcbiAgICAgIHN5bmNlZFdpdGhMYXllclRpbWVsaW5lOiB0cnVlXG4gICAgfTtcblxuICAgIC8vIHJlcGxhY2UgZmlsdGVyIGluIHN0YXRlIHdpdGggbmV3RmlsdGVyXG4gICAgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgIGZpbHRlcnM6IHN3YXBfPEZpbHRlcj4obmV3RmlsdGVyKShuZXdTdGF0ZS5maWx0ZXJzKVxuICAgIH07XG5cbiAgICBuZXdTdGF0ZSA9IHNldFRpbWVGaWx0ZXJUaW1lbGluZU1vZGVVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgICBpZDogbmV3RmlsdGVyLmlkLFxuICAgICAgbW9kZTogZ2V0U3luY0FuaW1hdGlvbk1vZGUobmV3RmlsdGVyKVxuICAgIH0pO1xuXG4gICAgbmV3RmlsdGVyID0gbmV3U3RhdGUuZmlsdGVyc1tmaWx0ZXJJZHhdIGFzIFRpbWVSYW5nZUZpbHRlcjtcblxuICAgIC8vIHNldCB0aGUgYW5pbWF0aW9uIGNvbmZpZyB2YWx1ZSB0byBtYXRjaCBmaWx0ZXIgdmFsdWVcbiAgICByZXR1cm4gc2V0TGF5ZXJBbmltYXRpb25UaW1lVXBkYXRlcihuZXdTdGF0ZSwge1xuICAgICAgdmFsdWU6IG5ld0ZpbHRlci52YWx1ZVtuZXdGaWx0ZXIuc3luY1RpbWVsaW5lTW9kZV1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIHNldCBkb21haW4gYW5kIHN0ZXBcbiAgbmV3RmlsdGVyID0ge1xuICAgIC4uLmZpbHRlcixcbiAgICBzeW5jZWRXaXRoTGF5ZXJUaW1lbGluZTogZmFsc2VcbiAgfTtcblxuICAvLyByZXBsYWNlIGZpbHRlciBpbiBzdGF0ZSB3aXRoIG5ld0ZpbHRlclxuICBuZXdTdGF0ZSA9IHtcbiAgICAuLi5uZXdTdGF0ZSxcbiAgICBmaWx0ZXJzOiBzd2FwXzxGaWx0ZXI+KG5ld0ZpbHRlcikobmV3U3RhdGUuZmlsdGVycylcbiAgfTtcblxuICAvLyByZXNldCBzeW5jIHRpbWVsaW5lIG1vZGVcbiAgbmV3U3RhdGUgPSBzZXRUaW1lRmlsdGVyVGltZWxpbmVNb2RlVXBkYXRlcihuZXdTdGF0ZSwge1xuICAgIGlkOiBuZXdGaWx0ZXIuaWQsXG4gICAgbW9kZTogU1lOQ19USU1FTElORV9NT0RFUy5lbmRcbiAgfSk7XG5cbiAgbmV3RmlsdGVyID0gbmV3U3RhdGUuZmlsdGVyc1tmaWx0ZXJJZHhdIGFzIFRpbWVSYW5nZUZpbHRlcjtcblxuICAvLyByZXNldCBmaWx0ZXIgdmFsdWVcbiAgY29uc3QgbmV3RmlsdGVyVmFsdWUgPSBhZGp1c3RWYWx1ZVRvRmlsdGVyRG9tYWluKG5ld0ZpbHRlci5kb21haW4sIG5ld0ZpbHRlcik7XG5cbiAgbmV3U3RhdGUgPSBzZXRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgaWR4OiBmaWx0ZXJJZHgsXG4gICAgcHJvcDogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogbmV3RmlsdGVyVmFsdWVcbiAgfSk7XG5cbiAgbmV3U3RhdGUgPSBzZXRUaW1lRmlsdGVyVGltZWxpbmVNb2RlVXBkYXRlcihuZXdTdGF0ZSwge1xuICAgIGlkOiBuZXdGaWx0ZXIuaWQsXG4gICAgbW9kZTogZ2V0U3luY0FuaW1hdGlvbk1vZGUobmV3RmlsdGVyKVxuICB9KTtcblxuICAvLyByZXNldCBhbmltYXRpb24gY29uZmlnIGN1cnJlbnQgdGltZSB0b1xuICByZXR1cm4gc2V0TGF5ZXJBbmltYXRpb25UaW1lVXBkYXRlcihuZXdTdGF0ZSwge1xuICAgIHZhbHVlOiBuZXdTdGF0ZS5hbmltYXRpb25Db25maWcuZG9tYWluPy5bMF0gPz8gbnVsbFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFRpbWVGaWx0ZXJUaW1lbGluZU1vZGVVcGRhdGVyPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5zZXRUaW1lRmlsdGVyU3luY1RpbWVsaW5lTW9kZUFjdGlvblxuKSB7XG4gIGNvbnN0IHtpZDogZmlsdGVySWQsIG1vZGU6IHN5bmNUaW1lbGluZU1vZGV9ID0gYWN0aW9uO1xuXG4gIGNvbnN0IGZpbHRlcklkeCA9IHN0YXRlLmZpbHRlcnMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gZmlsdGVySWQpO1xuICBpZiAoZmlsdGVySWR4ID09PSAtMSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IGZpbHRlciA9IHN0YXRlLmZpbHRlcnNbZmlsdGVySWR4XSBhcyBUaW1lUmFuZ2VGaWx0ZXI7XG5cbiAgaWYgKCF2YWxpZGF0ZVN5bmNBbmltYXRpb25Nb2RlKGZpbHRlciwgc3luY1RpbWVsaW5lTW9kZSkpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBuZXdGaWx0ZXIgPSB7XG4gICAgLi4uZmlsdGVyLFxuICAgIHN5bmNUaW1lbGluZU1vZGVcbiAgfTtcblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiBzd2FwXzxGaWx0ZXI+KG5ld0ZpbHRlcikoc3RhdGUuZmlsdGVycylcbiAgfTtcblxuICByZXR1cm4gYWRqdXN0QW5pbWF0aW9uQ29uZmlnV2l0aEZpbHRlcihuZXdTdGF0ZSwgZmlsdGVySWR4KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgc3RhdGUgb2YgdGhlIGxvYWRpbmcgaW5kaWNhdG9yLlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSBzdGF0ZSB2aXNTdGF0ZVxuICogQHBhcmFtIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkIFBheWxvYWQgd2l0aCBjaGFuZ2Ugb2YgbnVtYmVyIG9mIGFjdGl2ZSBsb2FkaW5nIGFjdGlvbnMuXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldExvYWRpbmdJbmRpY2F0b3JVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtwYXlsb2FkOiB7Y2hhbmdlfX06IHtwYXlsb2FkOiBTZXRMb2FkaW5nSW5kaWNhdG9yUGF5bG9hZH1cbik6IFZpc1N0YXRlID0+IHtcbiAgbGV0IHtsb2FkaW5nSW5kaWNhdG9yVmFsdWV9ID0gc3RhdGU7XG4gIGlmICghbG9hZGluZ0luZGljYXRvclZhbHVlKSB7XG4gICAgbG9hZGluZ0luZGljYXRvclZhbHVlID0gMDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbG9hZGluZ0luZGljYXRvclZhbHVlOiBNYXRoLm1heChsb2FkaW5nSW5kaWNhdG9yVmFsdWUgKyBjaGFuZ2UsIDApXG4gIH07XG59O1xuXG5mdW5jdGlvbiBhZGp1c3RBbmltYXRpb25Db25maWdXaXRoRmlsdGVyPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oc3RhdGU6IFMsIGZpbHRlcklkeDogbnVtYmVyKTogUyB7XG4gIGNvbnN0IGZpbHRlciA9IHN0YXRlLmZpbHRlcnNbZmlsdGVySWR4XTtcbiAgaWYgKChmaWx0ZXIgYXMgVGltZVJhbmdlRmlsdGVyKS5zeW5jZWRXaXRoTGF5ZXJUaW1lbGluZSkge1xuICAgIGNvbnN0IHRpbWVsaW5lVmFsdWUgPSBnZXRUaW1lbGluZVZhbHVlRnJvbUZpbHRlcihmaWx0ZXIpO1xuICAgIGNvbnN0IHZhbHVlID0gc3RhdGUuYW5pbWF0aW9uQ29uZmlnLnRpbWVTdGVwc1xuICAgICAgPyBzbmFwVG9NYXJrcyh0aW1lbGluZVZhbHVlLCBzdGF0ZS5hbmltYXRpb25Db25maWcudGltZVN0ZXBzKVxuICAgICAgOiB0aW1lbGluZVZhbHVlO1xuICAgIHJldHVybiBzZXRMYXllckFuaW1hdGlvblRpbWVVcGRhdGVyKHN0YXRlLCB7dmFsdWV9KTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVsaW5lVmFsdWVGcm9tRmlsdGVyKGZpbHRlcikge1xuICByZXR1cm4gZmlsdGVyLnZhbHVlW2ZpbHRlci5zeW5jVGltZWxpbmVNb2RlXTtcbn1cblxuZnVuY3Rpb24gZ2V0U3luY0FuaW1hdGlvbk1vZGUoZmlsdGVyOiBUaW1lUmFuZ2VGaWx0ZXIpIHtcbiAgaWYgKGZpbHRlci5hbmltYXRpb25XaW5kb3cgPT09IEFOSU1BVElPTl9XSU5ET1cuZnJlZSkge1xuICAgIHJldHVybiBmaWx0ZXIuc3luY1RpbWVsaW5lTW9kZSA/PyBTWU5DX1RJTUVMSU5FX01PREVTLmVuZDtcbiAgfVxuXG4gIHJldHVybiBTWU5DX1RJTUVMSU5FX01PREVTLmVuZDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTeW5jQW5pbWF0aW9uTW9kZShmaWx0ZXI6IFRpbWVSYW5nZUZpbHRlciwgbmV3TW9kZTogbnVtYmVyKSB7XG4gIHJldHVybiAhKFxuICAgIGZpbHRlci5hbmltYXRpb25XaW5kb3cgIT09IEFOSU1BVElPTl9XSU5ET1cuZnJlZSAmJiBuZXdNb2RlID09PSBTWU5DX1RJTUVMSU5FX01PREVTLnN0YXJ0XG4gICk7XG59XG5cbmZ1bmN0aW9uIGFkanVzdFRpbWVGaWx0ZXJJbnRlcnZhbChzdGF0ZSwgZmlsdGVyKSB7XG4gIGNvbnN0IGludGVydmFsQmFzZWRBbmltYXRpb25MYXllcnMgPSBnZXRJbnRlcnZhbEJhc2VkQW5pbWF0aW9uTGF5ZXJzKHN0YXRlLmxheWVycyk7XG5cbiAgbGV0IGludGVydmFsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgaWYgKGludGVydmFsQmFzZWRBbmltYXRpb25MYXllcnMubGVuZ3RoID4gMCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBpbnRlcnZhbEluZGV4ID0gaW50ZXJ2YWxCYXNlZEFuaW1hdGlvbkxheWVycy5yZWR1Y2UoKGN1cnJlbnRJbmRleCwgbCkgPT4ge1xuICAgICAgaWYgKGwubWV0YS50YXJnZXRUaW1lSW50ZXJ2YWwpIHtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSBUSU1FX0lOVEVSVkFMU19PUkRFUkVELmZpbmRJbmRleChpID0+IGkgPT09IGwubWV0YS50YXJnZXRUaW1lSW50ZXJ2YWwpO1xuICAgICAgICByZXR1cm4gbmV3SW5kZXggPiAtMSAmJiBuZXdJbmRleCA8IGN1cnJlbnRJbmRleCA/IG5ld0luZGV4IDogY3VycmVudEluZGV4O1xuICAgICAgfVxuICAgIH0sIFRJTUVfSU5URVJWQUxTX09SREVSRUQubGVuZ3RoIC0gMSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGhleFRpbGVJbnRlcnZhbCA9IFRJTUVfSU5URVJWQUxTX09SREVSRURbaW50ZXJ2YWxJbmRleF07XG4gICAgaW50ZXJ2YWwgPSBMYXllclRvRmlsdGVyVGltZUludGVydmFsW2hleFRpbGVJbnRlcnZhbF07XG4gIH1cblxuICBpZiAoIWludGVydmFsKSB7XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuXG4gIC8vIGFkanVzdCBmaWx0ZXJcbiAgY29uc3QgdGltZUZvcm1hdCA9IGdldERlZmF1bHRUaW1lRm9ybWF0KGludGVydmFsKTtcbiAgY29uc3QgdXBkYXRlZFBsb3RUeXBlID0gey4uLmZpbHRlci5wbG90VHlwZSwgaW50ZXJ2YWwsIHRpbWVGb3JtYXR9O1xuICBjb25zdCBuZXdGaWx0ZXIgPSB1cGRhdGVUaW1lRmlsdGVyUGxvdFR5cGUoZmlsdGVyLCB1cGRhdGVkUGxvdFR5cGUsIHN0YXRlLmRhdGFzZXRzKTtcbiAgcmV0dXJuIGFkanVzdFZhbHVlVG9BbmltYXRpb25XaW5kb3coc3RhdGUsIG5ld0ZpbHRlcik7XG59XG5cbi8vIEZpbmQgZGF0YUlkIGZyb20gYSBzYXZlZCB2aXNTdGF0ZSBwcm9wZXJ0eTpcbi8vIGxheWVycywgZmlsdGVycywgaW50ZXJhY3Rpb25zLCBsYXllckJsZW5kaW5nLCBvdmVybGF5QmxlbmRpbmcsIHNwbGl0TWFwcywgYW5pbWF0aW9uQ29uZmlnLCBlZGl0b3Jcbi8vIHJlcGxhY2UgaXQgd2l0aCBhbm90aGVyIGRhdGFJZFxuZnVuY3Rpb24gZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzKHZhbHVlOiBhbnksIGRhdGFJZDogc3RyaW5nLCBkYXRhSWRUb1JlcGxhY2U6IHN0cmluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBmb3IgbGF5ZXJzLCBmaWx0ZXJzLCBjYWxsIGRlZmF1bHRSZXBsYWNlUGFyZW50RGF0YXNldElkcyBvbiBlYWNoIGl0ZW0gaW4gYXJyYXlcbiAgICBjb25zdCByZXBsYWNlZCA9IHZhbHVlXG4gICAgICAubWFwKHYgPT4gZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzKHYsIGRhdGFJZCwgZGF0YUlkVG9SZXBsYWNlKSlcbiAgICAgIC5maWx0ZXIoZCA9PiBkKTtcbiAgICByZXR1cm4gcmVwbGFjZWQubGVuZ3RoID8gcmVwbGFjZWQgOiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUuZGF0YUlkID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5kYXRhSWQgPT09IGRhdGFJZCkge1xuICAgIC8vIG90aGVyc1xuICAgIHJldHVybiB7XG4gICAgICAuLi52YWx1ZSxcbiAgICAgIGRhdGFJZDogZGF0YUlkVG9SZXBsYWNlXG4gICAgfTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLmRhdGFJZCkgJiYgdmFsdWUuZGF0YUlkLmluY2x1ZGVzKGRhdGFJZCkpIHtcbiAgICAvLyBmaWx0ZXJcbiAgICByZXR1cm4ge1xuICAgICAgLi4udmFsdWUsXG4gICAgICBkYXRhSWQ6IHZhbHVlLmRhdGFJZC5tYXAoZCA9PiAoZCA9PT0gZGF0YUlkID8gZGF0YUlkVG9SZXBsYWNlIDogZCkpXG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5jb25maWc/LmRhdGFJZCAmJiB2YWx1ZS5jb25maWc/LmRhdGFJZCA9PT0gZGF0YUlkKSB7XG4gICAgLy8gbGF5ZXJcbiAgICByZXR1cm4ge1xuICAgICAgLi4udmFsdWUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgLi4udmFsdWUuY29uZmlnLFxuICAgICAgICBkYXRhSWQ6IGRhdGFJZFRvUmVwbGFjZVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgZGF0YUlkKSkge1xuICAgIC8vIGZvciB2YWx1ZSBzYXZlZCBhcyB7W2RhdGFJZF06IHsuLi59fVxuICAgIHJldHVybiB7W2RhdGFJZFRvUmVwbGFjZV06IHZhbHVlW2RhdGFJZF19O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEZpbmQgZGF0YXNldElkcyBkZXJpdmVkIGEgc2F2ZWQgdmlzU3RhdGUgUHJvcGVydHk7XG5mdW5jdGlvbiBmaW5kQ2hpbGREYXRhc2V0SWRzKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIGZvciBsYXllcnMsIGZpbHRlcnMsIGNhbGwgZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzIG9uIGVhY2ggaXRlbSBpbiBhcnJheVxuICAgIGNvbnN0IGNoaWxkRGF0YUlkcyA9IHZhbHVlLm1hcChmaW5kQ2hpbGREYXRhc2V0SWRzKS5maWx0ZXIoZCA9PiBkKTtcbiAgICByZXR1cm4gY2hpbGREYXRhSWRzLmxlbmd0aCA/IGNoaWxkRGF0YUlkcyA6IG51bGw7XG4gIH1cblxuICAvLyBjaGlsZCBkYXRhIGlkIHVzdWFsbHkgc3RvcmVzIGluIHRoZSBkZXJpdmVkIGRhdGFzZXQgaW5mb1xuICByZXR1cm4gdmFsdWU/Lm5ld0RhdGFzZXQ/LmluZm8uaWQgfHwgbnVsbDtcbn1cblxuLy8gbW92ZWQgdW5tZXJnZWQgbGF5ZXJzLCBmaWx0ZXJzLCBpbnRlcmFjdGlvbnNcbmZ1bmN0aW9uIG1vdmVWYWx1ZVRvQmVNZXJnZWQoc3RhdGUsIHByb3BWYWx1ZXMsIHtwcm9wLCB0b01lcmdlUHJvcCwgc2F2ZVVubWVyZ2VkfSkge1xuICAvLyByZW1vdmUgcHJvcCB2YWx1ZSBmcm9tIHN0YXRlXG4gIC8vIFRPRE86IHNob3VsZCB3ZSBhZGQgcmVtb3ZlIHVwZGF0ZXIgdG8gbWVyZ2VyIGFzIHdlbGw/XG4gIGlmICghcHJvcFZhbHVlcykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBzdGF0ZVJlbW92ZWQgPVxuICAgIHByb3AgPT09ICdsYXllcnMnXG4gICAgICA/IHByb3BWYWx1ZXMucmVkdWNlKChhY2N1LCBwcm9wVmFsdWUpID0+IHJlbW92ZUxheWVyVXBkYXRlcihhY2N1LCB7aWQ6IHByb3BWYWx1ZS5pZH0pLCBzdGF0ZSlcbiAgICAgIDogQXJyYXkuaXNBcnJheShzdGF0ZVtwcm9wXSlcbiAgICAgID8ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIFtwcm9wXTogc3RhdGVbcHJvcF0uZmlsdGVyKHAgPT4gIXByb3BWYWx1ZXMuZmluZChwcm9wVmFsdWUgPT4gcC5pZCA9PT0gcHJvcFZhbHVlLmlkKSlcbiAgICAgICAgfVxuICAgICAgOiAvLyBpZiBub3QgYXJyYXksIHdlIHdvbid0IHJlbW92ZSBpdCwgcmVtb3ZlIGRhdGFzZXQgc2hvdWxkIGhhbmRsZSBpdFxuICAgICAgICBzdGF0ZTtcblxuICAvLyBtb3ZlIHRvIHN0YXRlVG9CZU1lcmdlZFxuICBjb25zdCB0b0JlTWVyZ2VkID0ge1xuICAgIFt0b01lcmdlUHJvcF06IHNhdmVVbm1lcmdlZFxuICAgICAgPyAvLyBjYWxsIG1lcmdlIHNhdmVVbm1lcmdlZCBtZXRob2RcbiAgICAgICAgc2F2ZVVubWVyZ2VkKHN0YXRlUmVtb3ZlZCwgcHJvcFZhbHVlcylcbiAgICAgIDogLy8gaWYgdG9NZXJnZVByb3AgaXMgYXJhYXksIGFwcGVuZCB0byBpdFxuICAgICAgQXJyYXkuaXNBcnJheShzdGF0ZVJlbW92ZWRbdG9NZXJnZVByb3BdKVxuICAgICAgPyBbLi4uc3RhdGVSZW1vdmVkW3RvTWVyZ2VQcm9wXSwgLi4ucHJvcFZhbHVlc11cbiAgICAgIDogLy8gc2F2ZSBwcm9wVmFsdWVzIHRvIHRvTWVyZ2VcbiAgICAgIGlzT2JqZWN0KHN0YXRlUmVtb3ZlZFt0b01lcmdlUHJvcF0pXG4gICAgICA/IHtcbiAgICAgICAgICAuLi5zdGF0ZVJlbW92ZWRbdG9NZXJnZVByb3BdLFxuICAgICAgICAgIC4uLnByb3BWYWx1ZXNcbiAgICAgICAgfVxuICAgICAgOiBzdGF0ZVJlbW92ZWRbdG9NZXJnZVByb3BdXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZVJlbW92ZWQsXG4gICAgLi4udG9CZU1lcmdlZFxuICB9O1xufVxuXG5mdW5jdGlvbiByZXBsYWNlRGF0YXNldEFuZERlcHM8VCBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFQsXG4gIGRhdGFJZDogc3RyaW5nLFxuICBkYXRhSWRUb1VzZTogc3RyaW5nXG4pOiBUIHtcbiAgcmV0dXJuIGNvbXBvc2VfPFQ+KFtcbiAgICBhcHBseV8ocmVwbGFjZURhdGFzZXREZXBzSW5TdGF0ZSwge2RhdGFJZCwgZGF0YUlkVG9Vc2V9KSxcbiAgICBhcHBseV8ocmVtb3ZlRGF0YXNldFVwZGF0ZXIsIHtkYXRhSWR9KVxuICBdKShzdGF0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlU3RhdGVGb3JEYXRhc2V0UmVwbGFjZTxUIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogVCxcbiAgZGF0YUlkOiBzdHJpbmcsXG4gIGRhdGFJZFRvVXNlOiBzdHJpbmdcbik6IFQge1xuICBjb25zdCBzZXJpYWxpemVkU3RhdGUgPSBzZXJpYWxpemVWaXNTdGF0ZShzdGF0ZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgbmV4dFN0YXRlID0gcmVwbGFjZURhdGFzZXRBbmREZXBzKHN0YXRlLCBkYXRhSWQsIGRhdGFJZFRvVXNlKTtcbiAgLy8gbWFrZSBhIGNvcHkgb2YgbGF5ZXJPcmRlciwgYmVjYXVzZSBsYXllciBpZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBpdCBieSBjYWxsaW5nIHJlbW92ZUxheWVyVXBkYXRlclxuICBjb25zdCBwcmVzZXJ2ZUxheWVyT3JkZXIgPSBbLi4uc3RhdGUubGF5ZXJPcmRlcl07XG5cbiAgLy8gcHJlc2VydmUgZGF0YXNldCBvcmRlclxuICBuZXh0U3RhdGUucHJlc2VydmVEYXRhc2V0T3JkZXIgPSBPYmplY3Qua2V5cyhzdGF0ZS5kYXRhc2V0cykubWFwKGQgPT5cbiAgICBkID09PSBkYXRhSWQgPyBkYXRhSWRUb1VzZSA6IGRcbiAgKTtcblxuICAvLyBwcmVzZXJ2ZUxheWVyT3JkZXJcbiAgaWYgKG5leHRTdGF0ZS5sYXllclRvQmVNZXJnZWQ/Lmxlbmd0aCkge1xuICAgIC8vIGNvcHkgc3BsaXQgbWFwcyB0byBiZSBtZXJnZWQsIGJlY2F1c2UgaXQgd2lsbCBiZSByZXNldCBpbiByZW1vdmUgbGF5ZXJcbiAgICBuZXh0U3RhdGUuc3BsaXRNYXBzVG9CZU1lcmdlZCA9IHNlcmlhbGl6ZWRTdGF0ZT8uc3BsaXRNYXBzID8/IFtdO1xuICAgIG5leHRTdGF0ZS5sYXllck9yZGVyID0gWy4uLnByZXNlcnZlTGF5ZXJPcmRlcl07XG4gIH1cblxuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZURhdGFzZXREZXBzSW5TdGF0ZTxUIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogVCxcbiAge2RhdGFJZCwgZGF0YUlkVG9Vc2V9OiB7ZGF0YUlkOiBzdHJpbmc7IGRhdGFJZFRvVXNlOiBzdHJpbmd9XG4pOiBUIHtcbiAgY29uc3Qgc2VyaWFsaXplZFN0YXRlID0gc2VyaWFsaXplVmlzU3RhdGUoc3RhdGUsIHN0YXRlLnNjaGVtYSk7XG5cbiAgY29uc3QgbmV4dFN0YXRlID0gc3RhdGUubWVyZ2Vycy5yZWR1Y2UoXG4gICAgKFxuICAgICAgYWNjdVN0YXRlLFxuICAgICAge3Byb3AsIHRvTWVyZ2VQcm9wLCByZXBsYWNlUGFyZW50RGF0YXNldElkcywgZ2V0Q2hpbGREYXRhc2V0SWRzLCBzYXZlVW5tZXJnZWQsIHByZXNlcnZlT3JkZXJ9XG4gICAgKSA9PiB7XG4gICAgICAvLyBnZXQgZGF0YXNldCBpZHMgdGhhdCBhcmUgZGVwZW5kcyBvbiB0aGlzIGRhdGFzZXRcbiAgICAgIGNvbnN0IHByb3BzID0gdG9BcnJheShwcm9wKTtcbiAgICAgIGNvbnN0IHRvTWVyZ2VQcm9wcyA9IHRvQXJyYXkodG9NZXJnZVByb3ApO1xuICAgICAgY29uc3Qgc2F2ZWRQcm9wcyA9IHNlcmlhbGl6ZWRTdGF0ZSA/IHByb3BzLm1hcChwID0+IHNlcmlhbGl6ZWRTdGF0ZVtwXSkgOiBbXTtcblxuICAgICAgbGV0IHJlcGxhY2VkU3RhdGUgPSBhY2N1U3RhdGU7XG4gICAgICBzYXZlZFByb3BzLmZvckVhY2goKHByb3BWYWx1ZSwgaSkgPT4ge1xuICAgICAgICBjb25zdCBtZXJnZXJPcHRpb25zID0ge1xuICAgICAgICAgIHByb3A6IHByb3BzW2ldLFxuICAgICAgICAgIHRvTWVyZ2VQcm9wOiB0b01lcmdlUHJvcHNbaV0sXG4gICAgICAgICAgZ2V0Q2hpbGREYXRhc2V0SWRzLFxuICAgICAgICAgIHNhdmVVbm1lcmdlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlcGxhY2VkSXRlbSA9XG4gICAgICAgICAgcmVwbGFjZVBhcmVudERhdGFzZXRJZHM/Lihwcm9wVmFsdWUsIGRhdGFJZCwgZGF0YUlkVG9Vc2UpIHx8XG4gICAgICAgICAgZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzKHByb3BWYWx1ZSwgZGF0YUlkLCBkYXRhSWRUb1VzZSk7XG4gICAgICAgIHJlcGxhY2VkU3RhdGUgPSByZXBsYWNlZEl0ZW1cbiAgICAgICAgICA/IHJlcGxhY2VQcm9wVmFsdWVJblN0YXRlKHJlcGxhY2VkU3RhdGUsIHJlcGxhY2VkSXRlbSwgbWVyZ2VyT3B0aW9ucylcbiAgICAgICAgICA6IHJlcGxhY2VkU3RhdGU7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1lcmdlck9wdGlvbnMudG9NZXJnZVByb3AgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHJlcGxhY2VkU3RhdGVbbWVyZ2VyT3B0aW9ucy50b01lcmdlUHJvcF0/Lmxlbmd0aCAmJlxuICAgICAgICAgIHByZXNlcnZlT3JkZXJcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVwbGFjZWRTdGF0ZVtwcmVzZXJ2ZU9yZGVyXSA9IHByb3BWYWx1ZS5tYXAoaXRlbSA9PiBpdGVtLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXBsYWNlZFN0YXRlO1xuICAgIH0sXG4gICAgc3RhdGVcbiAgKTtcblxuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlUHJvcFZhbHVlSW5TdGF0ZShcbiAgc3RhdGUsXG4gIHJlcGxhY2VkSXRlbSxcbiAge3Byb3AsIHRvTWVyZ2VQcm9wLCBnZXRDaGlsZERhdGFzZXRJZHMsIHNhdmVVbm1lcmdlZH1cbikge1xuICAvLyBwcm9wIGlzIGRlcGVuZHMgb24gdGhlIGRhdGFzZXQgdG8gYmUgcmVwbGFjZWRcbiAgLy8gcmVtb3ZlIHByb3AgZnJvbSBzdGF0ZSwgYW5kIG1vdmUgaXQgdG8gdG9CZU1lcmdlZFxuICBsZXQgbmV4dFN0YXRlID0gbW92ZVZhbHVlVG9CZU1lcmdlZChzdGF0ZSwgcmVwbGFjZWRJdGVtLCB7cHJvcCwgdG9NZXJnZVByb3AsIHNhdmVVbm1lcmdlZH0pO1xuICBjb25zdCBjaGlsZERhdGFJZHMgPSBnZXRDaGlsZERhdGFzZXRJZHM/LihyZXBsYWNlZEl0ZW0pIHx8IGZpbmRDaGlsZERhdGFzZXRJZHMocmVwbGFjZWRJdGVtKTtcblxuICBpZiAoY2hpbGREYXRhSWRzKSB7XG4gICAgbmV4dFN0YXRlID0gdG9BcnJheShjaGlsZERhdGFJZHMpLnJlZHVjZSgoYWNjdSwgY2hpbGREYXRhSWQpID0+IHtcbiAgICAgIC8vIHNob3VsZG4ndCBuZWVkIHRvIGNoYW5nZSBjaGlsZCBkYXRhc2V0IGlkLFxuICAgICAgLy8gYnV0IHN0aWxsIG5lZWQgdG8gbW92ZSBvdXQgb2Ygc3RhdGUgYW5kIG1lcmdlIGJhY2sgaW5cbiAgICAgIHJldHVybiByZXBsYWNlRGF0YXNldEFuZERlcHMoYWNjdSwgY2hpbGREYXRhSWQsIGNoaWxkRGF0YUlkKTtcbiAgICB9LCBuZXh0U3RhdGUpO1xuICB9XG4gIHJldHVybiBuZXh0U3RhdGU7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0EsSUFBQUEsS0FBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsZ0JBQUEsR0FBQUYsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFFLFVBQUEsR0FBQUgsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFHLE9BQUEsR0FBQUgsT0FBQTtBQUNBLElBQUFJLFVBQUEsR0FBQUwsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFLLElBQUEsR0FBQU4sc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFNLFFBQUEsR0FBQVAsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFPLEtBQUEsR0FBQVIsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFRLEtBQUEsR0FBQVQsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFTLElBQUEsR0FBQVYsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFVLE1BQUEsR0FBQUMsdUJBQUEsQ0FBQVgsT0FBQTtBQUVBLElBQUFZLE9BQUEsR0FBQVosT0FBQTtBQVFBLElBQUFhLFFBQUEsR0FBQWIsT0FBQTtBQTJCQSxJQUFBYyxNQUFBLEdBQUFkLE9BQUE7QUE2QkEsSUFBQWUsWUFBQSxHQUFBZixPQUFBO0FBRUEsSUFBQWdCLFVBQUEsR0FBQWhCLE9BQUE7QUFpQkEsSUFBQWlCLE9BQUEsR0FBQWpC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