"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDatasetContext = getDatasetContext;
exports.getGeometriesFromDataset = getGeometriesFromDataset;
exports.getValuesFromDataset = getValuesFromDataset;
exports.getValuesFromVectorTileLayer = getValuesFromVectorTileLayer;
exports.highlightRows = highlightRows;
exports.highlightRowsByColumnValues = highlightRowsByColumnValues;
exports.interpolateColor = interpolateColor;
exports.saveAsDataset = saveAsDataset;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _colorInterpolate = _interopRequireDefault(require("color-interpolate"));
var _constants = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/constants/src");
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0,
        F = function F() {};
      return {
        s: F,
        n: function n() {
          return _n >= r.length ? {
            done: !0
          } : {
            done: !1,
            value: r[_n++]
          };
        },
        e: function e(r) {
          throw r;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o,
    a = !0,
    u = !1;
  return {
    s: function s() {
      t = t.call(r);
    },
    n: function n() {
      var r = t.next();
      return a = r.done, r;
    },
    e: function e(r) {
      u = !0, o = r;
    },
    f: function f() {
      try {
        a || null == t["return"] || t["return"]();
      } finally {
        if (u) throw o;
      }
    }
  };
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
} // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
/**
 * Interpolate the colors from the original colors with the given number of colors
 * @param originalColors The original colors
 * @param numberOfColors The number of colors
 * @returns The interpolated colors
 */
function interpolateColor(originalColors, numberOfColors) {
  if (originalColors.length === numberOfColors) {
    return originalColors;
  }
  var interp = (0, _colorInterpolate["default"])(originalColors);
  var colors = Array.from({
    length: numberOfColors
  }, function (_, j) {
    return interp(j / (numberOfColors - 1));
  });
  // convert colors from 'rgb(255, 255, 255)' to '#ffffff'
  var hexColors = colors.map(function (color) {
    var rgb = color.match(/\d+/g);
    return "#".concat(rgb === null || rgb === void 0 ? void 0 : rgb.map(function (c) {
      return parseInt(c).toString(16).padStart(2, '0');
    }).join(''));
  });
  return hexColors;
}

/**
 * Get the values from a dataset for a variable
 * @param datasets
 * @param datasetName
 * @param variableName
 * @returns {number[]}
 */
function getValuesFromDataset(datasets, layers, datasetName, variableName) {
  // find which dataset has the variableName
  var datasetId = Object.keys(datasets).find(function (dataId) {
    return datasets[dataId].label === datasetName;
  });
  if (!datasetId) {
    throw new Error("Dataset ".concat(datasetName, " not found"));
  }
  var dataset = datasets[datasetId];
  if (dataset) {
    // check if field exists
    var field = dataset.fields.find(function (field) {
      return field.name === variableName;
    });
    if (!field) {
      throw new Error("Field ".concat(variableName, " not found in dataset ").concat(datasetName));
    }
    // for vector-tile, getting values from layerData
    if (dataset.type === 'vector-tile') {
      // get field from dataset
      var _field = dataset.fields.find(function (field) {
        return field.name === variableName;
      });
      if (_field) {
        return getValuesFromVectorTileLayer(datasetId, layers, _field);
      }
    }
    return Array.from({
      length: dataset.length
    }, function (_, i) {
      return dataset.getValue(variableName, i);
    });
  }
  return [];
}
function isVectorTileLayer(layer) {
  return layer.type === _constants.LAYER_TYPES.vectorTile;
}
function getValuesFromVectorTileLayer(datasetId, layers, field) {
  // get the index of the layer
  var layerIndex = layers.findIndex(function (layer) {
    return layer.config.dataId === datasetId;
  });
  if (layerIndex === -1) return [];
  var layer = layers[layerIndex];
  if (!isVectorTileLayer(layer)) return [];
  var accessor = layer.accessRowValue(field);
  var values = [];
  // @ts-expect-error TODO fix this later in the vector-tile layer
  var _iterator = _createForOfIteratorHelper(layer.tileDataset.tileSet),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var row = _step.value;
      var value = accessor(field, row);
      if (value === null) break;
      values.push(value);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return values;
}

/**
 * Highlight the rows in a dataset
 * @param datasets The kepler.gl datasets
 * @param layers The kepler.gl layers
 * @param datasetName The name of the dataset
 * @param selectedRowIndices The indices of the rows to highlight
 * @param layerSetIsValid The function to set the layer validity
 */
function highlightRows(datasets, layers, datasetName, selectedRowIndices, layerSetIsValid) {
  // update the filteredIndex in the dataset
  var datasetId = Object.keys(datasets).find(function (dataId) {
    return datasets[dataId].label === datasetName;
  });
  if (!datasetId) return;
  var dataset = datasets[datasetId];
  if (dataset) {
    dataset.filteredIndex = selectedRowIndices.length === 0 ? dataset.allIndexes : selectedRowIndices;
    // get all layers that use this dataset
    var selectLayers = layers.filter(function (layer) {
      return layer.config.dataId === dataset.id;
    });
    selectLayers.forEach(function (layer) {
      layer.formatLayerData(datasets);
      // trigger a re-render using layerSetIsValid() to update the top layer
      layerSetIsValid(layer, true);
    });
  }
}

/**
 * Get the dataset context, which is used to provide the dataset information to the AI assistant
 * @param datasets The kepler.gl datasets
 * @param layers The kepler.gl layers
 * @returns The dataset context
 */
function getDatasetContext(datasets, layers) {
  if (!datasets || !layers) return '';
  var context = 'Please ONLY use the following datasets and layers to answer the user question:';
  var dataMeta = Object.values(datasets).map(function (dataset) {
    return {
      datasetName: dataset.label,
      datasetId: dataset.id,
      fields: dataset.fields.map(function (field) {
        return (0, _defineProperty2["default"])({}, field.name, field.type);
      }),
      layers: layers.filter(function (layer) {
        return layer.config.dataId === dataset.id;
      }).map(function (layer) {
        return {
          id: layer.id,
          label: layer.config.label,
          type: layer.type,
          geometryMode: layer.config.columnMode,
          // get the valid geometry columns as string
          geometryColumns: Object.fromEntries(Object.entries(layer.config.columns).filter(function (_ref2) {
            var _ref3 = (0, _slicedToArray2["default"])(_ref2, 2),
              value = _ref3[1];
            return value !== null;
          }).map(function (_ref4) {
            var _ref5 = (0, _slicedToArray2["default"])(_ref4, 2),
              key = _ref5[0],
              value = _ref5[1];
            return [key, (0, _typeof2["default"])(value) === 'object' && value !== null ? Object.fromEntries(Object.entries(value).filter(function (_ref6) {
              var _ref7 = (0, _slicedToArray2["default"])(_ref6, 2),
                v = _ref7[1];
              return v !== null;
            })) : value];
          }))
        };
      })
    };
  });
  return "".concat(context, "\n").concat(JSON.stringify(dataMeta));
}

/**
 * Get the geometries from a dataset
 * @param datasets The kepler.gl datasets
 * @param layers The kepler.gl layers
 * @param layerData The layer data
 * @param datasetName The name of the dataset
 * @returns The geometries
 */
function getGeometriesFromDataset(datasets, layers, layerData, datasetName) {
  var datasetId = Object.keys(datasets).find(function (dataId) {
    return datasets[dataId].label === datasetName;
  });
  if (!datasetId) {
    return [];
  }
  var dataset = datasets[datasetId];

  // if layer is vector-tile, get the geometries from the layer
  if (dataset.type === 'vector-tile') {
    // find the vector-tile layer
    var selected = layers.filter(function (layer) {
      return layer.config.dataId === dataset.id;
    });
    var layer = selected.find(function (layer) {
      return layer.type === _constants.LAYER_TYPES.vectorTile;
    });
    if (!layer) return [];
    var geometries = [];
    // @ts-expect-error TODO fix this later in the vector-tile layer
    var _iterator2 = _createForOfIteratorHelper(layer.tileDataset.tileSet),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var row = _step2.value;
        geometries.push(row);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return geometries;
  }

  // for non-vector-tile dataset, get the geometries from the possible layer
  var selectedLayers = layers.filter(function (layer) {
    return layer.config.dataId === dataset.id;
  });
  if (selectedLayers.length === 0) return [];

  // find geojson layer, then point layer, then other layers
  var geojsonLayer = selectedLayers.find(function (layer) {
    return layer.type === _constants.LAYER_TYPES.geojson;
  });
  var pointLayer = selectedLayers.find(function (layer) {
    return layer.type === _constants.LAYER_TYPES.point;
  });
  var otherLayers = selectedLayers.filter(function (layer) {
    return layer.type !== _constants.LAYER_TYPES.geojson && layer.type !== _constants.LAYER_TYPES.point;
  });
  var validLayer = geojsonLayer || pointLayer || otherLayers[0];
  if (validLayer) {
    var layerIndex = layers.findIndex(function (layer) {
      return layer.id === validLayer.id;
    });
    var _geometries = layerData[layerIndex];
    return _geometries.data;
  }
  return [];
}

/**
 * Save the data as a new dataset by joining it with the left dataset
 * @param datasets The kepler.gl datasets
 * @param datasetName The name of the left dataset
 * @param data The data to save
 * @param addDataToMap The function to add the data to the map
 */
function saveAsDataset(datasets, layers, datasetName, newDatasetName, data) {
  // find datasetId from datasets
  var datasetId = Object.keys(datasets).find(function (dataId) {
    return datasets[dataId].label === datasetName;
  });
  if (!datasetId) return;

  // check if newDatasetName already exists
  if (Object.keys(datasets).includes(newDatasetName)) return;

  // Save the data as a new dataset by joining it with the left dataset
  var leftDataset = datasets[datasetId];
  var numRows = leftDataset.length;
  var geometries;
  if (leftDataset.type === 'vector-tile') {
    // we need to get geometries from the vector-tile layer
    geometries = getFeaturesFromVectorTile(leftDataset, layers) || [];
    numRows = geometries.length;
  }
  var fields = [].concat((0, _toConsumableArray2["default"])(Object.keys(data).map(function (fieldName, index) {
    return {
      name: fieldName,
      id: "".concat(fieldName, "_").concat(index),
      displayName: fieldName,
      type: determineFieldType(data[fieldName][0])
    };
  })), (0, _toConsumableArray2["default"])(leftDataset.fields.map(function (field, index) {
    return {
      name: field.name,
      id: field.id || "".concat(field.name, "_").concat(index),
      displayName: field.displayName,
      type: field.type
    };
  })), (0, _toConsumableArray2["default"])(leftDataset.type === 'vector-tile' ? [{
    name: '_geojson',
    id: '_geojson',
    displayName: '_geojson',
    type: 'geojson'
  }] : []));

  // Pre-calculate data values array
  var dataValues = Object.values(data);
  var rows = Array(numRows).fill(null).map(function (_, rowIdx) {
    return [].concat((0, _toConsumableArray2["default"])(dataValues.map(function (col) {
      return col[rowIdx];
    })), (0, _toConsumableArray2["default"])(leftDataset.fields.map(function (field) {
      var _geometries$rowIdx$pr;
      return leftDataset.type === 'vector-tile' ? (_geometries$rowIdx$pr = geometries[rowIdx].properties) === null || _geometries$rowIdx$pr === void 0 ? void 0 : _geometries$rowIdx$pr[field.name] : leftDataset.getValue(field.name, rowIdx);
    })), (0, _toConsumableArray2["default"])(leftDataset.type === 'vector-tile' ? [geometries[rowIdx]] : []));
  });

  // create new dataset
  var newDataset = {
    info: {
      id: newDatasetName,
      label: newDatasetName
    },
    data: {
      fields: fields,
      rows: rows
    }
  };
  return newDataset;
}

/**
 * Helper function to determine field type
 * @param value The value to determine the field type
 * @returns The field type
 */
function determineFieldType(value) {
  return typeof value === 'number' ? Number.isInteger(value) ? _constants.ALL_FIELD_TYPES.integer : _constants.ALL_FIELD_TYPES.real : _constants.ALL_FIELD_TYPES.string;
}
function highlightRowsByColumnValues(datasets, layers, datasetName, columnName, selectedValues, layerSetIsValid) {
  var datasetId = Object.keys(datasets).find(function (dataId) {
    return datasets[dataId].label === datasetName;
  });
  if (!datasetId) return;
  var dataset = datasets[datasetId];
  if (dataset) {
    // get the values of the column
    var values = Array.from({
      length: dataset.length
    }, function (_, i) {
      return dataset.getValue(columnName, i);
    });
    // create a dict using the values
    var valueDict = values.reduce(function (acc, value, index) {
      acc[value] = index;
      return acc;
    }, {});
    // need to fix the type error of value here
    var selectedIndices = selectedValues.map(function (value) {
      return valueDict[value];
    });
    // highlight the rows
    highlightRows(datasets, layers, datasetName, selectedIndices, layerSetIsValid);
  }
}
function getFeaturesFromVectorTile(leftDataset, layers) {
  var layerIndex = layers.findIndex(function (layer) {
    return layer.config.dataId === leftDataset.id;
  });
  if (layerIndex === -1) return;
  var layer = layers[layerIndex];
  if (!isVectorTileLayer(layer)) return;
  var features = [];
  // @ts-expect-error TODO fix this later in the vector-tile layer
  var _iterator3 = _createForOfIteratorHelper(layer.tileDataset.tileSet),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var row = _step3.value;
      features.push(row);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return features;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfY29sb3JJbnRlcnBvbGF0ZSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2NvbnN0YW50cyIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiciIsImUiLCJ0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBcnJheSIsImlzQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJsZW5ndGgiLCJfbiIsIkYiLCJzIiwibiIsImRvbmUiLCJ2YWx1ZSIsImYiLCJUeXBlRXJyb3IiLCJvIiwiYSIsInUiLCJjYWxsIiwibmV4dCIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwiaW50ZXJwb2xhdGVDb2xvciIsIm9yaWdpbmFsQ29sb3JzIiwibnVtYmVyT2ZDb2xvcnMiLCJpbnRlcnAiLCJjb2xvcnMiLCJfIiwiaiIsImhleENvbG9ycyIsIm1hcCIsImNvbG9yIiwicmdiIiwibWF0Y2giLCJjb25jYXQiLCJjIiwicGFyc2VJbnQiLCJwYWRTdGFydCIsImpvaW4iLCJnZXRWYWx1ZXNGcm9tRGF0YXNldCIsImRhdGFzZXRzIiwibGF5ZXJzIiwiZGF0YXNldE5hbWUiLCJ2YXJpYWJsZU5hbWUiLCJkYXRhc2V0SWQiLCJPYmplY3QiLCJrZXlzIiwiZmluZCIsImRhdGFJZCIsImxhYmVsIiwiRXJyb3IiLCJkYXRhc2V0IiwiZmllbGQiLCJmaWVsZHMiLCJ0eXBlIiwiX2ZpZWxkIiwiZ2V0VmFsdWVzRnJvbVZlY3RvclRpbGVMYXllciIsImkiLCJnZXRWYWx1ZSIsImlzVmVjdG9yVGlsZUxheWVyIiwibGF5ZXIiLCJMQVlFUl9UWVBFUyIsInZlY3RvclRpbGUiLCJsYXllckluZGV4IiwiZmluZEluZGV4IiwiY29uZmlnIiwiYWNjZXNzb3IiLCJhY2Nlc3NSb3dWYWx1ZSIsInZhbHVlcyIsIl9pdGVyYXRvciIsInRpbGVEYXRhc2V0IiwidGlsZVNldCIsIl9zdGVwIiwicm93IiwicHVzaCIsImVyciIsImhpZ2hsaWdodFJvd3MiLCJzZWxlY3RlZFJvd0luZGljZXMiLCJsYXllclNldElzVmFsaWQiLCJmaWx0ZXJlZEluZGV4IiwiYWxsSW5kZXhlcyIsInNlbGVjdExheWVycyIsImZpbHRlciIsImlkIiwiZm9yRWFjaCIsImZvcm1hdExheWVyRGF0YSIsImdldERhdGFzZXRDb250ZXh0IiwiY29udGV4dCIsImRhdGFNZXRhIiwiX2RlZmluZVByb3BlcnR5MiIsImdlb21ldHJ5TW9kZSIsImNvbHVtbk1vZGUiLCJnZW9tZXRyeUNvbHVtbnMiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJjb2x1bW5zIiwiX3JlZjIiLCJfcmVmMyIsIl9zbGljZWRUb0FycmF5MiIsIl9yZWY0IiwiX3JlZjUiLCJrZXkiLCJfdHlwZW9mMiIsIl9yZWY2IiwiX3JlZjciLCJ2IiwiSlNPTiIsInN0cmluZ2lmeSIsImdldEdlb21ldHJpZXNGcm9tRGF0YXNldCIsImxheWVyRGF0YSIsInNlbGVjdGVkIiwiZ2VvbWV0cmllcyIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJzZWxlY3RlZExheWVycyIsImdlb2pzb25MYXllciIsImdlb2pzb24iLCJwb2ludExheWVyIiwicG9pbnQiLCJvdGhlckxheWVycyIsInZhbGlkTGF5ZXIiLCJfZ2VvbWV0cmllcyIsImRhdGEiLCJzYXZlQXNEYXRhc2V0IiwibmV3RGF0YXNldE5hbWUiLCJpbmNsdWRlcyIsImxlZnREYXRhc2V0IiwibnVtUm93cyIsImdldEZlYXR1cmVzRnJvbVZlY3RvclRpbGUiLCJfdG9Db25zdW1hYmxlQXJyYXkyIiwiZmllbGROYW1lIiwiaW5kZXgiLCJkaXNwbGF5TmFtZSIsImRldGVybWluZUZpZWxkVHlwZSIsImRhdGFWYWx1ZXMiLCJyb3dzIiwiZmlsbCIsInJvd0lkeCIsImNvbCIsIl9nZW9tZXRyaWVzJHJvd0lkeCRwciIsInByb3BlcnRpZXMiLCJuZXdEYXRhc2V0IiwiaW5mbyIsIk51bWJlciIsImlzSW50ZWdlciIsIkFMTF9GSUVMRF9UWVBFUyIsImludGVnZXIiLCJyZWFsIiwic3RyaW5nIiwiaGlnaGxpZ2h0Um93c0J5Q29sdW1uVmFsdWVzIiwiY29sdW1uTmFtZSIsInNlbGVjdGVkVmFsdWVzIiwidmFsdWVEaWN0IiwicmVkdWNlIiwiYWNjIiwic2VsZWN0ZWRJbmRpY2VzIiwiZmVhdHVyZXMiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Rvb2xzL3V0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCBpbnRlcnBvbGF0ZSBmcm9tICdjb2xvci1pbnRlcnBvbGF0ZSc7XG5pbXBvcnQge0ZlYXR1cmV9IGZyb20gJ2dlb2pzb24nO1xuaW1wb3J0IHtMYXllciwgVmVjdG9yVGlsZUxheWVyfSBmcm9tICdAa2VwbGVyLmdsL2xheWVycyc7XG5pbXBvcnQge0RhdGFzZXRzLCBLZXBsZXJUYWJsZX0gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5pbXBvcnQge1NwYXRpYWxKb2luR2VvbWV0cmllc30gZnJvbSAnQG9wZW5hc3Npc3RhbnQvZ2VvZGEnO1xuaW1wb3J0IHtBTExfRklFTERfVFlQRVMsIExBWUVSX1RZUEVTfSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge0ZpZWxkLCBQcm90b0RhdGFzZXQsIFByb3RvRGF0YXNldEZpZWxkfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcblxuLyoqXG4gKiBJbnRlcnBvbGF0ZSB0aGUgY29sb3JzIGZyb20gdGhlIG9yaWdpbmFsIGNvbG9ycyB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2YgY29sb3JzXG4gKiBAcGFyYW0gb3JpZ2luYWxDb2xvcnMgVGhlIG9yaWdpbmFsIGNvbG9yc1xuICogQHBhcmFtIG51bWJlck9mQ29sb3JzIFRoZSBudW1iZXIgb2YgY29sb3JzXG4gKiBAcmV0dXJucyBUaGUgaW50ZXJwb2xhdGVkIGNvbG9yc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGVDb2xvcihvcmlnaW5hbENvbG9yczogc3RyaW5nW10sIG51bWJlck9mQ29sb3JzOiBudW1iZXIpIHtcbiAgaWYgKG9yaWdpbmFsQ29sb3JzLmxlbmd0aCA9PT0gbnVtYmVyT2ZDb2xvcnMpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxDb2xvcnM7XG4gIH1cbiAgY29uc3QgaW50ZXJwID0gaW50ZXJwb2xhdGUob3JpZ2luYWxDb2xvcnMpO1xuICBjb25zdCBjb2xvcnMgPSBBcnJheS5mcm9tKHtsZW5ndGg6IG51bWJlck9mQ29sb3JzfSwgKF8sIGopID0+IGludGVycChqIC8gKG51bWJlck9mQ29sb3JzIC0gMSkpKTtcbiAgLy8gY29udmVydCBjb2xvcnMgZnJvbSAncmdiKDI1NSwgMjU1LCAyNTUpJyB0byAnI2ZmZmZmZidcbiAgY29uc3QgaGV4Q29sb3JzID0gY29sb3JzLm1hcChjb2xvciA9PiB7XG4gICAgY29uc3QgcmdiID0gY29sb3IubWF0Y2goL1xcZCsvZyk7XG4gICAgcmV0dXJuIGAjJHtyZ2I/Lm1hcChjID0+IHBhcnNlSW50KGMpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKX1gO1xuICB9KTtcbiAgcmV0dXJuIGhleENvbG9ycztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlcyBmcm9tIGEgZGF0YXNldCBmb3IgYSB2YXJpYWJsZVxuICogQHBhcmFtIGRhdGFzZXRzXG4gKiBAcGFyYW0gZGF0YXNldE5hbWVcbiAqIEBwYXJhbSB2YXJpYWJsZU5hbWVcbiAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlc0Zyb21EYXRhc2V0KFxuICBkYXRhc2V0czogRGF0YXNldHMsXG4gIGxheWVyczogTGF5ZXJbXSxcbiAgZGF0YXNldE5hbWU6IHN0cmluZyxcbiAgdmFyaWFibGVOYW1lOiBzdHJpbmdcbik6IHVua25vd25bXSB7XG4gIC8vIGZpbmQgd2hpY2ggZGF0YXNldCBoYXMgdGhlIHZhcmlhYmxlTmFtZVxuICBjb25zdCBkYXRhc2V0SWQgPSBPYmplY3Qua2V5cyhkYXRhc2V0cykuZmluZChkYXRhSWQgPT4gZGF0YXNldHNbZGF0YUlkXS5sYWJlbCA9PT0gZGF0YXNldE5hbWUpO1xuICBpZiAoIWRhdGFzZXRJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRGF0YXNldCAke2RhdGFzZXROYW1lfSBub3QgZm91bmRgKTtcbiAgfVxuICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbZGF0YXNldElkXTtcbiAgaWYgKGRhdGFzZXQpIHtcbiAgICAvLyBjaGVjayBpZiBmaWVsZCBleGlzdHNcbiAgICBjb25zdCBmaWVsZCA9IGRhdGFzZXQuZmllbGRzLmZpbmQoZmllbGQgPT4gZmllbGQubmFtZSA9PT0gdmFyaWFibGVOYW1lKTtcbiAgICBpZiAoIWZpZWxkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkICR7dmFyaWFibGVOYW1lfSBub3QgZm91bmQgaW4gZGF0YXNldCAke2RhdGFzZXROYW1lfWApO1xuICAgIH1cbiAgICAvLyBmb3IgdmVjdG9yLXRpbGUsIGdldHRpbmcgdmFsdWVzIGZyb20gbGF5ZXJEYXRhXG4gICAgaWYgKGRhdGFzZXQudHlwZSA9PT0gJ3ZlY3Rvci10aWxlJykge1xuICAgICAgLy8gZ2V0IGZpZWxkIGZyb20gZGF0YXNldFxuICAgICAgY29uc3QgZmllbGQgPSBkYXRhc2V0LmZpZWxkcy5maW5kKGZpZWxkID0+IGZpZWxkLm5hbWUgPT09IHZhcmlhYmxlTmFtZSk7XG4gICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlc0Zyb21WZWN0b3JUaWxlTGF5ZXIoZGF0YXNldElkLCBsYXllcnMsIGZpZWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oe2xlbmd0aDogZGF0YXNldC5sZW5ndGh9LCAoXywgaSkgPT4gZGF0YXNldC5nZXRWYWx1ZSh2YXJpYWJsZU5hbWUsIGkpKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIGlzVmVjdG9yVGlsZUxheWVyKGxheWVyOiBMYXllcik6IGxheWVyIGlzIFZlY3RvclRpbGVMYXllciB7XG4gIHJldHVybiBsYXllci50eXBlID09PSBMQVlFUl9UWVBFUy52ZWN0b3JUaWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVzRnJvbVZlY3RvclRpbGVMYXllcihkYXRhc2V0SWQ6IHN0cmluZywgbGF5ZXJzOiBMYXllcltdLCBmaWVsZDogRmllbGQpIHtcbiAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGF5ZXJcbiAgY29uc3QgbGF5ZXJJbmRleCA9IGxheWVycy5maW5kSW5kZXgobGF5ZXIgPT4gbGF5ZXIuY29uZmlnLmRhdGFJZCA9PT0gZGF0YXNldElkKTtcbiAgaWYgKGxheWVySW5kZXggPT09IC0xKSByZXR1cm4gW107XG4gIGNvbnN0IGxheWVyID0gbGF5ZXJzW2xheWVySW5kZXhdO1xuICBpZiAoIWlzVmVjdG9yVGlsZUxheWVyKGxheWVyKSkgcmV0dXJuIFtdO1xuICBjb25zdCBhY2Nlc3NvciA9IGxheWVyLmFjY2Vzc1Jvd1ZhbHVlKGZpZWxkKTtcbiAgY29uc3QgdmFsdWVzOiB1bmtub3duW10gPSBbXTtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGZpeCB0aGlzIGxhdGVyIGluIHRoZSB2ZWN0b3ItdGlsZSBsYXllclxuICBmb3IgKGNvbnN0IHJvdyBvZiBsYXllci50aWxlRGF0YXNldC50aWxlU2V0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBhY2Nlc3NvcihmaWVsZCwgcm93KTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIGJyZWFrO1xuICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vKipcbiAqIEhpZ2hsaWdodCB0aGUgcm93cyBpbiBhIGRhdGFzZXRcbiAqIEBwYXJhbSBkYXRhc2V0cyBUaGUga2VwbGVyLmdsIGRhdGFzZXRzXG4gKiBAcGFyYW0gbGF5ZXJzIFRoZSBrZXBsZXIuZ2wgbGF5ZXJzXG4gKiBAcGFyYW0gZGF0YXNldE5hbWUgVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXRcbiAqIEBwYXJhbSBzZWxlY3RlZFJvd0luZGljZXMgVGhlIGluZGljZXMgb2YgdGhlIHJvd3MgdG8gaGlnaGxpZ2h0XG4gKiBAcGFyYW0gbGF5ZXJTZXRJc1ZhbGlkIFRoZSBmdW5jdGlvbiB0byBzZXQgdGhlIGxheWVyIHZhbGlkaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoaWdobGlnaHRSb3dzKFxuICBkYXRhc2V0czogRGF0YXNldHMsXG4gIGxheWVyczogTGF5ZXJbXSxcbiAgZGF0YXNldE5hbWU6IHN0cmluZyxcbiAgc2VsZWN0ZWRSb3dJbmRpY2VzOiBudW1iZXJbXSxcbiAgbGF5ZXJTZXRJc1ZhbGlkOiAobGF5ZXI6IExheWVyLCBpc1ZhbGlkOiBib29sZWFuKSA9PiB2b2lkXG4pIHtcbiAgLy8gdXBkYXRlIHRoZSBmaWx0ZXJlZEluZGV4IGluIHRoZSBkYXRhc2V0XG4gIGNvbnN0IGRhdGFzZXRJZCA9IE9iamVjdC5rZXlzKGRhdGFzZXRzKS5maW5kKGRhdGFJZCA9PiBkYXRhc2V0c1tkYXRhSWRdLmxhYmVsID09PSBkYXRhc2V0TmFtZSk7XG4gIGlmICghZGF0YXNldElkKSByZXR1cm47XG4gIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tkYXRhc2V0SWRdO1xuICBpZiAoZGF0YXNldCkge1xuICAgIGRhdGFzZXQuZmlsdGVyZWRJbmRleCA9XG4gICAgICBzZWxlY3RlZFJvd0luZGljZXMubGVuZ3RoID09PSAwID8gZGF0YXNldC5hbGxJbmRleGVzIDogc2VsZWN0ZWRSb3dJbmRpY2VzO1xuICAgIC8vIGdldCBhbGwgbGF5ZXJzIHRoYXQgdXNlIHRoaXMgZGF0YXNldFxuICAgIGNvbnN0IHNlbGVjdExheWVycyA9IGxheWVycy5maWx0ZXIobGF5ZXIgPT4gbGF5ZXIuY29uZmlnLmRhdGFJZCA9PT0gZGF0YXNldC5pZCk7XG4gICAgc2VsZWN0TGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgbGF5ZXIuZm9ybWF0TGF5ZXJEYXRhKGRhdGFzZXRzKTtcbiAgICAgIC8vIHRyaWdnZXIgYSByZS1yZW5kZXIgdXNpbmcgbGF5ZXJTZXRJc1ZhbGlkKCkgdG8gdXBkYXRlIHRoZSB0b3AgbGF5ZXJcbiAgICAgIGxheWVyU2V0SXNWYWxpZChsYXllciwgdHJ1ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRhdGFzZXQgY29udGV4dCwgd2hpY2ggaXMgdXNlZCB0byBwcm92aWRlIHRoZSBkYXRhc2V0IGluZm9ybWF0aW9uIHRvIHRoZSBBSSBhc3Npc3RhbnRcbiAqIEBwYXJhbSBkYXRhc2V0cyBUaGUga2VwbGVyLmdsIGRhdGFzZXRzXG4gKiBAcGFyYW0gbGF5ZXJzIFRoZSBrZXBsZXIuZ2wgbGF5ZXJzXG4gKiBAcmV0dXJucyBUaGUgZGF0YXNldCBjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhc2V0Q29udGV4dChkYXRhc2V0cz86IERhdGFzZXRzLCBsYXllcnM/OiBMYXllcltdKSB7XG4gIGlmICghZGF0YXNldHMgfHwgIWxheWVycykgcmV0dXJuICcnO1xuICBjb25zdCBjb250ZXh0ID0gJ1BsZWFzZSBPTkxZIHVzZSB0aGUgZm9sbG93aW5nIGRhdGFzZXRzIGFuZCBsYXllcnMgdG8gYW5zd2VyIHRoZSB1c2VyIHF1ZXN0aW9uOic7XG4gIGNvbnN0IGRhdGFNZXRhID0gT2JqZWN0LnZhbHVlcyhkYXRhc2V0cykubWFwKChkYXRhc2V0OiBLZXBsZXJUYWJsZSkgPT4gKHtcbiAgICBkYXRhc2V0TmFtZTogZGF0YXNldC5sYWJlbCxcbiAgICBkYXRhc2V0SWQ6IGRhdGFzZXQuaWQsXG4gICAgZmllbGRzOiBkYXRhc2V0LmZpZWxkcy5tYXAoZmllbGQgPT4gKHtbZmllbGQubmFtZV06IGZpZWxkLnR5cGV9KSksXG4gICAgbGF5ZXJzOiBsYXllcnNcbiAgICAgIC5maWx0ZXIobGF5ZXIgPT4gbGF5ZXIuY29uZmlnLmRhdGFJZCA9PT0gZGF0YXNldC5pZClcbiAgICAgIC5tYXAobGF5ZXIgPT4gKHtcbiAgICAgICAgaWQ6IGxheWVyLmlkLFxuICAgICAgICBsYWJlbDogbGF5ZXIuY29uZmlnLmxhYmVsLFxuICAgICAgICB0eXBlOiBsYXllci50eXBlLFxuICAgICAgICBnZW9tZXRyeU1vZGU6IGxheWVyLmNvbmZpZy5jb2x1bW5Nb2RlLFxuICAgICAgICAvLyBnZXQgdGhlIHZhbGlkIGdlb21ldHJ5IGNvbHVtbnMgYXMgc3RyaW5nXG4gICAgICAgIGdlb21ldHJ5Q29sdW1uczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGxheWVyLmNvbmZpZy5jb2x1bW5zKVxuICAgICAgICAgICAgLmZpbHRlcigoWywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gbnVsbClcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh2YWx1ZSkuZmlsdGVyKChbLCB2XSkgPT4gdiAhPT0gbnVsbCkpXG4gICAgICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICAgICAgXSlcbiAgICAgICAgKVxuICAgICAgfSkpXG4gIH0pKTtcbiAgcmV0dXJuIGAke2NvbnRleHR9XFxuJHtKU09OLnN0cmluZ2lmeShkYXRhTWV0YSl9YDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGdlb21ldHJpZXMgZnJvbSBhIGRhdGFzZXRcbiAqIEBwYXJhbSBkYXRhc2V0cyBUaGUga2VwbGVyLmdsIGRhdGFzZXRzXG4gKiBAcGFyYW0gbGF5ZXJzIFRoZSBrZXBsZXIuZ2wgbGF5ZXJzXG4gKiBAcGFyYW0gbGF5ZXJEYXRhIFRoZSBsYXllciBkYXRhXG4gKiBAcGFyYW0gZGF0YXNldE5hbWUgVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXRcbiAqIEByZXR1cm5zIFRoZSBnZW9tZXRyaWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHZW9tZXRyaWVzRnJvbURhdGFzZXQoXG4gIGRhdGFzZXRzOiBEYXRhc2V0cyxcbiAgbGF5ZXJzOiBMYXllcltdLFxuICBsYXllckRhdGE6IGFueVtdLFxuICBkYXRhc2V0TmFtZTogc3RyaW5nXG4pOiBTcGF0aWFsSm9pbkdlb21ldHJpZXMge1xuICBjb25zdCBkYXRhc2V0SWQgPSBPYmplY3Qua2V5cyhkYXRhc2V0cykuZmluZChkYXRhSWQgPT4gZGF0YXNldHNbZGF0YUlkXS5sYWJlbCA9PT0gZGF0YXNldE5hbWUpO1xuICBpZiAoIWRhdGFzZXRJZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbZGF0YXNldElkXTtcblxuICAvLyBpZiBsYXllciBpcyB2ZWN0b3ItdGlsZSwgZ2V0IHRoZSBnZW9tZXRyaWVzIGZyb20gdGhlIGxheWVyXG4gIGlmIChkYXRhc2V0LnR5cGUgPT09ICd2ZWN0b3ItdGlsZScpIHtcbiAgICAvLyBmaW5kIHRoZSB2ZWN0b3ItdGlsZSBsYXllclxuICAgIGNvbnN0IHNlbGVjdGVkID0gbGF5ZXJzLmZpbHRlcihsYXllciA9PiBsYXllci5jb25maWcuZGF0YUlkID09PSBkYXRhc2V0LmlkKTtcbiAgICBjb25zdCBsYXllciA9IHNlbGVjdGVkLmZpbmQobGF5ZXIgPT4gbGF5ZXIudHlwZSA9PT0gTEFZRVJfVFlQRVMudmVjdG9yVGlsZSk7XG4gICAgaWYgKCFsYXllcikgcmV0dXJuIFtdO1xuXG4gICAgY29uc3QgZ2VvbWV0cmllczogRmVhdHVyZVtdID0gW107XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGZpeCB0aGlzIGxhdGVyIGluIHRoZSB2ZWN0b3ItdGlsZSBsYXllclxuICAgIGZvciAoY29uc3Qgcm93IG9mIGxheWVyLnRpbGVEYXRhc2V0LnRpbGVTZXQpIHtcbiAgICAgIGdlb21ldHJpZXMucHVzaChyb3cpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cmllcztcbiAgfVxuXG4gIC8vIGZvciBub24tdmVjdG9yLXRpbGUgZGF0YXNldCwgZ2V0IHRoZSBnZW9tZXRyaWVzIGZyb20gdGhlIHBvc3NpYmxlIGxheWVyXG4gIGNvbnN0IHNlbGVjdGVkTGF5ZXJzID0gbGF5ZXJzLmZpbHRlcihsYXllciA9PiBsYXllci5jb25maWcuZGF0YUlkID09PSBkYXRhc2V0LmlkKTtcbiAgaWYgKHNlbGVjdGVkTGF5ZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuXG4gIC8vIGZpbmQgZ2VvanNvbiBsYXllciwgdGhlbiBwb2ludCBsYXllciwgdGhlbiBvdGhlciBsYXllcnNcbiAgY29uc3QgZ2VvanNvbkxheWVyID0gc2VsZWN0ZWRMYXllcnMuZmluZChsYXllciA9PiBsYXllci50eXBlID09PSBMQVlFUl9UWVBFUy5nZW9qc29uKTtcbiAgY29uc3QgcG9pbnRMYXllciA9IHNlbGVjdGVkTGF5ZXJzLmZpbmQobGF5ZXIgPT4gbGF5ZXIudHlwZSA9PT0gTEFZRVJfVFlQRVMucG9pbnQpO1xuICBjb25zdCBvdGhlckxheWVycyA9IHNlbGVjdGVkTGF5ZXJzLmZpbHRlcihcbiAgICBsYXllciA9PiBsYXllci50eXBlICE9PSBMQVlFUl9UWVBFUy5nZW9qc29uICYmIGxheWVyLnR5cGUgIT09IExBWUVSX1RZUEVTLnBvaW50XG4gICk7XG5cbiAgY29uc3QgdmFsaWRMYXllciA9IGdlb2pzb25MYXllciB8fCBwb2ludExheWVyIHx8IG90aGVyTGF5ZXJzWzBdO1xuICBpZiAodmFsaWRMYXllcikge1xuICAgIGNvbnN0IGxheWVySW5kZXggPSBsYXllcnMuZmluZEluZGV4KGxheWVyID0+IGxheWVyLmlkID09PSB2YWxpZExheWVyLmlkKTtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gbGF5ZXJEYXRhW2xheWVySW5kZXhdO1xuICAgIHJldHVybiBnZW9tZXRyaWVzLmRhdGE7XG4gIH1cblxuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogU2F2ZSB0aGUgZGF0YSBhcyBhIG5ldyBkYXRhc2V0IGJ5IGpvaW5pbmcgaXQgd2l0aCB0aGUgbGVmdCBkYXRhc2V0XG4gKiBAcGFyYW0gZGF0YXNldHMgVGhlIGtlcGxlci5nbCBkYXRhc2V0c1xuICogQHBhcmFtIGRhdGFzZXROYW1lIFRoZSBuYW1lIG9mIHRoZSBsZWZ0IGRhdGFzZXRcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHNhdmVcbiAqIEBwYXJhbSBhZGREYXRhVG9NYXAgVGhlIGZ1bmN0aW9uIHRvIGFkZCB0aGUgZGF0YSB0byB0aGUgbWFwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYXZlQXNEYXRhc2V0KFxuICBkYXRhc2V0czogRGF0YXNldHMsXG4gIGxheWVyczogTGF5ZXJbXSxcbiAgZGF0YXNldE5hbWU6IHN0cmluZyxcbiAgbmV3RGF0YXNldE5hbWU6IHN0cmluZyxcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgbnVtYmVyW10+XG4pIHtcbiAgLy8gZmluZCBkYXRhc2V0SWQgZnJvbSBkYXRhc2V0c1xuICBjb25zdCBkYXRhc2V0SWQgPSBPYmplY3Qua2V5cyhkYXRhc2V0cykuZmluZChkYXRhSWQgPT4gZGF0YXNldHNbZGF0YUlkXS5sYWJlbCA9PT0gZGF0YXNldE5hbWUpO1xuICBpZiAoIWRhdGFzZXRJZCkgcmV0dXJuO1xuXG4gIC8vIGNoZWNrIGlmIG5ld0RhdGFzZXROYW1lIGFscmVhZHkgZXhpc3RzXG4gIGlmIChPYmplY3Qua2V5cyhkYXRhc2V0cykuaW5jbHVkZXMobmV3RGF0YXNldE5hbWUpKSByZXR1cm47XG5cbiAgLy8gU2F2ZSB0aGUgZGF0YSBhcyBhIG5ldyBkYXRhc2V0IGJ5IGpvaW5pbmcgaXQgd2l0aCB0aGUgbGVmdCBkYXRhc2V0XG4gIGNvbnN0IGxlZnREYXRhc2V0ID0gZGF0YXNldHNbZGF0YXNldElkXTtcbiAgbGV0IG51bVJvd3MgPSBsZWZ0RGF0YXNldC5sZW5ndGg7XG4gIGxldCBnZW9tZXRyaWVzOiBGZWF0dXJlW107XG5cbiAgaWYgKGxlZnREYXRhc2V0LnR5cGUgPT09ICd2ZWN0b3ItdGlsZScpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGdldCBnZW9tZXRyaWVzIGZyb20gdGhlIHZlY3Rvci10aWxlIGxheWVyXG4gICAgZ2VvbWV0cmllcyA9IGdldEZlYXR1cmVzRnJvbVZlY3RvclRpbGUobGVmdERhdGFzZXQsIGxheWVycykgfHwgW107XG4gICAgbnVtUm93cyA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICB9XG5cbiAgY29uc3QgZmllbGRzOiBQcm90b0RhdGFzZXRGaWVsZFtdID0gW1xuICAgIC8vIE5ldyBmaWVsZHMgZnJvbSBkYXRhXG4gICAgLi4uT2JqZWN0LmtleXMoZGF0YSkubWFwKChmaWVsZE5hbWUsIGluZGV4KSA9PiAoe1xuICAgICAgbmFtZTogZmllbGROYW1lLFxuICAgICAgaWQ6IGAke2ZpZWxkTmFtZX1fJHtpbmRleH1gLFxuICAgICAgZGlzcGxheU5hbWU6IGZpZWxkTmFtZSxcbiAgICAgIHR5cGU6IGRldGVybWluZUZpZWxkVHlwZShkYXRhW2ZpZWxkTmFtZV1bMF0pXG4gICAgfSkpLFxuICAgIC8vIEV4aXN0aW5nIGZpZWxkcyBmcm9tIGxlZnREYXRhc2V0XG4gICAgLi4ubGVmdERhdGFzZXQuZmllbGRzLm1hcCgoZmllbGQsIGluZGV4KSA9PiAoe1xuICAgICAgbmFtZTogZmllbGQubmFtZSxcbiAgICAgIGlkOiBmaWVsZC5pZCB8fCBgJHtmaWVsZC5uYW1lfV8ke2luZGV4fWAsXG4gICAgICBkaXNwbGF5TmFtZTogZmllbGQuZGlzcGxheU5hbWUsXG4gICAgICB0eXBlOiBmaWVsZC50eXBlXG4gICAgfSkpLFxuICAgIC8vIGFkZCBnZW9tZXRyeSBjb2x1bW4gZm9yIHZlY3Rvci10aWxlXG4gICAgLi4uKGxlZnREYXRhc2V0LnR5cGUgPT09ICd2ZWN0b3ItdGlsZSdcbiAgICAgID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdfZ2VvanNvbicsXG4gICAgICAgICAgICBpZDogJ19nZW9qc29uJyxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnX2dlb2pzb24nLFxuICAgICAgICAgICAgdHlwZTogJ2dlb2pzb24nXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICA6IFtdKVxuICBdO1xuXG4gIC8vIFByZS1jYWxjdWxhdGUgZGF0YSB2YWx1ZXMgYXJyYXlcbiAgY29uc3QgZGF0YVZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZGF0YSk7XG5cbiAgY29uc3Qgcm93cyA9IEFycmF5KG51bVJvd3MpXG4gICAgLmZpbGwobnVsbClcbiAgICAubWFwKChfLCByb3dJZHgpID0+IFtcbiAgICAgIC8vIE5ldyBkYXRhIHZhbHVlc1xuICAgICAgLi4uZGF0YVZhbHVlcy5tYXAoY29sID0+IGNvbFtyb3dJZHhdKSxcbiAgICAgIC8vIEV4aXN0aW5nIGRhdGFzZXQgdmFsdWVzXG4gICAgICAuLi5sZWZ0RGF0YXNldC5maWVsZHMubWFwKGZpZWxkID0+XG4gICAgICAgIGxlZnREYXRhc2V0LnR5cGUgPT09ICd2ZWN0b3ItdGlsZSdcbiAgICAgICAgICA/IGdlb21ldHJpZXNbcm93SWR4XS5wcm9wZXJ0aWVzPy5bZmllbGQubmFtZV1cbiAgICAgICAgICA6IGxlZnREYXRhc2V0LmdldFZhbHVlKGZpZWxkLm5hbWUsIHJvd0lkeClcbiAgICAgICksXG4gICAgICAvLyBnZW9tZXRyeSBjb2x1bW4gZm9yIHZlY3Rvci10aWxlXG4gICAgICAuLi4obGVmdERhdGFzZXQudHlwZSA9PT0gJ3ZlY3Rvci10aWxlJyA/IFtnZW9tZXRyaWVzW3Jvd0lkeF1dIDogW10pXG4gICAgXSk7XG5cbiAgLy8gY3JlYXRlIG5ldyBkYXRhc2V0XG4gIGNvbnN0IG5ld0RhdGFzZXQ6IFByb3RvRGF0YXNldCA9IHtcbiAgICBpbmZvOiB7XG4gICAgICBpZDogbmV3RGF0YXNldE5hbWUsXG4gICAgICBsYWJlbDogbmV3RGF0YXNldE5hbWVcbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIGZpZWxkcyxcbiAgICAgIHJvd3NcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIG5ld0RhdGFzZXQ7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBmaWVsZCB0eXBlXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGRldGVybWluZSB0aGUgZmllbGQgdHlwZVxuICogQHJldHVybnMgVGhlIGZpZWxkIHR5cGVcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lRmllbGRUeXBlKHZhbHVlOiB1bmtub3duKToga2V5b2YgdHlwZW9mIEFMTF9GSUVMRF9UWVBFUyB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG4gICAgPyBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKVxuICAgICAgPyBBTExfRklFTERfVFlQRVMuaW50ZWdlclxuICAgICAgOiBBTExfRklFTERfVFlQRVMucmVhbFxuICAgIDogQUxMX0ZJRUxEX1RZUEVTLnN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpZ2hsaWdodFJvd3NCeUNvbHVtblZhbHVlcyhcbiAgZGF0YXNldHM6IERhdGFzZXRzLFxuICBsYXllcnM6IExheWVyW10sXG4gIGRhdGFzZXROYW1lOiBzdHJpbmcsXG4gIGNvbHVtbk5hbWU6IHN0cmluZyxcbiAgc2VsZWN0ZWRWYWx1ZXM6IHVua25vd25bXSxcbiAgbGF5ZXJTZXRJc1ZhbGlkOiAobGF5ZXI6IExheWVyLCBpc1ZhbGlkOiBib29sZWFuKSA9PiB2b2lkXG4pIHtcbiAgY29uc3QgZGF0YXNldElkID0gT2JqZWN0LmtleXMoZGF0YXNldHMpLmZpbmQoZGF0YUlkID0+IGRhdGFzZXRzW2RhdGFJZF0ubGFiZWwgPT09IGRhdGFzZXROYW1lKTtcbiAgaWYgKCFkYXRhc2V0SWQpIHJldHVybjtcbiAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2RhdGFzZXRJZF07XG4gIGlmIChkYXRhc2V0KSB7XG4gICAgLy8gZ2V0IHRoZSB2YWx1ZXMgb2YgdGhlIGNvbHVtblxuICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmZyb20oe2xlbmd0aDogZGF0YXNldC5sZW5ndGh9LCAoXywgaSkgPT4gZGF0YXNldC5nZXRWYWx1ZShjb2x1bW5OYW1lLCBpKSk7XG4gICAgLy8gY3JlYXRlIGEgZGljdCB1c2luZyB0aGUgdmFsdWVzXG4gICAgY29uc3QgdmFsdWVEaWN0ID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGFjY1t2YWx1ZV0gPSBpbmRleDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIC8vIG5lZWQgdG8gZml4IHRoZSB0eXBlIGVycm9yIG9mIHZhbHVlIGhlcmVcbiAgICBjb25zdCBzZWxlY3RlZEluZGljZXMgPSBzZWxlY3RlZFZhbHVlcy5tYXAodmFsdWUgPT4gdmFsdWVEaWN0W3ZhbHVlIGFzIGFueV0pO1xuICAgIC8vIGhpZ2hsaWdodCB0aGUgcm93c1xuICAgIGhpZ2hsaWdodFJvd3MoZGF0YXNldHMsIGxheWVycywgZGF0YXNldE5hbWUsIHNlbGVjdGVkSW5kaWNlcywgbGF5ZXJTZXRJc1ZhbGlkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGZWF0dXJlc0Zyb21WZWN0b3JUaWxlKGxlZnREYXRhc2V0OiBLZXBsZXJUYWJsZSwgbGF5ZXJzOiBMYXllcltdKSB7XG4gIGNvbnN0IGxheWVySW5kZXggPSBsYXllcnMuZmluZEluZGV4KGxheWVyID0+IGxheWVyLmNvbmZpZy5kYXRhSWQgPT09IGxlZnREYXRhc2V0LmlkKTtcbiAgaWYgKGxheWVySW5kZXggPT09IC0xKSByZXR1cm47XG5cbiAgY29uc3QgbGF5ZXIgPSBsYXllcnNbbGF5ZXJJbmRleF07XG4gIGlmICghaXNWZWN0b3JUaWxlTGF5ZXIobGF5ZXIpKSByZXR1cm47XG5cbiAgY29uc3QgZmVhdHVyZXM6IEZlYXR1cmVbXSA9IFtdO1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gZml4IHRoaXMgbGF0ZXIgaW4gdGhlIHZlY3Rvci10aWxlIGxheWVyXG4gIGZvciAoY29uc3Qgcm93IG9mIGxheWVyLnRpbGVEYXRhc2V0LnRpbGVTZXQpIHtcbiAgICBmZWF0dXJlcy5wdXNoKHJvdyk7XG4gIH1cblxuICByZXR1cm4gZmVhdHVyZXM7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBLElBQUFBLGlCQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFLQSxJQUFBQyxVQUFBLEdBQUFELE9BQUE7QUFBa0UsU0FBQUUsMkJBQUFDLENBQUEsRUFBQUMsQ0FBQTtFQUFBLElBQUFDLENBQUEseUJBQUFDLE1BQUEsSUFBQUgsQ0FBQSxDQUFBRyxNQUFBLENBQUFDLFFBQUEsS0FBQUosQ0FBQTtFQUFBLEtBQUFFLENBQUE7SUFBQSxJQUFBRyxLQUFBLENBQUFDLE9BQUEsQ0FBQU4sQ0FBQSxNQUFBRSxDQUFBLEdBQUFLLDJCQUFBLENBQUFQLENBQUEsTUFBQUMsQ0FBQSxJQUFBRCxDQUFBLHVCQUFBQSxDQUFBLENBQUFRLE1BQUE7TUFBQU4sQ0FBQSxLQUFBRixDQUFBLEdBQUFFLENBQUE7TUFBQSxJQUFBTyxFQUFBO1FBQUFDLENBQUEsWUFBQUEsRUFBQTtNQUFBO1FBQUFDLENBQUEsRUFBQUQsQ0FBQTtRQUFBRSxDQUFBLFdBQUFBLEVBQUE7VUFBQSxPQUFBSCxFQUFBLElBQUFULENBQUEsQ0FBQVEsTUFBQTtZQUFBSyxJQUFBO1VBQUE7WUFBQUEsSUFBQTtZQUFBQyxLQUFBLEVBQUFkLENBQUEsQ0FBQVMsRUFBQTtVQUFBO1FBQUE7UUFBQVIsQ0FBQSxXQUFBQSxFQUFBRCxDQUFBO1VBQUEsTUFBQUEsQ0FBQTtRQUFBO1FBQUFlLENBQUEsRUFBQUw7TUFBQTtJQUFBO0lBQUEsVUFBQU0sU0FBQTtFQUFBO0VBQUEsSUFBQUMsQ0FBQTtJQUFBQyxDQUFBO0lBQUFDLENBQUE7RUFBQTtJQUFBUixDQUFBLFdBQUFBLEVBQUE7TUFBQVQsQ0FBQSxH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