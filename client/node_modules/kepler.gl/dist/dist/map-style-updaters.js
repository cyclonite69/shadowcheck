"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultMapStyles = exports.editCustomMapStyleUpdater = exports.addCustomMapStyleUpdater = exports.INITIAL_MAP_STYLE = void 0;
exports.getInitialInputStyle = getInitialInputStyle;
exports.getMapStyles = getMapStyles;
exports.setBackgroundColorUpdater = exports.set3dBuildingColorUpdater = exports.resetMapConfigMapStyleUpdater = exports.requestMapStylesUpdater = exports.removeCustomMapStyleUpdater = exports.receiveMapConfigUpdater = exports.mapStyleChangeUpdater = exports.mapConfigChangeUpdater = exports.loadMapStylesUpdater = exports.loadMapStyleErrUpdater = exports.loadCustomMapStyleUpdater = exports.inputMapStyleUpdater = exports.initMapStyleUpdater = void 0;
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _tasks = _interopRequireWildcard(require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/node_modules/react-palm/tasks"));
var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));
var _console = _interopRequireDefault(require("global/console"));
var _utils = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/utils/src");
var _commonUtils = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/common-utils/src");
var _constants = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/constants/src");
var _tasks2 = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/tasks/src");
var _d3Color = require("d3-color");
var _actions = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/actions/src");
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != _typeof(e) && "function" != typeof e) return {
    "default": e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n["default"] = e, t && t.set(e, n), n;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      (0, _defineProperty2["default"])(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
} // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
// Utils
var getDefaultMapStyles = exports.getDefaultMapStyles = function getDefaultMapStyles(cdnUrl) {
  return _constants.DEFAULT_MAP_STYLES.reduce(function (accu, curr) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, curr.id, _objectSpread(_objectSpread({}, curr), {}, {
      icon: "".concat(cdnUrl, "/").concat(curr.icon)
    })));
  }, {});
};
var getDefaultState = function getDefaultState() {
  var visibleLayerGroups = {};
  var topLayerGroups = {};
  return {
    styleType: _constants.DEFAULT_BASE_MAP_STYLE,
    visibleLayerGroups: visibleLayerGroups,
    topLayerGroups: topLayerGroups,
    mapStyles: getDefaultMapStyles((0, _utils.getApplicationConfig)().cdnUrl),
    // save mapbox access token
    mapboxApiAccessToken: null,
    mapboxApiUrl: _constants.DEFAULT_MAPBOX_API_URL,
    mapStylesReplaceDefault: false,
    inputStyle: getInitialInputStyle(),
    threeDBuildingColor: (0, _utils.hexToRgb)(_constants.DEFAULT_BLDG_COLOR),
    custom3DBuildingColor: false,
    backgroundColor: (0, _utils.hexToRgb)(_constants.DEFAULT_BACKGROUND_COLOR),
    isLoading: {},
    bottomMapStyle: undefined,
    topMapStyle: undefined
  };
};

/**
 * Updaters for `mapStyle`. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {mapStyleUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // click button to hide label from background map
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             mapStyle: mapStyleUpdaters.mapConfigChangeUpdater(
 *               mapStyle,
 *               {payload: {visibleLayerGroups: {label: false, road: true, background: true}}}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable @typescript-eslint/no-unused-vars */
// @ts-ignore
var mapStyleUpdaters = null;
/* eslint-enable @typescript-eslint/no-unused-vars */
/**
 * Default initial `mapStyle`
 * @memberof mapStyleUpdaters
 * @constant
 * @property styleType - Default: `'dark'`
 * @property visibleLayerGroups - Default: `{}`
 * @property topLayerGroups - Default: `{}`
 * @property mapStyles - mapping from style key to style object
 * @property mapboxApiAccessToken - Default: `null`
 * @Property mapboxApiUrl - Default null
 * @Property mapStylesReplaceDefault - Default: `false`
 * @property inputStyle - Default: `{}`
 * @property threeDBuildingColor - Default: `[r, g, b]`
 * @property backgroundColor - Default: `[r, g, b]`
 * @public
 */
var INITIAL_MAP_STYLE = exports.INITIAL_MAP_STYLE = getDefaultState();
/**
 * Create two map styles from preset map style, one for top map one for bottom
 *
 * @param {string} styleType - current map style
 * @param {Object} visibleLayerGroups - visible layers of bottom map
 * @param {Object} topLayerGroups - visible layers of top map
 * @param {Object} mapStyles - a dictionary of all map styles
 * @returns {Object} bottomMapStyle | topMapStyle | isRaster
 */
function getMapStyles(_ref) {
  var styleType = _ref.styleType,
    visibleLayerGroups = _ref.visibleLayerGroups,
    topLayerGroups = _ref.topLayerGroups,
    mapStyles = _ref.mapStyles;
  var mapStyle = mapStyles[styleType];

  // style might not be loaded yet
  if (!mapStyle || !mapStyle.style) {
    return {};
  }
  var editable = Object.keys(visibleLayerGroups).length;
  var bottomMapStyle = !editable ? mapStyle.style : (0, _utils.editBottomMapStyle)({
    id: styleType,
    mapStyle: mapStyle,
    visibleLayerGroups: visibleLayerGroups
  });
  var hasTopLayer = editable > 0 && Object.values(topLayerGroups).some(function (v) {
    return v;
  });

  // mute top layer if not visible in bottom layer
  var topLayers = hasTopLayer && Object.keys(topLayerGroups).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, topLayerGroups[key] && visibleLayerGroups[key]));
  }, {});
  var topMapStyle = hasTopLayer ? (0, _utils.editTopMapStyle)({
    id: styleType,
    mapStyle: mapStyle,
    visibleLayerGroups: topLayers
  }) : null;
  return {
    bottomMapStyle: bottomMapStyle,
    topMapStyle: topMapStyle,
    editable: editable
  };
}
function findLayerFillColor(layer) {
  return layer && layer.paint && layer.paint['background-color'];
}

// need to be careful because some basemap layer.paint['background-color'] values may be an interpolate array expression instead of a color string
// https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#paint-background-background-color
// https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/#interpolate
function getPaintColor(color) {
  if (Array.isArray(color) && color[0] === 'interpolate') {
    // get color of first zoom break
    // ["interpolate", ["linear"], ["zoom"], 11, "hsl(35, 32%, 91%)", 13, "hsl(35, 12%, 89%)"]
    return color[4];
  }
  return color;
}
function get3DBuildingColor(style) {
  // set building color to be the same as the background color.
  if (!style.style) {
    return (0, _utils.hexToRgb)(_constants.DEFAULT_BLDG_COLOR);
  }
  var backgroundLayer = (style.style.layers || []).find(function (_ref2) {
    var id = _ref2.id;
    return id === 'background';
  });
  var buildingLayer = (style.style.layers || []).find(function (_ref3) {
    var id = _ref3.id;
    return id.match(/building/);
  });
  var buildingColor = findLayerFillColor(buildingLayer) || findLayerFillColor(backgroundLayer) || _constants.DEFAULT_BLDG_COLOR;

  // brighten or darken building based on style
  var operation = style.id.match(/(?=(dark|night))/) ? 'brighter' : 'darker';
  var alpha = 0.2;
  var rgbObj = (0, _d3Color.rgb)(buildingColor)[operation]([alpha]);
  return [rgbObj.r, rgbObj.g, rgbObj.b];
}
function getBackgroundColorFromStyleBaseLayer(style, backupBackgroundColor) {
  var _colorMaybeToRGB;
  if (!style.style) {
    return (0, _utils.colorMaybeToRGB)(backupBackgroundColor) || backupBackgroundColor;
  }

  // @ts-expect-error style.style not typed
  var baseLayer = (style.style.layers || []).find(function (_ref4) {
    var id = _ref4.id;
    return _constants.BASE_MAP_BACKGROUND_LAYER_IDS.includes(id);
  });
  var backgroundColorOfBaseLayer = getPaintColor(findLayerFillColor(baseLayer));
  var newBackgroundColor = typeof backgroundColorOfBaseLayer === 'string' ? backgroundColorOfBaseLayer : backupBackgroundColor;
  var newBackgroundColorAsRGBArray = (_colorMaybeToRGB = (0, _utils.colorMaybeToRGB)(newBackgroundColor)
  // if newBackgroundColor was in string HSL format it can introduce RGB numbers with decimals,
  // which may render the background-color CSS of the <StyledMap> container incorrectly when using our own color utils `rgbToHex()`
  // so we attempt to round to nearest integer here
  ) === null || _colorMaybeToRGB === void 0 ? void 0 : _colorMaybeToRGB.map(function (channelNumber) {
    return Math.round(channelNumber);
  });
  return newBackgroundColorAsRGBArray || backupBackgroundColor;
}

// determine new backgroundColor from either previous state basemap style, previous state backgroundColor, or the DEFAULT_BACKGROUND_COLOR
function getBackgroundColor(previousState, styleType) {
  var previousStateMapStyle = previousState.mapStyles[previousState.styleType];
  var backupBackgroundColor = previousState.backgroundColor || _constants.DEFAULT_BACKGROUND_COLOR;
  var backgroundColor = styleType === _constants.NO_MAP_ID ?
  // if the style has switched to the "no basemap" style,
  // attempt to detect backgroundColor of the previous basemap if it was a mapbox basemap
  // and set it as the "no basemap" backgroundColor
  getBackgroundColorFromStyleBaseLayer(previousStateMapStyle, backupBackgroundColor) :
  // otherwise leave it alone and rely on the previous state's preexisting backgroundColor
  // or DEFAULT_BACKGROUND_COLOR as a last resort
  backupBackgroundColor;
  return backgroundColor;
}
function getLayerGroupsFromStyle(style) {
  return Array.isArray(style === null || style === void 0 ? void 0 : style.layers) ? _constants.DEFAULT_LAYER_GROUPS.filter(function (lg) {
    return style.layers.filter(lg.filter).length;
  }) : [];
}

// Updaters

/**
 * @memberof mapStyleUpdaters
 * @public
 */
var requestMapStylesUpdater = exports.requestMapStylesUpdater = function requestMapStylesUpdater(state, _ref5) {
  var _ref5$payload = _ref5.payload,
    mapStyles = _ref5$payload.mapStyles,
    onSuccess = _ref5$payload.onSuccess;
  var toLoad = Object.keys(mapStyles).reduce(function (accu, id) {
    return _objectSpread(_objectSpread({}, accu), !state.isLoading[id] ? (0, _defineProperty2["default"])({}, id, mapStyles[id]) : {});
  }, {});
  var loadMapStyleTasks = getLoadMapStyleTasks(toLoad, state.mapboxApiAccessToken, state.mapboxApiUrl, onSuccess);
  var isLoading = Object.keys(toLoad).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, true));
  }, {});
  var nextState = _objectSpread(_objectSpread({}, state), {}, {
    isLoading: isLoading
  });
  return (0, _tasks.withTask)(nextState, loadMapStyleTasks);
};

/**
 * Propagate `mapStyle` reducer with `mapboxApiAccessToken` and `mapStylesReplaceDefault`.
 * if mapStylesReplaceDefault is true mapStyles is emptied; loadMapStylesUpdater() will
 * populate mapStyles.
 *
 * @memberof mapStyleUpdaters
 * @public
 */
var initMapStyleUpdater = exports.initMapStyleUpdater = function initMapStyleUpdater(state, _ref7) {
  var _ref7$payload = _ref7.payload,
    payload = _ref7$payload === void 0 ? {} : _ref7$payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    // save mapbox access token to map style state
    mapboxApiAccessToken: payload.mapboxApiAccessToken || state.mapboxApiAccessToken,
    mapboxApiUrl: payload.mapboxApiUrl || state.mapboxApiUrl,
    mapStyles: !payload.mapStylesReplaceDefault ? state.mapStyles : {},
    mapStylesReplaceDefault: payload.mapStylesReplaceDefault || false
  });
};
// });

/**
 * Update `visibleLayerGroups`to change layer group visibility
 * @memberof mapStyleUpdaters
 * @public
 */
var mapConfigChangeUpdater = exports.mapConfigChangeUpdater = function mapConfigChangeUpdater(state, action) {
  return _objectSpread(_objectSpread(_objectSpread({}, state), action.payload), getMapStyles(_objectSpread(_objectSpread({}, state), action.payload)));
};
var hasStyleObject = function hasStyleObject(style) {
  return (0, _utils.isPlainObject)(style === null || style === void 0 ? void 0 : style.style);
};

/**
 * Change to another map style. The selected style should already been loaded into `mapStyle.mapStyles`
 * @memberof mapStyleUpdaters
 * @public
 */
var mapStyleChangeUpdater = exports.mapStyleChangeUpdater = function mapStyleChangeUpdater(state, _ref8) {
  var _state$mapStyles$styl, _state$mapStyles$styl2;
  var _ref8$payload = _ref8.payload,
    styleType = _ref8$payload.styleType,
    onSuccess = _ref8$payload.onSuccess;
  if (
  // we might not have received the style yet
  !state.mapStyles[styleType] ||
  // or if it is a managed custom style asset
  // and if it has not been hydrated with URL info yet (during app first initialization)
  // and it does not have a style object (during adding a custom style)
  ((_state$mapStyles$styl = state.mapStyles[styleType]) === null || _state$mapStyles$styl === void 0 ? void 0 : _state$mapStyles$styl.custom) === 'MANAGED' && !((_state$mapStyles$styl2 = state.mapStyles[styleType]) !== null && _state$mapStyles$styl2 !== void 0 && _state$mapStyles$styl2.url) && !hasStyleObject(state.mapStyles[styleType])) {
    return state;
  }
  if (!hasStyleObject(state.mapStyles[styleType])) {
    // style hasn't loaded yet
    return requestMapStylesUpdater(_objectSpread(_objectSpread({}, state), {}, {
      styleType: styleType
    }), {
      payload: {
        mapStyles: (0, _defineProperty2["default"])({}, styleType, state.mapStyles[styleType]),
        onSuccess: onSuccess
      }
    });
  }
  var defaultLGVisibility = (0, _utils.getDefaultLayerGroupVisibility)(state.mapStyles[styleType]);
  var visibleLayerGroups = (0, _utils.mergeLayerGroupVisibility)(defaultLGVisibility, state.visibleLayerGroups);
  var threeDBuildingColor = state.custom3DBuildingColor ? state.threeDBuildingColor : get3DBuildingColor(state.mapStyles[styleType]);

  // determine new backgroundColor from either previous state basemap style, previous state backgroundColor, or the DEFAULT_BACKGROUND_COLOR
  var backgroundColor = getBackgroundColor(state, styleType);
  return _objectSpread(_objectSpread({}, state), {}, {
    styleType: styleType,
    visibleLayerGroups: visibleLayerGroups,
    threeDBuildingColor: threeDBuildingColor,
    backgroundColor: backgroundColor
  }, getMapStyles(_objectSpread(_objectSpread({}, state), {}, {
    visibleLayerGroups: visibleLayerGroups,
    styleType: styleType
  })));
};

/**
 * Callback when load map style success
 * @memberof mapStyleUpdaters
 * @public
 */
var loadMapStylesUpdater = exports.loadMapStylesUpdater = function loadMapStylesUpdater(state, action) {
  var _ref9 = action.payload || {},
    newStyles = _ref9.newStyles,
    onSuccess = _ref9.onSuccess;
  var addLayerGroups = Object.keys(newStyles).reduce(function (accu, id) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, _objectSpread(_objectSpread({}, newStyles[id]), {}, {
      layerGroups: newStyles[id].layerGroups || getLayerGroupsFromStyle(newStyles[id].style)
    })));
  }, {});
  // reset isLoading
  var isLoading = Object.keys(state.isLoading).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), state.isLoading[key] && hasStyleObject(newStyles[key]) ? (0, _defineProperty2["default"])({}, key, false) : (0, _defineProperty2["default"])({}, key, state.isLoading[key]));
  }, {});
  // add new styles to state
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    isLoading: isLoading,
    mapStyles: _objectSpread(_objectSpread({}, state.mapStyles), addLayerGroups)
  });
  var tasks = createActionTask(onSuccess, {
    styleType: state.styleType
  });
  var nextState = newStyles[state.styleType] ? mapStyleChangeUpdater(newState, {
    payload: {
      styleType: state.styleType
    }
  }) : newState;
  return tasks ? (0, _tasks.withTask)(nextState, tasks) : nextState;
};
function createActionTask(action, payload) {
  if (typeof action === 'function') {
    return (0, _tasks2.ACTION_TASK)().map(function () {
      return action(payload);
    });
  }
  return null;
}

/**
 * Callback when load map style error
 * @memberof mapStyleUpdaters
 * @public
 */
// do nothing for now, if didn't load, skip it
var loadMapStyleErrUpdater = exports.loadMapStyleErrUpdater = function loadMapStyleErrUpdater(state, _ref12) {
  var _ref12$payload = _ref12.payload,
    ids = _ref12$payload.ids,
    error = _ref12$payload.error;
  _console["default"].error(error);
  // reset isLoading
  var isLoading = Object.keys(state.isLoading).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), state.isLoading[key] && (ids || []).includes(key) ? (0, _defineProperty2["default"])({}, key, false) : (0, _defineProperty2["default"])({}, key, state.isLoading[key]));
  }, {});
  return _objectSpread(_objectSpread({}, state), {}, {
    isLoading: isLoading
  });
};

/**
 * Load map style object when pass in saved map config
 * @memberof mapStyleUpdaters
 * @param state `mapStyle`
 * @param action
 * @param action.payload saved map config `{mapStyle, visState, mapState}`
 * @returns nextState or `react-pam` tasks to load map style object
 */
var receiveMapConfigUpdater = exports.receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref15) {
  var config = _ref15.payload.config;
  var _ref16 = config || {},
    mapStyle = _ref16.mapStyle;
  if (!mapStyle) {
    return state;
  }

  // merge default mapStyles
  var merged = mapStyle.mapStyles ? _objectSpread(_objectSpread({}, mapStyle), {}, {
    mapStyles: _objectSpread(_objectSpread({}, mapStyle.mapStyles), state.mapStyles)
  }) : mapStyle;

  // set custom3DBuildingColor: true if mapStyle contains threeDBuildingColor
  // @ts-expect-error
  merged.custom3DBuildingColor =
  // @ts-expect-error
  Boolean(mapStyle.threeDBuildingColor) || merged.custom3DBuildingColor;
  var newState = mapConfigChangeUpdater(state, {
    payload: merged
  });
  return mapStyleChangeUpdater(newState, {
    payload: {
      styleType: newState.styleType
    }
  });
};
function getLoadMapStyleTasks(mapStyles, mapboxApiAccessToken, mapboxApiUrl, onSuccess) {
  return [_tasks["default"].all(Object.values(mapStyles)
  // @ts-expect-error
  .map(function (_ref17) {
    var id = _ref17.id,
      url = _ref17.url,
      accessToken = _ref17.accessToken;
    return {
      id: id,
      url: (0, _utils.getStyleDownloadUrl)(url, accessToken || mapboxApiAccessToken, mapboxApiUrl)
    };
  }).map(_tasks2.LOAD_MAP_STYLE_TASK)).bimap(
  // success
  function (results) {
    return (0, _actions.loadMapStyles)(results.reduce(function (accu, _ref18) {
      var id = _ref18.id,
        style = _ref18.style;
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, _objectSpread(_objectSpread({}, mapStyles[id]), {}, {
        style: style
      })));
    }, {}), onSuccess);
  },
  // error
  function (err) {
    return (0, _actions.loadMapStyleErr)(Object.keys(mapStyles), err);
  })];
}
/**
 * Reset map style config to initial state
 * @memberof mapStyleUpdaters
 * @param state `mapStyle`
 * @returns nextState
 * @public
 */
var resetMapConfigMapStyleUpdater = exports.resetMapConfigMapStyleUpdater = function resetMapConfigMapStyleUpdater(state) {
  var emptyConfig = _objectSpread(_objectSpread(_objectSpread({}, INITIAL_MAP_STYLE), {}, {
    mapboxApiAccessToken: state.mapboxApiAccessToken,
    mapboxApiUrl: state.mapboxApiUrl,
    mapStylesReplaceDefault: state.mapStylesReplaceDefault
  }, state.initialState), {}, {
    mapStyles: state.mapStyles,
    initialState: state.initialState
  });
  return mapStyleChangeUpdater(emptyConfig, {
    payload: {
      styleType: emptyConfig.styleType
    }
  });
};

/**
 * Callback when a custom map style object is received
 * @memberof mapStyleUpdaters
 * @public
 */
var loadCustomMapStyleUpdater = exports.loadCustomMapStyleUpdater = function loadCustomMapStyleUpdater(state, _ref19) {
  var _ref19$payload = _ref19.payload,
    icon = _ref19$payload.icon,
    style = _ref19$payload.style,
    error = _ref19$payload.error;
  return _objectSpread(_objectSpread({}, state), {}, {
    // @ts-expect-error
    inputStyle: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, state.inputStyle), style ? {
      id: state.inputStyle.custom === 'MANAGED' ? state.inputStyle.id // custom MANAGED type
      :
      // @ts-expect-error
      style.id || (0, _commonUtils.generateHashId)(),
      // custom LOCAL type
      // make a copy of the style object
      style: (0, _cloneDeep["default"])(style),
      // @ts-expect-error
      label: state.inputStyle.label || style.name,
      // gathering layer group info from style json
      layerGroups: getLayerGroupsFromStyle(style)
    } : {}), icon ? {
      icon: icon
    } : {}), error !== undefined ? {
      error: error
    } : {})
  });
};

/**
 * Input a custom map style object
 * @memberof mapStyleUpdaters
 * @public
 */
var inputMapStyleUpdater = exports.inputMapStyleUpdater = function inputMapStyleUpdater(state, _ref20) {
  var _updated$icon, _updated$url, _updated$url2;
  var _ref20$payload = _ref20.payload,
    inputStyle = _ref20$payload.inputStyle,
    mapState = _ref20$payload.mapState;
  var updated = _objectSpread(_objectSpread({}, state.inputStyle), inputStyle);

  // differentiate between either a url to hosted style json that needs an icon url,
  // or an icon already available client-side as a data uri
  var isUpdatedIconDataUri = (_updated$icon = updated.icon) === null || _updated$icon === void 0 ? void 0 : _updated$icon.startsWith('data:image');
  var isMapboxStyleUrl = ((_updated$url = updated.url) === null || _updated$url === void 0 ? void 0 : _updated$url.startsWith('mapbox://')) || ((_updated$url2 = updated.url) === null || _updated$url2 === void 0 ? void 0 : _updated$url2.includes('mapbox.com'));
  var icon = !isUpdatedIconDataUri && isMapboxStyleUrl ?
  // Get image icon urls only for mapbox map lib.
  (0, _utils.getStyleImageIcon)({
    mapState: mapState,
    styleUrl: updated.url || '',
    mapboxApiAccessToken: updated.accessToken || state.mapboxApiAccessToken || '',
    mapboxApiUrl: state.mapboxApiUrl || _constants.DEFAULT_MAPBOX_API_URL
  }) : updated.icon;
  return _objectSpread(_objectSpread({}, state), {}, {
    inputStyle: _objectSpread(_objectSpread({}, updated), {}, {
      isValid: true,
      icon: icon
    })
  });
};

/**
 * Add map style from user input to reducer and set it to current style
 * This action is called when user click confirm after putting in a valid style url in the custom map style dialog.
 * It should not be called from outside kepler.gl without a valid `inputStyle` in the `mapStyle` reducer.
 * @memberof mapStyleUpdaters
 */
var addCustomMapStyleUpdater = exports.addCustomMapStyleUpdater = function addCustomMapStyleUpdater(state) {
  var styleId = state.inputStyle.id;
  if (!styleId) return state;
  var newState = getNewStateWithCustomMapStyle(state);
  // set new style
  return mapStyleChangeUpdater(newState, {
    payload: {
      styleType: styleId
    }
  });
};

/**
 * Edit map style from user input to reducer.
 * This action is called when user clicks confirm after editing an existing custom style in the custom map style dialog.
 * It should not be called from outside kepler.gl without a valid `inputStyle` in the `mapStyle` reducer.
 * @memberof mapStyleUpdaters
 */
var editCustomMapStyleUpdater = exports.editCustomMapStyleUpdater = function editCustomMapStyleUpdater(state) {
  return getNewStateWithCustomMapStyle(state);
};
function getNewStateWithCustomMapStyle(state) {
  var styleId = state.inputStyle.id;
  if (!styleId) return state;
  return _objectSpread(_objectSpread({}, state), {}, {
    // @ts-expect-error Property 'layerGroups' is missing in type 'InputStyle' but required in type 'BaseMapStyle'. Legacy case?
    mapStyles: _objectSpread(_objectSpread({}, state.mapStyles), {}, (0, _defineProperty2["default"])({}, styleId, _objectSpread(_objectSpread({}, state.mapStyles[styleId]), state.inputStyle))),
    // set to default
    inputStyle: getInitialInputStyle()
  });
}

/**
 * Remove a custom map style from `state.mapStyle.mapStyles`.
 * @memberof mapStyleUpdaters
 */
var removeCustomMapStyleUpdater = exports.removeCustomMapStyleUpdater = function removeCustomMapStyleUpdater(state, action) {
  var id = action.payload.id;

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  var _state$mapStyles = state.mapStyles,
    _ = _state$mapStyles[id],
    restOfMapStyles = (0, _objectWithoutProperties2["default"])(_state$mapStyles, [id].map(_toPropertyKey));
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    mapStyles: restOfMapStyles
  });
  if (state.styleType === id) {
    // if removing a custom style that is also the current active base map,
    // then reset to the default active base map (`mapStyle.styleType`)
    return mapStyleChangeUpdater(newState, {
      payload: {
        styleType: getDefaultState().styleType
      }
    });
  }
  return newState;
};

/**
 * Updates 3d building color
 * @memberof mapStyleUpdaters
 */
var set3dBuildingColorUpdater = exports.set3dBuildingColorUpdater = function set3dBuildingColorUpdater(state, _ref21) {
  var color = _ref21.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    threeDBuildingColor: color,
    custom3DBuildingColor: true
  });
};

/**
 * Updates background color
 * @memberof mapStyleUpdaters
 */
var setBackgroundColorUpdater = exports.setBackgroundColorUpdater = function setBackgroundColorUpdater(state, _ref22) {
  var color = _ref22.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    backgroundColor: color
  });
};

/**
 * Return the initial input style
 * @return Object
 */
function getInitialInputStyle() {
  return {
    id: null,
    accessToken: null,
    error: false,
    isValid: false,
    label: null,
    style: null,
    url: null,
    icon: null,
    custom: 'LOCAL',
    uploadedFile: null
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfdGFza3MiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfY2xvbmVEZWVwIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9jb25zb2xlIiwiX3V0aWxzIiwiX2NvbW1vblV0aWxzIiwiX2NvbnN0YW50cyIsIl90YXNrczIiLCJfZDNDb2xvciIsIl9hY3Rpb25zIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwiX3RvUHJvcGVydHlLZXkiLCJfdG9QcmltaXRpdmUiLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eTIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImdldERlZmF1bHRNYXBTdHlsZXMiLCJleHBvcnRzIiwiY2RuVXJsIiwiREVGQVVMVF9NQVBfU1RZTEVTIiwicmVkdWNlIiwiYWNjdSIsImN1cnIiLCJpZCIsImljb24iLCJjb25jYXQiLCJnZXREZWZhdWx0U3RhdGUiLCJ2aXNpYmxlTGF5ZXJHcm91cHMiLCJ0b3BMYXllckdyb3VwcyIsInN0eWxlVHlwZSIsIkRFRkFVTFRfQkFTRV9NQVBfU1RZTEUiLCJtYXBTdHlsZXMiLCJnZXRBcHBsaWNhdGlvbkNvbmZpZyIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwibWFwYm94QXBpVXJsIiwiREVGQVVMVF9NQVBCT1hfQVBJX1VSTCIsIm1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0IiwiaW5wdXRTdHlsZSIsImdldEluaXRpYWxJbnB1dFN0eWxlIiwidGhyZWVEQnVpbGRpbmdDb2xvciIsImhleFRvUmdiIiwiREVGQVVMVF9CTERHX0NPTE9SIiwiY3VzdG9tM0RCdWlsZGluZ0NvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9SIiwiaXNMb2FkaW5nIiwiYm90dG9tTWFwU3R5bGUiLCJ1bmRlZmluZWQiLCJ0b3BNYXBTdHlsZSIsIm1hcFN0eWxlVXBkYXRlcnMiLCJJTklUSUFMX01BUF9TVFlMRSIsImdldE1hcFN0eWxlcyIsIl9yZWYiLCJtYXBTdHlsZSIsInN0eWxlIiwiZWRpdGFibGUiLCJlZGl0Qm90dG9tTWFwU3R5bGUiLCJoYXNUb3BMYXllciIsInZhbHVlcyIsInNvbWUiLCJ2IiwidG9wTGF5ZXJzIiwia2V5IiwiZWRpdFRvcE1hcFN0eWxlIiwiZmluZExheWVyRmlsbENvbG9yIiwibGF5ZXIiLCJwYWludCIsImdldFBhaW50Q29sb3IiLCJjb2xvciIsIkFycmF5IiwiaXNBcnJheSIsImdldDNEQnVpbGRpbmdDb2xvciIsImJhY2tncm91bmRMYXllciIsImxheWVycyIsImZpbmQiLCJfcmVmMiIsImJ1aWxkaW5nTGF5ZXIiLCJfcmVmMyIsIm1hdGNoIiwiYnVpbGRpbmdDb2xvciIsIm9wZXJhdGlvbiIsImFscGhhIiwicmdiT2JqIiwicmdiIiwiZyIsImIiLCJnZXRCYWNrZ3JvdW5kQ29sb3JGcm9tU3R5bGVCYXNlTGF5ZXIiLCJiYWNrdXBCYWNrZ3JvdW5kQ29sb3IiLCJfY29sb3JNYXliZVRvUkdCIiwiY29sb3JNYXliZVRvUkdCIiwiYmFzZUxheWVyIiwiX3JlZjQiLCJCQVNFX01BUF9CQUNLR1JPVU5EX0xBWUVSX0lEUyIsImluY2x1ZGVzIiwiYmFja2dyb3VuZENvbG9yT2ZCYXNlTGF5ZXIiLCJuZXdCYWNrZ3JvdW5kQ29sb3IiLCJuZXdCYWNrZ3JvdW5kQ29sb3JBc1JHQkFycmF5IiwibWFwIiwiY2hhbm5lbE51bWJlciIsIk1hdGgiLCJyb3VuZCIsImdldEJhY2tncm91bmRDb2xvciIsInByZXZpb3VzU3RhdGUiLCJwcmV2aW91c1N0YXRlTWFwU3R5bGUiLCJOT19NQVBfSUQiLCJnZXRMYXllckdyb3Vwc0Zyb21TdHlsZSIsIkRFRkFVTFRfTEFZRVJfR1JPVVBTIiwibGciLCJyZXF1ZXN0TWFwU3R5bGVzVXBkYXRlciIsInN0YXRlIiwiX3JlZjUiLCJfcmVmNSRwYXlsb2FkIiwicGF5bG9hZCIsIm9uU3VjY2VzcyIsInRvTG9hZCIsImxvYWRNYXBTdHlsZVRhc2tzIiwiZ2V0TG9hZE1hcFN0eWxlVGFza3MiLCJuZXh0U3RhdGUiLCJ3aXRoVGFzayIsImluaXRNYXBTdHlsZVVwZGF0ZXIiLCJfcmVmNyIsIl9yZWY3JHBheWxvYWQiLCJtYXBDb25maWdDaGFuZ2VVcGRhdGVyIiwiYWN0aW9uIiwiaGFzU3R5bGVPYmplY3QiLCJpc1BsYWluT2JqZWN0IiwibWFwU3R5bGVDaGFuZ2VVcGRhdGVyIiwiX3JlZjgiLCJfc3RhdGUkbWFwU3R5bGVzJHN0eWwiLCJfc3RhdGUkbWFwU3R5bGVzJHN0eWwyIiwiX3JlZjgkcGF5bG9hZCIsImN1c3RvbSIsInVybCIsImRlZmF1bHRMR1Zpc2liaWxpdHkiLCJnZXREZWZhdWx0TGF5ZXJHcm91cFZpc2liaWxpdHkiLCJtZXJnZUxheWVyR3JvdXBWaXNpYmlsaXR5IiwibG9hZE1hcFN0eWxlc1VwZGF0ZXIiLCJfcmVmOSIsIm5ld1N0eWxlcyIsImFkZExheWVyR3JvdXBzIiwibGF5ZXJHcm91cHMiLCJuZXdTdGF0ZSIsInRhc2tzIiwiY3JlYXRlQWN0aW9uVGFzayIsIkFDVElPTl9UQVNLIiwibG9hZE1hcFN0eWxlRXJyVXBkYXRlciIsIl9yZWYxMiIsIl9yZWYxMiRwYXlsb2FkIiwiaWRzIiwiZXJyb3IiLCJyZWNlaXZlTWFwQ29uZmlnVXBkYXRlciIsIl9yZWYxNSIsImNvbmZpZyIsIl9yZWYxNiIsIm1lcmdlZCIsIkJvb2xlYW4iLCJhbGwiLCJfcmVmMTciLCJhY2Nlc3NUb2tlbiIsImdldFN0eWxlRG93bmxvYWRVcmwiLCJMT0FEX01BUF9TVFlMRV9UQVNLIiwiYmltYXAiLCJyZXN1bHRzIiwibG9hZE1hcFN0eWxlcyIsIl9yZWYxOCIsImVyciIsImxvYWRNYXBTdHlsZUVyciIsInJlc2V0TWFwQ29uZmlnTWFwU3R5bGVVcGRhdGVyIiwiZW1wdHlDb25maWciLCJpbml0aWFsU3RhdGUiLCJsb2FkQ3VzdG9tTWFwU3R5bGVVcGRhdGVyIiwiX3JlZjE5IiwiX3JlZjE5JHBheWxvYWQiLCJnZW5lcmF0ZUhhc2hJZCIsImxhYmVsIiwibmFtZSIsImlucHV0TWFwU3R5bGVVcGRhdGVyIiwiX3JlZjIwIiwiX3VwZGF0ZWQkaWNvbiIsIl91cGRhdGVkJHVybCIsIl91cGRhdGVkJHVybDIiLCJfcmVmMjAkcGF5bG9hZCIsIm1hcFN0YXRlIiwidXBkYXRlZCIsImlzVXBkYXRlZEljb25EYXRhVXJpIiwic3RhcnRzV2l0aCIsImlzTWFwYm94U3R5bGVVcmwiLCJnZXRTdHlsZUltYWdlSWNvbiIsInN0eWxlVXJsIiwiaXNWYWxpZCIsImFkZEN1c3RvbU1hcFN0eWxlVXBkYXRlciIsInN0eWxlSWQiLCJnZXROZXdTdGF0ZVdpdGhDdXN0b21NYXBTdHlsZSIsImVkaXRDdXN0b21NYXBTdHlsZVVwZGF0ZXIiLCJyZW1vdmVDdXN0b21NYXBTdHlsZVVwZGF0ZXIiLCJfc3RhdGUkbWFwU3R5bGVzIiwiXyIsInJlc3RPZk1hcFN0eWxlcyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllczIiLCJzZXQzZEJ1aWxkaW5nQ29sb3JVcGRhdGVyIiwiX3JlZjIxIiwic2V0QmFja2dyb3VuZENvbG9yVXBkYXRlciIsIl9yZWYyMiIsInVwbG9hZGVkRmlsZSJdLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXAtc3R5bGUtdXBkYXRlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IFRhc2ssIHt3aXRoVGFza30gZnJvbSAncmVhY3QtcGFsbS90YXNrcyc7XG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC9jbG9uZURlZXAnO1xuaW1wb3J0IENvbnNvbGUgZnJvbSAnZ2xvYmFsL2NvbnNvbGUnO1xuXG4vLyBVdGlsc1xuaW1wb3J0IHtcbiAgZ2V0RGVmYXVsdExheWVyR3JvdXBWaXNpYmlsaXR5LFxuICBnZXRTdHlsZURvd25sb2FkVXJsLFxuICBtZXJnZUxheWVyR3JvdXBWaXNpYmlsaXR5LFxuICBlZGl0VG9wTWFwU3R5bGUsXG4gIGVkaXRCb3R0b21NYXBTdHlsZSxcbiAgZ2V0U3R5bGVJbWFnZUljb24sXG4gIGlzUGxhaW5PYmplY3QsXG4gIGhleFRvUmdiLFxuICBjb2xvck1heWJlVG9SR0IsXG4gIGdldEFwcGxpY2F0aW9uQ29uZmlnXG59IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtnZW5lcmF0ZUhhc2hJZH0gZnJvbSAnQGtlcGxlci5nbC9jb21tb24tdXRpbHMnO1xuaW1wb3J0IHtcbiAgREVGQVVMVF9NQVBfU1RZTEVTLFxuICBERUZBVUxUX0xBWUVSX0dST1VQUyxcbiAgREVGQVVMVF9NQVBCT1hfQVBJX1VSTCxcbiAgTk9fTUFQX0lELFxuICBERUZBVUxUX0JMREdfQ09MT1IsXG4gIERFRkFVTFRfQkFDS0dST1VORF9DT0xPUixcbiAgQkFTRV9NQVBfQkFDS0dST1VORF9MQVlFUl9JRFMsXG4gIERFRkFVTFRfQkFTRV9NQVBfU1RZTEVcbn0gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtBQ1RJT05fVEFTSywgTE9BRF9NQVBfU1RZTEVfVEFTS30gZnJvbSAnQGtlcGxlci5nbC90YXNrcyc7XG5pbXBvcnQge3JnYn0gZnJvbSAnZDMtY29sb3InO1xuXG5pbXBvcnQge1xuICBSR0JDb2xvcixcbiAgTGF5ZXJHcm91cCxcbiAgQmFzZU1hcFN0eWxlLFxuICBNYXBTdHlsZXMsXG4gIElucHV0U3R5bGUsXG4gIFZpc2libGVMYXllckdyb3Vwc1xufSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7XG4gIEFjdGlvblR5cGVzLFxuICBSZWNlaXZlTWFwQ29uZmlnUGF5bG9hZCxcbiAgS2VwbGVyR2xJbml0UGF5bG9hZCxcbiAgTWFwU3R5bGVBY3Rpb25zLFxuICBsb2FkTWFwU3R5bGVzLFxuICBsb2FkTWFwU3R5bGVFcnJcbn0gZnJvbSAnQGtlcGxlci5nbC9hY3Rpb25zJztcblxuZXhwb3J0IHR5cGUgTWFwYm94U3R5bGVVcmwgPSBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIE1hcFN0eWxlID0ge1xuICBzdHlsZVR5cGU6IHN0cmluZztcbiAgdmlzaWJsZUxheWVyR3JvdXBzOiBWaXNpYmxlTGF5ZXJHcm91cHM7XG4gIHRvcExheWVyR3JvdXBzOiBWaXNpYmxlTGF5ZXJHcm91cHM7XG4gIG1hcFN0eWxlczogTWFwU3R5bGVzO1xuICAvLyBzYXZlIG1hcGJveCBhY2Nlc3MgdG9rZW5cbiAgbWFwYm94QXBpQWNjZXNzVG9rZW46IHN0cmluZyB8IG51bGw7XG4gIG1hcGJveEFwaVVybDogc3RyaW5nO1xuICBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdDogYm9vbGVhbjtcbiAgaW5wdXRTdHlsZTogSW5wdXRTdHlsZTtcbiAgdGhyZWVEQnVpbGRpbmdDb2xvcjogUkdCQ29sb3I7XG4gIGJhY2tncm91bmRDb2xvcjogUkdCQ29sb3I7XG4gIGN1c3RvbTNEQnVpbGRpbmdDb2xvcjogYm9vbGVhbjtcbiAgYm90dG9tTWFwU3R5bGU6IGFueTtcbiAgdG9wTWFwU3R5bGU6IGFueTtcbiAgaW5pdGlhbFN0YXRlPzogTWFwU3R5bGU7XG4gIGlzTG9hZGluZzoge1xuICAgIFtrZXk6IHN0cmluZ106IGJvb2xlYW47XG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdE1hcFN0eWxlcyA9IChjZG5Vcmw6IHN0cmluZykgPT4ge1xuICByZXR1cm4gREVGQVVMVF9NQVBfU1RZTEVTLnJlZHVjZShcbiAgICAoYWNjdSwgY3VycikgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICBbY3Vyci5pZF06IHtcbiAgICAgICAgLi4uY3VycixcbiAgICAgICAgaWNvbjogYCR7Y2RuVXJsfS8ke2N1cnIuaWNvbn1gXG4gICAgICB9XG4gICAgfSksXG4gICAge31cbiAgKTtcbn07XG5cbmNvbnN0IGdldERlZmF1bHRTdGF0ZSA9ICgpOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IHZpc2libGVMYXllckdyb3VwcyA9IHt9O1xuICBjb25zdCB0b3BMYXllckdyb3VwcyA9IHt9O1xuXG4gIHJldHVybiB7XG4gICAgc3R5bGVUeXBlOiBERUZBVUxUX0JBU0VfTUFQX1NUWUxFLFxuICAgIHZpc2libGVMYXllckdyb3VwcyxcbiAgICB0b3BMYXllckdyb3VwcyxcbiAgICBtYXBTdHlsZXM6IGdldERlZmF1bHRNYXBTdHlsZXMoZ2V0QXBwbGljYXRpb25Db25maWcoKS5jZG5VcmwpLFxuICAgIC8vIHNhdmUgbWFwYm94IGFjY2VzcyB0b2tlblxuICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBudWxsLFxuICAgIG1hcGJveEFwaVVybDogREVGQVVMVF9NQVBCT1hfQVBJX1VSTCxcbiAgICBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdDogZmFsc2UsXG4gICAgaW5wdXRTdHlsZTogZ2V0SW5pdGlhbElucHV0U3R5bGUoKSxcbiAgICB0aHJlZURCdWlsZGluZ0NvbG9yOiBoZXhUb1JnYihERUZBVUxUX0JMREdfQ09MT1IpLFxuICAgIGN1c3RvbTNEQnVpbGRpbmdDb2xvcjogZmFsc2UsXG4gICAgYmFja2dyb3VuZENvbG9yOiBoZXhUb1JnYihERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1IpLFxuICAgIGlzTG9hZGluZzoge30sXG4gICAgYm90dG9tTWFwU3R5bGU6IHVuZGVmaW5lZCxcbiAgICB0b3BNYXBTdHlsZTogdW5kZWZpbmVkXG4gIH07XG59O1xuXG4vKipcbiAqIFVwZGF0ZXJzIGZvciBgbWFwU3R5bGVgLiBDYW4gYmUgdXNlZCBpbiB5b3VyIHJvb3QgcmVkdWNlciB0byBkaXJlY3RseSBtb2RpZnkga2VwbGVyLmdsJ3Mgc3RhdGUuXG4gKiBSZWFkIG1vcmUgYWJvdXQgW1VzaW5nIHVwZGF0ZXJzXSguLi9hZHZhbmNlZC11c2FnZS91c2luZy11cGRhdGVycy5tZClcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IGtlcGxlckdsUmVkdWNlciwge21hcFN0eWxlVXBkYXRlcnN9IGZyb20gJ2tlcGxlci5nbC9yZWR1Y2Vycyc7XG4gKiAvLyBSb290IFJlZHVjZXJcbiAqIGNvbnN0IHJlZHVjZXJzID0gY29tYmluZVJlZHVjZXJzKHtcbiAqICBrZXBsZXJHbDoga2VwbGVyR2xSZWR1Y2VyLFxuICogIGFwcDogYXBwUmVkdWNlclxuICogfSk7XG4gKlxuICogY29uc3QgY29tcG9zZWRSZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAqICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gKiAgICAvLyBjbGljayBidXR0b24gdG8gaGlkZSBsYWJlbCBmcm9tIGJhY2tncm91bmQgbWFwXG4gKiAgICBjYXNlICdDTElDS19CVVRUT04nOlxuICogICAgICByZXR1cm4ge1xuICogICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgIGtlcGxlckdsOiB7XG4gKiAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbCxcbiAqICAgICAgICAgIGZvbzoge1xuICogICAgICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wuZm9vLFxuICogICAgICAgICAgICAgbWFwU3R5bGU6IG1hcFN0eWxlVXBkYXRlcnMubWFwQ29uZmlnQ2hhbmdlVXBkYXRlcihcbiAqICAgICAgICAgICAgICAgbWFwU3R5bGUsXG4gKiAgICAgICAgICAgICAgIHtwYXlsb2FkOiB7dmlzaWJsZUxheWVyR3JvdXBzOiB7bGFiZWw6IGZhbHNlLCByb2FkOiB0cnVlLCBiYWNrZ3JvdW5kOiB0cnVlfX19XG4gKiAgICAgICAgICAgICApXG4gKiAgICAgICAgICB9XG4gKiAgICAgICAgfVxuICogICAgICB9O1xuICogIH1cbiAqICByZXR1cm4gcmVkdWNlcnMoc3RhdGUsIGFjdGlvbik7XG4gKiB9O1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGNvbXBvc2VkUmVkdWNlcjtcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG1hcFN0eWxlVXBkYXRlcnMgPSBudWxsO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogRGVmYXVsdCBpbml0aWFsIGBtYXBTdHlsZWBcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAY29uc3RhbnRcbiAqIEBwcm9wZXJ0eSBzdHlsZVR5cGUgLSBEZWZhdWx0OiBgJ2RhcmsnYFxuICogQHByb3BlcnR5IHZpc2libGVMYXllckdyb3VwcyAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSB0b3BMYXllckdyb3VwcyAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSBtYXBTdHlsZXMgLSBtYXBwaW5nIGZyb20gc3R5bGUga2V5IHRvIHN0eWxlIG9iamVjdFxuICogQHByb3BlcnR5IG1hcGJveEFwaUFjY2Vzc1Rva2VuIC0gRGVmYXVsdDogYG51bGxgXG4gKiBAUHJvcGVydHkgbWFwYm94QXBpVXJsIC0gRGVmYXVsdCBudWxsXG4gKiBAUHJvcGVydHkgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQgLSBEZWZhdWx0OiBgZmFsc2VgXG4gKiBAcHJvcGVydHkgaW5wdXRTdHlsZSAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSB0aHJlZURCdWlsZGluZ0NvbG9yIC0gRGVmYXVsdDogYFtyLCBnLCBiXWBcbiAqIEBwcm9wZXJ0eSBiYWNrZ3JvdW5kQ29sb3IgLSBEZWZhdWx0OiBgW3IsIGcsIGJdYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgSU5JVElBTF9NQVBfU1RZTEU6IE1hcFN0eWxlID0gZ2V0RGVmYXVsdFN0YXRlKCk7XG5cbmludGVyZmFjZSBHZXRNYXBTdHlsZXNQYXJhbSB7XG4gIHN0eWxlVHlwZTogc3RyaW5nO1xuICB2aXNpYmxlTGF5ZXJHcm91cHM6IHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufTtcbiAgdG9wTGF5ZXJHcm91cHM6IHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufTtcbiAgbWFwU3R5bGVzOiB7W2lkOiBzdHJpbmddOiBhbnl9O1xufVxuXG4vKipcbiAqIENyZWF0ZSB0d28gbWFwIHN0eWxlcyBmcm9tIHByZXNldCBtYXAgc3R5bGUsIG9uZSBmb3IgdG9wIG1hcCBvbmUgZm9yIGJvdHRvbVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVR5cGUgLSBjdXJyZW50IG1hcCBzdHlsZVxuICogQHBhcmFtIHtPYmplY3R9IHZpc2libGVMYXllckdyb3VwcyAtIHZpc2libGUgbGF5ZXJzIG9mIGJvdHRvbSBtYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b3BMYXllckdyb3VwcyAtIHZpc2libGUgbGF5ZXJzIG9mIHRvcCBtYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXBTdHlsZXMgLSBhIGRpY3Rpb25hcnkgb2YgYWxsIG1hcCBzdHlsZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGJvdHRvbU1hcFN0eWxlIHwgdG9wTWFwU3R5bGUgfCBpc1Jhc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwU3R5bGVzKHtcbiAgc3R5bGVUeXBlLFxuICB2aXNpYmxlTGF5ZXJHcm91cHMsXG4gIHRvcExheWVyR3JvdXBzLFxuICBtYXBTdHlsZXNcbn06IEdldE1hcFN0eWxlc1BhcmFtKSB7XG4gIGNvbnN0IG1hcFN0eWxlID0gbWFwU3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgLy8gc3R5bGUgbWlnaHQgbm90IGJlIGxvYWRlZCB5ZXRcbiAgaWYgKCFtYXBTdHlsZSB8fCAhbWFwU3R5bGUuc3R5bGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCBlZGl0YWJsZSA9IE9iamVjdC5rZXlzKHZpc2libGVMYXllckdyb3VwcykubGVuZ3RoO1xuXG4gIGNvbnN0IGJvdHRvbU1hcFN0eWxlID0gIWVkaXRhYmxlXG4gICAgPyBtYXBTdHlsZS5zdHlsZVxuICAgIDogZWRpdEJvdHRvbU1hcFN0eWxlKHtcbiAgICAgICAgaWQ6IHN0eWxlVHlwZSxcbiAgICAgICAgbWFwU3R5bGUsXG4gICAgICAgIHZpc2libGVMYXllckdyb3Vwc1xuICAgICAgfSk7XG5cbiAgY29uc3QgaGFzVG9wTGF5ZXIgPSBlZGl0YWJsZSA+IDAgJiYgT2JqZWN0LnZhbHVlcyh0b3BMYXllckdyb3Vwcykuc29tZSh2ID0+IHYpO1xuXG4gIC8vIG11dGUgdG9wIGxheWVyIGlmIG5vdCB2aXNpYmxlIGluIGJvdHRvbSBsYXllclxuICBjb25zdCB0b3BMYXllcnMgPVxuICAgIGhhc1RvcExheWVyICYmXG4gICAgT2JqZWN0LmtleXModG9wTGF5ZXJHcm91cHMpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiB0b3BMYXllckdyb3Vwc1trZXldICYmIHZpc2libGVMYXllckdyb3Vwc1trZXldXG4gICAgICB9KSxcbiAgICAgIHt9IGFzIHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufVxuICAgICk7XG5cbiAgY29uc3QgdG9wTWFwU3R5bGUgPSBoYXNUb3BMYXllclxuICAgID8gZWRpdFRvcE1hcFN0eWxlKHtcbiAgICAgICAgaWQ6IHN0eWxlVHlwZSxcbiAgICAgICAgbWFwU3R5bGUsXG4gICAgICAgIHZpc2libGVMYXllckdyb3VwczogdG9wTGF5ZXJzXG4gICAgICB9KVxuICAgIDogbnVsbDtcblxuICByZXR1cm4ge2JvdHRvbU1hcFN0eWxlLCB0b3BNYXBTdHlsZSwgZWRpdGFibGV9O1xufVxuXG5mdW5jdGlvbiBmaW5kTGF5ZXJGaWxsQ29sb3IobGF5ZXIpIHtcbiAgcmV0dXJuIGxheWVyICYmIGxheWVyLnBhaW50ICYmIGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLWNvbG9yJ107XG59XG5cbi8vIG5lZWQgdG8gYmUgY2FyZWZ1bCBiZWNhdXNlIHNvbWUgYmFzZW1hcCBsYXllci5wYWludFsnYmFja2dyb3VuZC1jb2xvciddIHZhbHVlcyBtYXkgYmUgYW4gaW50ZXJwb2xhdGUgYXJyYXkgZXhwcmVzc2lvbiBpbnN0ZWFkIG9mIGEgY29sb3Igc3RyaW5nXG4vLyBodHRwczovL2RvY3MubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvc3R5bGUtc3BlYy9sYXllcnMvI3BhaW50LWJhY2tncm91bmQtYmFja2dyb3VuZC1jb2xvclxuLy8gaHR0cHM6Ly9kb2NzLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3N0eWxlLXNwZWMvZXhwcmVzc2lvbnMvI2ludGVycG9sYXRlXG5mdW5jdGlvbiBnZXRQYWludENvbG9yKGNvbG9yKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSAmJiBjb2xvclswXSA9PT0gJ2ludGVycG9sYXRlJykge1xuICAgIC8vIGdldCBjb2xvciBvZiBmaXJzdCB6b29tIGJyZWFrXG4gICAgLy8gW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJ6b29tXCJdLCAxMSwgXCJoc2woMzUsIDMyJSwgOTElKVwiLCAxMywgXCJoc2woMzUsIDEyJSwgODklKVwiXVxuICAgIHJldHVybiBjb2xvcls0XTtcbiAgfVxuICByZXR1cm4gY29sb3I7XG59XG5cbmZ1bmN0aW9uIGdldDNEQnVpbGRpbmdDb2xvcihzdHlsZSk6IFJHQkNvbG9yIHtcbiAgLy8gc2V0IGJ1aWxkaW5nIGNvbG9yIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICBpZiAoIXN0eWxlLnN0eWxlKSB7XG4gICAgcmV0dXJuIGhleFRvUmdiKERFRkFVTFRfQkxER19DT0xPUik7XG4gIH1cblxuICBjb25zdCBiYWNrZ3JvdW5kTGF5ZXIgPSAoc3R5bGUuc3R5bGUubGF5ZXJzIHx8IFtdKS5maW5kKCh7aWR9KSA9PiBpZCA9PT0gJ2JhY2tncm91bmQnKTtcblxuICBjb25zdCBidWlsZGluZ0xheWVyID0gKHN0eWxlLnN0eWxlLmxheWVycyB8fCBbXSkuZmluZCgoe2lkfSkgPT4gaWQubWF0Y2goL2J1aWxkaW5nLykpO1xuXG4gIGNvbnN0IGJ1aWxkaW5nQ29sb3IgPVxuICAgIGZpbmRMYXllckZpbGxDb2xvcihidWlsZGluZ0xheWVyKSB8fCBmaW5kTGF5ZXJGaWxsQ29sb3IoYmFja2dyb3VuZExheWVyKSB8fCBERUZBVUxUX0JMREdfQ09MT1I7XG5cbiAgLy8gYnJpZ2h0ZW4gb3IgZGFya2VuIGJ1aWxkaW5nIGJhc2VkIG9uIHN0eWxlXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHN0eWxlLmlkLm1hdGNoKC8oPz0oZGFya3xuaWdodCkpLykgPyAnYnJpZ2h0ZXInIDogJ2Rhcmtlcic7XG5cbiAgY29uc3QgYWxwaGEgPSAwLjI7XG4gIGNvbnN0IHJnYk9iaiA9IHJnYihidWlsZGluZ0NvbG9yKVtvcGVyYXRpb25dKFthbHBoYV0pO1xuICByZXR1cm4gW3JnYk9iai5yLCByZ2JPYmouZywgcmdiT2JqLmJdO1xufVxuXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kQ29sb3JGcm9tU3R5bGVCYXNlTGF5ZXIoXG4gIHN0eWxlOiBCYXNlTWFwU3R5bGUsXG4gIGJhY2t1cEJhY2tncm91bmRDb2xvcjogUkdCQ29sb3Jcbik6IFJHQkNvbG9yIHtcbiAgaWYgKCFzdHlsZS5zdHlsZSkge1xuICAgIHJldHVybiBjb2xvck1heWJlVG9SR0IoYmFja3VwQmFja2dyb3VuZENvbG9yKSB8fCBiYWNrdXBCYWNrZ3JvdW5kQ29sb3I7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yIHN0eWxlLnN0eWxlIG5vdCB0eXBlZFxuICBjb25zdCBiYXNlTGF5ZXIgPSAoc3R5bGUuc3R5bGUubGF5ZXJzIHx8IFtdKS5maW5kKCh7aWR9KSA9PlxuICAgIEJBU0VfTUFQX0JBQ0tHUk9VTkRfTEFZRVJfSURTLmluY2x1ZGVzKGlkKVxuICApO1xuXG4gIGNvbnN0IGJhY2tncm91bmRDb2xvck9mQmFzZUxheWVyID0gZ2V0UGFpbnRDb2xvcihmaW5kTGF5ZXJGaWxsQ29sb3IoYmFzZUxheWVyKSk7XG5cbiAgY29uc3QgbmV3QmFja2dyb3VuZENvbG9yID1cbiAgICB0eXBlb2YgYmFja2dyb3VuZENvbG9yT2ZCYXNlTGF5ZXIgPT09ICdzdHJpbmcnXG4gICAgICA/IGJhY2tncm91bmRDb2xvck9mQmFzZUxheWVyXG4gICAgICA6IGJhY2t1cEJhY2tncm91bmRDb2xvcjtcblxuICBjb25zdCBuZXdCYWNrZ3JvdW5kQ29sb3JBc1JHQkFycmF5ID0gY29sb3JNYXliZVRvUkdCKG5ld0JhY2tncm91bmRDb2xvcilcbiAgICAvLyBpZiBuZXdCYWNrZ3JvdW5kQ29sb3Igd2FzIGluIHN0cmluZyBIU0wgZm9ybWF0IGl0IGNhbiBpbnRyb2R1Y2UgUkdCIG51bWJlcnMgd2l0aCBkZWNpbWFscyxcbiAgICAvLyB3aGljaCBtYXkgcmVuZGVyIHRoZSBiYWNrZ3JvdW5kLWNvbG9yIENTUyBvZiB0aGUgPFN0eWxlZE1hcD4gY29udGFpbmVyIGluY29ycmVjdGx5IHdoZW4gdXNpbmcgb3VyIG93biBjb2xvciB1dGlscyBgcmdiVG9IZXgoKWBcbiAgICAvLyBzbyB3ZSBhdHRlbXB0IHRvIHJvdW5kIHRvIG5lYXJlc3QgaW50ZWdlciBoZXJlXG4gICAgPy5tYXAoY2hhbm5lbE51bWJlciA9PiBNYXRoLnJvdW5kKGNoYW5uZWxOdW1iZXIpKSBhcyBSR0JDb2xvciB8IG51bGw7XG5cbiAgcmV0dXJuIG5ld0JhY2tncm91bmRDb2xvckFzUkdCQXJyYXkgfHwgYmFja3VwQmFja2dyb3VuZENvbG9yO1xufVxuXG4vLyBkZXRlcm1pbmUgbmV3IGJhY2tncm91bmRDb2xvciBmcm9tIGVpdGhlciBwcmV2aW91cyBzdGF0ZSBiYXNlbWFwIHN0eWxlLCBwcmV2aW91cyBzdGF0ZSBiYWNrZ3JvdW5kQ29sb3IsIG9yIHRoZSBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1JcbmZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcihwcmV2aW91c1N0YXRlOiBNYXBTdHlsZSwgc3R5bGVUeXBlOiBzdHJpbmcpIHtcbiAgY29uc3QgcHJldmlvdXNTdGF0ZU1hcFN0eWxlID0gcHJldmlvdXNTdGF0ZS5tYXBTdHlsZXNbcHJldmlvdXNTdGF0ZS5zdHlsZVR5cGVdO1xuICBjb25zdCBiYWNrdXBCYWNrZ3JvdW5kQ29sb3IgPSBwcmV2aW91c1N0YXRlLmJhY2tncm91bmRDb2xvciB8fCBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1I7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9XG4gICAgc3R5bGVUeXBlID09PSBOT19NQVBfSURcbiAgICAgID8gLy8gaWYgdGhlIHN0eWxlIGhhcyBzd2l0Y2hlZCB0byB0aGUgXCJubyBiYXNlbWFwXCIgc3R5bGUsXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gZGV0ZWN0IGJhY2tncm91bmRDb2xvciBvZiB0aGUgcHJldmlvdXMgYmFzZW1hcCBpZiBpdCB3YXMgYSBtYXBib3ggYmFzZW1hcFxuICAgICAgICAvLyBhbmQgc2V0IGl0IGFzIHRoZSBcIm5vIGJhc2VtYXBcIiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgZ2V0QmFja2dyb3VuZENvbG9yRnJvbVN0eWxlQmFzZUxheWVyKHByZXZpb3VzU3RhdGVNYXBTdHlsZSwgYmFja3VwQmFja2dyb3VuZENvbG9yKVxuICAgICAgOiAvLyBvdGhlcndpc2UgbGVhdmUgaXQgYWxvbmUgYW5kIHJlbHkgb24gdGhlIHByZXZpb3VzIHN0YXRlJ3MgcHJlZXhpc3RpbmcgYmFja2dyb3VuZENvbG9yXG4gICAgICAgIC8vIG9yIERFRkFVTFRfQkFDS0dST1VORF9DT0xPUiBhcyBhIGxhc3QgcmVzb3J0XG4gICAgICAgIGJhY2t1cEJhY2tncm91bmRDb2xvcjtcblxuICByZXR1cm4gYmFja2dyb3VuZENvbG9yO1xufVxuXG5mdW5jdGlvbiBnZXRMYXllckdyb3Vwc0Zyb21TdHlsZShzdHlsZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdHlsZT8ubGF5ZXJzKVxuICAgID8gREVGQVVMVF9MQVlFUl9HUk9VUFMuZmlsdGVyKGxnID0+IHN0eWxlLmxheWVycy5maWx0ZXIobGcuZmlsdGVyKS5sZW5ndGgpXG4gICAgOiBbXTtcbn1cblxuLy8gVXBkYXRlcnNcblxuLyoqXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVxdWVzdE1hcFN0eWxlc1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHttYXBTdHlsZXMsIG9uU3VjY2Vzc319OiBNYXBTdHlsZUFjdGlvbnMuUmVxdWVzdE1hcFN0eWxlc1VwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+IHtcbiAgY29uc3QgdG9Mb2FkID0gT2JqZWN0LmtleXMobWFwU3R5bGVzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGlkKSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIC4uLighc3RhdGUuaXNMb2FkaW5nW2lkXSA/IHtbaWRdOiBtYXBTdHlsZXNbaWRdfSA6IHt9KVxuICAgIH0pLFxuICAgIHt9XG4gICk7XG4gIGNvbnN0IGxvYWRNYXBTdHlsZVRhc2tzID0gZ2V0TG9hZE1hcFN0eWxlVGFza3MoXG4gICAgdG9Mb2FkLFxuICAgIHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgIHN0YXRlLm1hcGJveEFwaVVybCxcbiAgICBvblN1Y2Nlc3NcbiAgKTtcblxuICBjb25zdCBpc0xvYWRpbmcgPSBPYmplY3Qua2V5cyh0b0xvYWQpLnJlZHVjZShcbiAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIFtrZXldOiB0cnVlXG4gICAgfSksXG4gICAge31cbiAgKTtcbiAgY29uc3QgbmV4dFN0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGlzTG9hZGluZ1xuICB9O1xuICByZXR1cm4gd2l0aFRhc2sobmV4dFN0YXRlLCBsb2FkTWFwU3R5bGVUYXNrcyk7XG59O1xuXG4vKipcbiAqIFByb3BhZ2F0ZSBgbWFwU3R5bGVgIHJlZHVjZXIgd2l0aCBgbWFwYm94QXBpQWNjZXNzVG9rZW5gIGFuZCBgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHRgLlxuICogaWYgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQgaXMgdHJ1ZSBtYXBTdHlsZXMgaXMgZW1wdGllZDsgbG9hZE1hcFN0eWxlc1VwZGF0ZXIoKSB3aWxsXG4gKiBwb3B1bGF0ZSBtYXBTdHlsZXMuXG4gKlxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRNYXBTdHlsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge1xuICAgIHBheWxvYWQgPSB7fVxuICB9OiB7XG4gICAgdHlwZT86IHR5cGVvZiBBY3Rpb25UeXBlcy5JTklUO1xuICAgIHBheWxvYWQ6IEtlcGxlckdsSW5pdFBheWxvYWQ7XG4gIH1cbik6IE1hcFN0eWxlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAvLyBzYXZlIG1hcGJveCBhY2Nlc3MgdG9rZW4gdG8gbWFwIHN0eWxlIHN0YXRlXG4gIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBwYXlsb2FkLm1hcGJveEFwaUFjY2Vzc1Rva2VuIHx8IHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICBtYXBib3hBcGlVcmw6IHBheWxvYWQubWFwYm94QXBpVXJsIHx8IHN0YXRlLm1hcGJveEFwaVVybCxcbiAgbWFwU3R5bGVzOiAhcGF5bG9hZC5tYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCA/IHN0YXRlLm1hcFN0eWxlcyA6IHt9LFxuICBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdDogcGF5bG9hZC5tYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCB8fCBmYWxzZVxufSk7XG4vLyB9KTtcblxuLyoqXG4gKiBVcGRhdGUgYHZpc2libGVMYXllckdyb3Vwc2B0byBjaGFuZ2UgbGF5ZXIgZ3JvdXAgdmlzaWJpbGl0eVxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcENvbmZpZ0NoYW5nZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAgYWN0aW9uOiBNYXBTdHlsZUFjdGlvbnMuTWFwQ29uZmlnQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogTWFwU3R5bGUgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIC4uLmFjdGlvbi5wYXlsb2FkLFxuICAgIC4uLmdldE1hcFN0eWxlcyh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLmFjdGlvbi5wYXlsb2FkXG4gICAgfSlcbiAgfTtcbn07XG5cbmNvbnN0IGhhc1N0eWxlT2JqZWN0ID0gc3R5bGUgPT4gaXNQbGFpbk9iamVjdChzdHlsZT8uc3R5bGUpO1xuXG4vKipcbiAqIENoYW5nZSB0byBhbm90aGVyIG1hcCBzdHlsZS4gVGhlIHNlbGVjdGVkIHN0eWxlIHNob3VsZCBhbHJlYWR5IGJlZW4gbG9hZGVkIGludG8gYG1hcFN0eWxlLm1hcFN0eWxlc2BcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHtzdHlsZVR5cGUsIG9uU3VjY2Vzc319OiBNYXBTdHlsZUFjdGlvbnMuTWFwU3R5bGVDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIGlmIChcbiAgICAvLyB3ZSBtaWdodCBub3QgaGF2ZSByZWNlaXZlZCB0aGUgc3R5bGUgeWV0XG4gICAgIXN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdIHx8XG4gICAgLy8gb3IgaWYgaXQgaXMgYSBtYW5hZ2VkIGN1c3RvbSBzdHlsZSBhc3NldFxuICAgIC8vIGFuZCBpZiBpdCBoYXMgbm90IGJlZW4gaHlkcmF0ZWQgd2l0aCBVUkwgaW5mbyB5ZXQgKGR1cmluZyBhcHAgZmlyc3QgaW5pdGlhbGl6YXRpb24pXG4gICAgLy8gYW5kIGl0IGRvZXMgbm90IGhhdmUgYSBzdHlsZSBvYmplY3QgKGR1cmluZyBhZGRpbmcgYSBjdXN0b20gc3R5bGUpXG4gICAgKHN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdPy5jdXN0b20gPT09ICdNQU5BR0VEJyAmJlxuICAgICAgIXN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdPy51cmwgJiZcbiAgICAgICFoYXNTdHlsZU9iamVjdChzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXSkpXG4gICkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGlmICghaGFzU3R5bGVPYmplY3Qoc3RhdGUubWFwU3R5bGVzW3N0eWxlVHlwZV0pKSB7XG4gICAgLy8gc3R5bGUgaGFzbid0IGxvYWRlZCB5ZXRcbiAgICByZXR1cm4gcmVxdWVzdE1hcFN0eWxlc1VwZGF0ZXIoXG4gICAgICB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBzdHlsZVR5cGVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBtYXBTdHlsZXM6IHtcbiAgICAgICAgICAgIFtzdHlsZVR5cGVdOiBzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25TdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgY29uc3QgZGVmYXVsdExHVmlzaWJpbGl0eSA9IGdldERlZmF1bHRMYXllckdyb3VwVmlzaWJpbGl0eShzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXSk7XG5cbiAgY29uc3QgdmlzaWJsZUxheWVyR3JvdXBzID0gbWVyZ2VMYXllckdyb3VwVmlzaWJpbGl0eShcbiAgICBkZWZhdWx0TEdWaXNpYmlsaXR5LFxuICAgIHN0YXRlLnZpc2libGVMYXllckdyb3Vwc1xuICApO1xuXG4gIGNvbnN0IHRocmVlREJ1aWxkaW5nQ29sb3I6IFJHQkNvbG9yID0gc3RhdGUuY3VzdG9tM0RCdWlsZGluZ0NvbG9yXG4gICAgPyBzdGF0ZS50aHJlZURCdWlsZGluZ0NvbG9yXG4gICAgOiBnZXQzREJ1aWxkaW5nQ29sb3Ioc3RhdGUubWFwU3R5bGVzW3N0eWxlVHlwZV0pO1xuXG4gIC8vIGRldGVybWluZSBuZXcgYmFja2dyb3VuZENvbG9yIGZyb20gZWl0aGVyIHByZXZpb3VzIHN0YXRlIGJhc2VtYXAgc3R5bGUsIHByZXZpb3VzIHN0YXRlIGJhY2tncm91bmRDb2xvciwgb3IgdGhlIERFRkFVTFRfQkFDS0dST1VORF9DT0xPUlxuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3Ioc3RhdGUsIHN0eWxlVHlwZSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBzdHlsZVR5cGUsXG4gICAgdmlzaWJsZUxheWVyR3JvdXBzLFxuICAgIHRocmVlREJ1aWxkaW5nQ29sb3IsXG4gICAgYmFja2dyb3VuZENvbG9yLFxuICAgIC4uLmdldE1hcFN0eWxlcyh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHZpc2libGVMYXllckdyb3VwcyxcbiAgICAgIHN0eWxlVHlwZVxuICAgIH0pXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHdoZW4gbG9hZCBtYXAgc3R5bGUgc3VjY2Vzc1xuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRNYXBTdHlsZXNVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIGFjdGlvbjogTWFwU3R5bGVBY3Rpb25zLkxvYWRNYXBTdHlsZXNVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IHtuZXdTdHlsZXMsIG9uU3VjY2Vzc30gPSBhY3Rpb24ucGF5bG9hZCB8fCB7fTtcblxuICBjb25zdCBhZGRMYXllckdyb3VwcyA9IE9iamVjdC5rZXlzKG5ld1N0eWxlcykucmVkdWNlKFxuICAgIChhY2N1LCBpZCkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICBbaWRdOiB7XG4gICAgICAgIC4uLm5ld1N0eWxlc1tpZF0sXG4gICAgICAgIGxheWVyR3JvdXBzOiBuZXdTdHlsZXNbaWRdLmxheWVyR3JvdXBzIHx8IGdldExheWVyR3JvdXBzRnJvbVN0eWxlKG5ld1N0eWxlc1tpZF0uc3R5bGUpXG4gICAgICB9XG4gICAgfSksXG4gICAge31cbiAgKTtcbiAgLy8gcmVzZXQgaXNMb2FkaW5nXG4gIGNvbnN0IGlzTG9hZGluZyA9IE9iamVjdC5rZXlzKHN0YXRlLmlzTG9hZGluZykucmVkdWNlKFxuICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgLi4uKHN0YXRlLmlzTG9hZGluZ1trZXldICYmIGhhc1N0eWxlT2JqZWN0KG5ld1N0eWxlc1trZXldKVxuICAgICAgICA/IHtba2V5XTogZmFsc2V9XG4gICAgICAgIDoge1trZXldOiBzdGF0ZS5pc0xvYWRpbmdba2V5XX0pXG4gICAgfSksXG4gICAge31cbiAgKTtcbiAgLy8gYWRkIG5ldyBzdHlsZXMgdG8gc3RhdGVcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgaXNMb2FkaW5nLFxuICAgIG1hcFN0eWxlczoge1xuICAgICAgLi4uc3RhdGUubWFwU3R5bGVzLFxuICAgICAgLi4uYWRkTGF5ZXJHcm91cHNcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdGFza3MgPSBjcmVhdGVBY3Rpb25UYXNrKG9uU3VjY2Vzcywge3N0eWxlVHlwZTogc3RhdGUuc3R5bGVUeXBlfSk7XG5cbiAgY29uc3QgbmV4dFN0YXRlID0gbmV3U3R5bGVzW3N0YXRlLnN0eWxlVHlwZV1cbiAgICA/IG1hcFN0eWxlQ2hhbmdlVXBkYXRlcihuZXdTdGF0ZSwge3BheWxvYWQ6IHtzdHlsZVR5cGU6IHN0YXRlLnN0eWxlVHlwZX19KVxuICAgIDogbmV3U3RhdGU7XG5cbiAgcmV0dXJuIHRhc2tzID8gd2l0aFRhc2sobmV4dFN0YXRlLCB0YXNrcykgOiBuZXh0U3RhdGU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25UYXNrKGFjdGlvbiwgcGF5bG9hZCkge1xuICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBQ1RJT05fVEFTSygpLm1hcCgoKSA9PiBhY3Rpb24ocGF5bG9hZCkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgd2hlbiBsb2FkIG1hcCBzdHlsZSBlcnJvclxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuLy8gZG8gbm90aGluZyBmb3Igbm93LCBpZiBkaWRuJ3QgbG9hZCwgc2tpcCBpdFxuZXhwb3J0IGNvbnN0IGxvYWRNYXBTdHlsZUVyclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHtpZHMsIGVycm9yfX06IE1hcFN0eWxlQWN0aW9ucy5Mb2FkTWFwU3R5bGVFcnJVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIENvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAvLyByZXNldCBpc0xvYWRpbmdcbiAgY29uc3QgaXNMb2FkaW5nID0gT2JqZWN0LmtleXMoc3RhdGUuaXNMb2FkaW5nKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGtleSkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICAuLi4oc3RhdGUuaXNMb2FkaW5nW2tleV0gJiYgKGlkcyB8fCBbXSkuaW5jbHVkZXMoa2V5KVxuICAgICAgICA/IHtba2V5XTogZmFsc2V9XG4gICAgICAgIDoge1trZXldOiBzdGF0ZS5pc0xvYWRpbmdba2V5XX0pXG4gICAgfSksXG4gICAge31cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGlzTG9hZGluZ1xuICB9O1xufTtcblxuLyoqXG4gKiBMb2FkIG1hcCBzdHlsZSBvYmplY3Qgd2hlbiBwYXNzIGluIHNhdmVkIG1hcCBjb25maWdcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGUgYG1hcFN0eWxlYFxuICogQHBhcmFtIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkIHNhdmVkIG1hcCBjb25maWcgYHttYXBTdHlsZSwgdmlzU3RhdGUsIG1hcFN0YXRlfWBcbiAqIEByZXR1cm5zIG5leHRTdGF0ZSBvciBgcmVhY3QtcGFtYCB0YXNrcyB0byBsb2FkIG1hcCBzdHlsZSBvYmplY3RcbiAqL1xuZXhwb3J0IGNvbnN0IHJlY2VpdmVNYXBDb25maWdVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIHtcbiAgICBwYXlsb2FkOiB7Y29uZmlnfVxuICB9OiB7XG4gICAgdHlwZT86IHR5cGVvZiBBY3Rpb25UeXBlcy5SRUNFSVZFX01BUF9DT05GSUc7XG4gICAgcGF5bG9hZDogUmVjZWl2ZU1hcENvbmZpZ1BheWxvYWQ7XG4gIH1cbik6IE1hcFN0eWxlID0+IHtcbiAgY29uc3Qge21hcFN0eWxlfSA9IGNvbmZpZyB8fCB7fTtcblxuICBpZiAoIW1hcFN0eWxlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLy8gbWVyZ2UgZGVmYXVsdCBtYXBTdHlsZXNcbiAgY29uc3QgbWVyZ2VkID0gbWFwU3R5bGUubWFwU3R5bGVzXG4gICAgPyB7XG4gICAgICAgIC4uLm1hcFN0eWxlLFxuICAgICAgICBtYXBTdHlsZXM6IHtcbiAgICAgICAgICAuLi5tYXBTdHlsZS5tYXBTdHlsZXMsXG4gICAgICAgICAgLi4uc3RhdGUubWFwU3R5bGVzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICA6IG1hcFN0eWxlO1xuXG4gIC8vIHNldCBjdXN0b20zREJ1aWxkaW5nQ29sb3I6IHRydWUgaWYgbWFwU3R5bGUgY29udGFpbnMgdGhyZWVEQnVpbGRpbmdDb2xvclxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIG1lcmdlZC5jdXN0b20zREJ1aWxkaW5nQ29sb3IgPVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBCb29sZWFuKG1hcFN0eWxlLnRocmVlREJ1aWxkaW5nQ29sb3IpIHx8IG1lcmdlZC5jdXN0b20zREJ1aWxkaW5nQ29sb3I7XG4gIGNvbnN0IG5ld1N0YXRlID0gbWFwQ29uZmlnQ2hhbmdlVXBkYXRlcihzdGF0ZSwge3BheWxvYWQ6IG1lcmdlZH0pO1xuXG4gIHJldHVybiBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIobmV3U3RhdGUsIHtwYXlsb2FkOiB7c3R5bGVUeXBlOiBuZXdTdGF0ZS5zdHlsZVR5cGV9fSk7XG59O1xuXG5mdW5jdGlvbiBnZXRMb2FkTWFwU3R5bGVUYXNrcyhtYXBTdHlsZXMsIG1hcGJveEFwaUFjY2Vzc1Rva2VuLCBtYXBib3hBcGlVcmwsIG9uU3VjY2Vzcykge1xuICByZXR1cm4gW1xuICAgIFRhc2suYWxsKFxuICAgICAgT2JqZWN0LnZhbHVlcyhtYXBTdHlsZXMpXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgLm1hcCgoe2lkLCB1cmwsIGFjY2Vzc1Rva2VufSkgPT4gKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB1cmw6IGdldFN0eWxlRG93bmxvYWRVcmwodXJsLCBhY2Nlc3NUb2tlbiB8fCBtYXBib3hBcGlBY2Nlc3NUb2tlbiwgbWFwYm94QXBpVXJsKVxuICAgICAgICB9KSlcbiAgICAgICAgLm1hcChMT0FEX01BUF9TVFlMRV9UQVNLKVxuICAgICkuYmltYXAoXG4gICAgICAvLyBzdWNjZXNzXG4gICAgICByZXN1bHRzID0+XG4gICAgICAgIGxvYWRNYXBTdHlsZXMoXG4gICAgICAgICAgcmVzdWx0cy5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjdSwge2lkLCBzdHlsZX0pID0+ICh7XG4gICAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICAgIFtpZF06IHtcbiAgICAgICAgICAgICAgICAuLi5tYXBTdHlsZXNbaWRdLFxuICAgICAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAge31cbiAgICAgICAgICApLFxuICAgICAgICAgIG9uU3VjY2Vzc1xuICAgICAgICApLFxuICAgICAgLy8gZXJyb3JcbiAgICAgIGVyciA9PiBsb2FkTWFwU3R5bGVFcnIoT2JqZWN0LmtleXMobWFwU3R5bGVzKSwgZXJyKVxuICAgIClcbiAgXTtcbn1cbi8qKlxuICogUmVzZXQgbWFwIHN0eWxlIGNvbmZpZyB0byBpbml0aWFsIHN0YXRlXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGBtYXBTdHlsZWBcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVzZXRNYXBDb25maWdNYXBTdHlsZVVwZGF0ZXIgPSAoc3RhdGU6IE1hcFN0eWxlKTogTWFwU3R5bGUgPT4ge1xuICBjb25zdCBlbXB0eUNvbmZpZyA9IHtcbiAgICAuLi5JTklUSUFMX01BUF9TVFlMRSxcbiAgICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogc3RhdGUubWFwYm94QXBpQWNjZXNzVG9rZW4sXG4gICAgbWFwYm94QXBpVXJsOiBzdGF0ZS5tYXBib3hBcGlVcmwsXG4gICAgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQ6IHN0YXRlLm1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0LFxuICAgIC4uLnN0YXRlLmluaXRpYWxTdGF0ZSxcbiAgICBtYXBTdHlsZXM6IHN0YXRlLm1hcFN0eWxlcyxcbiAgICBpbml0aWFsU3RhdGU6IHN0YXRlLmluaXRpYWxTdGF0ZVxuICB9O1xuXG4gIHJldHVybiBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIoZW1wdHlDb25maWcsIHtwYXlsb2FkOiB7c3R5bGVUeXBlOiBlbXB0eUNvbmZpZy5zdHlsZVR5cGV9fSk7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHdoZW4gYSBjdXN0b20gbWFwIHN0eWxlIG9iamVjdCBpcyByZWNlaXZlZFxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHtpY29uLCBzdHlsZSwgZXJyb3J9fTogTWFwU3R5bGVBY3Rpb25zLkxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGlucHV0U3R5bGU6IHtcbiAgICAuLi5zdGF0ZS5pbnB1dFN0eWxlLFxuICAgIC8vIHN0eWxlIGpzb24gYW5kIGljb24gd2lsbCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgLi4uKHN0eWxlXG4gICAgICA/IHtcbiAgICAgICAgICBpZDpcbiAgICAgICAgICAgIHN0YXRlLmlucHV0U3R5bGUuY3VzdG9tID09PSAnTUFOQUdFRCdcbiAgICAgICAgICAgICAgPyBzdGF0ZS5pbnB1dFN0eWxlLmlkIC8vIGN1c3RvbSBNQU5BR0VEIHR5cGVcbiAgICAgICAgICAgICAgOiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgc3R5bGUuaWQgfHwgZ2VuZXJhdGVIYXNoSWQoKSwgLy8gY3VzdG9tIExPQ0FMIHR5cGVcbiAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICAgICAgc3R5bGU6IGNsb25lRGVlcChzdHlsZSksXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGxhYmVsOiBzdGF0ZS5pbnB1dFN0eWxlLmxhYmVsIHx8IHN0eWxlLm5hbWUsXG4gICAgICAgICAgLy8gZ2F0aGVyaW5nIGxheWVyIGdyb3VwIGluZm8gZnJvbSBzdHlsZSBqc29uXG4gICAgICAgICAgbGF5ZXJHcm91cHM6IGdldExheWVyR3JvdXBzRnJvbVN0eWxlKHN0eWxlKVxuICAgICAgICB9XG4gICAgICA6IHt9KSxcbiAgICAuLi4oaWNvbiA/IHtpY29ufSA6IHt9KSxcbiAgICAuLi4oZXJyb3IgIT09IHVuZGVmaW5lZCA/IHtlcnJvcn0gOiB7fSlcbiAgfVxufSk7XG5cbi8qKlxuICogSW5wdXQgYSBjdXN0b20gbWFwIHN0eWxlIG9iamVjdFxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGlucHV0TWFwU3R5bGVVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIHtwYXlsb2FkOiB7aW5wdXRTdHlsZSwgbWFwU3RhdGV9fTogTWFwU3R5bGVBY3Rpb25zLklucHV0TWFwU3R5bGVVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgLi4uc3RhdGUuaW5wdXRTdHlsZSxcbiAgICAuLi5pbnB1dFN0eWxlXG4gIH07XG5cbiAgLy8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGVpdGhlciBhIHVybCB0byBob3N0ZWQgc3R5bGUganNvbiB0aGF0IG5lZWRzIGFuIGljb24gdXJsLFxuICAvLyBvciBhbiBpY29uIGFscmVhZHkgYXZhaWxhYmxlIGNsaWVudC1zaWRlIGFzIGEgZGF0YSB1cmlcbiAgY29uc3QgaXNVcGRhdGVkSWNvbkRhdGFVcmkgPSB1cGRhdGVkLmljb24/LnN0YXJ0c1dpdGgoJ2RhdGE6aW1hZ2UnKTtcbiAgY29uc3QgaXNNYXBib3hTdHlsZVVybCA9XG4gICAgdXBkYXRlZC51cmw/LnN0YXJ0c1dpdGgoJ21hcGJveDovLycpIHx8IHVwZGF0ZWQudXJsPy5pbmNsdWRlcygnbWFwYm94LmNvbScpO1xuXG4gIGNvbnN0IGljb24gPVxuICAgICFpc1VwZGF0ZWRJY29uRGF0YVVyaSAmJiBpc01hcGJveFN0eWxlVXJsXG4gICAgICA/IC8vIEdldCBpbWFnZSBpY29uIHVybHMgb25seSBmb3IgbWFwYm94IG1hcCBsaWIuXG4gICAgICAgIGdldFN0eWxlSW1hZ2VJY29uKHtcbiAgICAgICAgICBtYXBTdGF0ZSxcbiAgICAgICAgICBzdHlsZVVybDogdXBkYXRlZC51cmwgfHwgJycsXG4gICAgICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IHVwZGF0ZWQuYWNjZXNzVG9rZW4gfHwgc3RhdGUubWFwYm94QXBpQWNjZXNzVG9rZW4gfHwgJycsXG4gICAgICAgICAgbWFwYm94QXBpVXJsOiBzdGF0ZS5tYXBib3hBcGlVcmwgfHwgREVGQVVMVF9NQVBCT1hfQVBJX1VSTFxuICAgICAgICB9KVxuICAgICAgOiB1cGRhdGVkLmljb247XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBpbnB1dFN0eWxlOiB7XG4gICAgICAuLi51cGRhdGVkLFxuICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgIGljb25cbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEFkZCBtYXAgc3R5bGUgZnJvbSB1c2VyIGlucHV0IHRvIHJlZHVjZXIgYW5kIHNldCBpdCB0byBjdXJyZW50IHN0eWxlXG4gKiBUaGlzIGFjdGlvbiBpcyBjYWxsZWQgd2hlbiB1c2VyIGNsaWNrIGNvbmZpcm0gYWZ0ZXIgcHV0dGluZyBpbiBhIHZhbGlkIHN0eWxlIHVybCBpbiB0aGUgY3VzdG9tIG1hcCBzdHlsZSBkaWFsb2cuXG4gKiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBmcm9tIG91dHNpZGUga2VwbGVyLmdsIHdpdGhvdXQgYSB2YWxpZCBgaW5wdXRTdHlsZWAgaW4gdGhlIGBtYXBTdHlsZWAgcmVkdWNlci5cbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRDdXN0b21NYXBTdHlsZVVwZGF0ZXIgPSAoc3RhdGU6IE1hcFN0eWxlKTogTWFwU3R5bGUgPT4ge1xuICBjb25zdCBzdHlsZUlkID0gc3RhdGUuaW5wdXRTdHlsZS5pZDtcbiAgaWYgKCFzdHlsZUlkKSByZXR1cm4gc3RhdGU7XG5cbiAgY29uc3QgbmV3U3RhdGUgPSBnZXROZXdTdGF0ZVdpdGhDdXN0b21NYXBTdHlsZShzdGF0ZSk7XG4gIC8vIHNldCBuZXcgc3R5bGVcbiAgcmV0dXJuIG1hcFN0eWxlQ2hhbmdlVXBkYXRlcihuZXdTdGF0ZSwge3BheWxvYWQ6IHtzdHlsZVR5cGU6IHN0eWxlSWR9fSk7XG59O1xuXG4vKipcbiAqIEVkaXQgbWFwIHN0eWxlIGZyb20gdXNlciBpbnB1dCB0byByZWR1Y2VyLlxuICogVGhpcyBhY3Rpb24gaXMgY2FsbGVkIHdoZW4gdXNlciBjbGlja3MgY29uZmlybSBhZnRlciBlZGl0aW5nIGFuIGV4aXN0aW5nIGN1c3RvbSBzdHlsZSBpbiB0aGUgY3VzdG9tIG1hcCBzdHlsZSBkaWFsb2cuXG4gKiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBmcm9tIG91dHNpZGUga2VwbGVyLmdsIHdpdGhvdXQgYSB2YWxpZCBgaW5wdXRTdHlsZWAgaW4gdGhlIGBtYXBTdHlsZWAgcmVkdWNlci5cbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBlZGl0Q3VzdG9tTWFwU3R5bGVVcGRhdGVyID0gKHN0YXRlOiBNYXBTdHlsZSk6IE1hcFN0eWxlID0+IHtcbiAgcmV0dXJuIGdldE5ld1N0YXRlV2l0aEN1c3RvbU1hcFN0eWxlKHN0YXRlKTtcbn07XG5cbmZ1bmN0aW9uIGdldE5ld1N0YXRlV2l0aEN1c3RvbU1hcFN0eWxlKHN0YXRlOiBNYXBTdHlsZSk6IE1hcFN0eWxlIHtcbiAgY29uc3Qgc3R5bGVJZCA9IHN0YXRlLmlucHV0U3R5bGUuaWQ7XG4gIGlmICghc3R5bGVJZCkgcmV0dXJuIHN0YXRlO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQcm9wZXJ0eSAnbGF5ZXJHcm91cHMnIGlzIG1pc3NpbmcgaW4gdHlwZSAnSW5wdXRTdHlsZScgYnV0IHJlcXVpcmVkIGluIHR5cGUgJ0Jhc2VNYXBTdHlsZScuIExlZ2FjeSBjYXNlP1xuICAgIG1hcFN0eWxlczoge1xuICAgICAgLi4uc3RhdGUubWFwU3R5bGVzLFxuICAgICAgW3N0eWxlSWRdOiB7XG4gICAgICAgIC4uLnN0YXRlLm1hcFN0eWxlc1tzdHlsZUlkXSwgLy8gZG8gbm90IHVuaW50ZW50aW9uYWxseSBkcm9wIGFueSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgICAgLi4uc3RhdGUuaW5wdXRTdHlsZVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gc2V0IHRvIGRlZmF1bHRcbiAgICBpbnB1dFN0eWxlOiBnZXRJbml0aWFsSW5wdXRTdHlsZSgpXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY3VzdG9tIG1hcCBzdHlsZSBmcm9tIGBzdGF0ZS5tYXBTdHlsZS5tYXBTdHlsZXNgLlxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUN1c3RvbU1hcFN0eWxlVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0eWxlLFxuICBhY3Rpb246IE1hcFN0eWxlQWN0aW9ucy5SZW1vdmVDdXN0b21NYXBTdHlsZVVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+IHtcbiAgY29uc3Qge2lkfSA9IGFjdGlvbi5wYXlsb2FkO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3Qge1tpZF06IF8sIC4uLnJlc3RPZk1hcFN0eWxlc30gPSBzdGF0ZS5tYXBTdHlsZXM7XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgbWFwU3R5bGVzOiByZXN0T2ZNYXBTdHlsZXNcbiAgfTtcblxuICBpZiAoc3RhdGUuc3R5bGVUeXBlID09PSBpZCkge1xuICAgIC8vIGlmIHJlbW92aW5nIGEgY3VzdG9tIHN0eWxlIHRoYXQgaXMgYWxzbyB0aGUgY3VycmVudCBhY3RpdmUgYmFzZSBtYXAsXG4gICAgLy8gdGhlbiByZXNldCB0byB0aGUgZGVmYXVsdCBhY3RpdmUgYmFzZSBtYXAgKGBtYXBTdHlsZS5zdHlsZVR5cGVgKVxuICAgIHJldHVybiBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIobmV3U3RhdGUsIHtwYXlsb2FkOiB7c3R5bGVUeXBlOiBnZXREZWZhdWx0U3RhdGUoKS5zdHlsZVR5cGV9fSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgM2QgYnVpbGRpbmcgY29sb3JcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBzZXQzZEJ1aWxkaW5nQ29sb3JVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIHtwYXlsb2FkOiBjb2xvcn06IE1hcFN0eWxlQWN0aW9ucy5TZXQzZEJ1aWxkaW5nQ29sb3JVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgdGhyZWVEQnVpbGRpbmdDb2xvcjogY29sb3IsXG4gIGN1c3RvbTNEQnVpbGRpbmdDb2xvcjogdHJ1ZVxufSk7XG5cbi8qKlxuICogVXBkYXRlcyBiYWNrZ3JvdW5kIGNvbG9yXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICovXG5leHBvcnQgY29uc3Qgc2V0QmFja2dyb3VuZENvbG9yVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0eWxlLFxuICB7cGF5bG9hZDogY29sb3J9OiBNYXBTdHlsZUFjdGlvbnMuU2V0QmFja2dyb3VuZENvbG9yVXBkYXRlckFjdGlvblxuKTogTWFwU3R5bGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGJhY2tncm91bmRDb2xvcjogY29sb3Jcbn0pO1xuXG4vKipcbiAqIFJldHVybiB0aGUgaW5pdGlhbCBpbnB1dCBzdHlsZVxuICogQHJldHVybiBPYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluaXRpYWxJbnB1dFN0eWxlKCk6IElucHV0U3R5bGUge1xuICByZXR1cm4ge1xuICAgIGlkOiBudWxsLFxuICAgIGFjY2Vzc1Rva2VuOiBudWxsLFxuICAgIGVycm9yOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICBsYWJlbDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICB1cmw6IG51bGwsXG4gICAgaWNvbjogbnVsbCxcbiAgICBjdXN0b206ICdMT0NBTCcsXG4gICAgdXBsb2FkZWRGaWxlOiBudWxsXG4gIH07XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFHQSxJQUFBQSxNQUFBLEdBQUFDLHVCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxVQUFBLEdBQUFDLHNCQUFBLENBQUFGLE9BQUE7QUFDQSxJQUFBRyxRQUFBLEdBQUFELHNCQUFBLENBQUFGLE9BQUE7QUFHQSxJQUFBSSxNQUFBLEdBQUFKLE9BQUE7QUFZQSxJQUFBSyxZQUFBLEdBQUFMLE9BQUE7QUFDQSxJQUFBTSxVQUFBLEdBQUFOLE9BQUE7QUFVQSxJQUFBTyxPQUFBLEdBQUFQLE9BQUE7QUFDQSxJQUFBUSxRQUFBLEdBQUFSLE9BQUE7QUFVQSxJQUFBUyxRQUFBLEdBQUFULE9BQUE7QUFPNEIsU0FBQVUseUJBQUFDLENBQUE7RUFBQSx5QkFBQUMsT0FBQTtFQUFBLElBQUFDLENBQUEsT0FBQUQsT0FBQTtJQUFBRSxDQUFBLE9BQUFGLE9BQUE7RUFBQSxRQUFBRix3QkFBQSxZQUFBQSx5QkFBQUMsQ0FBQTtJQUFBLE9BQUFBLENBQUEsR0FBQUcsQ0FBQSxHQUFBRCxDQUFBO0VBQUEsR0FBQUYsQ0FBQTtBQUFBO0FBQUEsU0FBQVosd0JBQUFZLENBQUEsRUFBQUUsQ0FBQTtFQUFBLEtBQUFBLENBQUEsSUFBQUYsQ0FBQSxJQUFBQSxDQUFBLENBQUFJLFVBQUEsU0FBQUosQ0FBQTtFQUFBLGFBQUFBLENBQUEsZ0JBQUFLLE9BQUEsQ0FBQUwsQ0FBQSwwQkFBQUEsQ0FBQTtJQUFBLFdBQUFBO0VBQUE7RUFBQSxJQUFBRyxDQUFBLEdBQUFK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QUU7SUFBUzhLLGVBQWUsT0FBQUMseUJBQUEsYUFBQUgsZ0JBQUEsR0FBMUI1SyxFQUFFLEVBQUEwRSxHQUFBLENBQUF2RyxjQUFBO0VBRVYsSUFBTW1KLFFBQVEsR0FBQXBJLGFBQUEsQ0FBQUEsYUFBQSxLQUNUb0csS0FBSztJQUNSOUUsU0FBUyxFQUFFc0s7RUFBZSxFQUMzQjtFQUVELElBQUl4RixLQUFLLENBQUNoRixTQUFTLEtBQUtOLEVBQUUsRUFBRTtJQUMxQjtJQUNBO0lBQ0EsT0FBT3VHLHFCQUFxQixDQUFDZSxRQUFRLEVBQUU7TUFBQzdCLE9BQU8sRUFBRTtRQUFDbkYsU0FBUyxFQUFFSCxlQUFlLENBQUMsQ0FBQyxDQUFDRztNQUFTO0lBQUMsQ0FBQyxDQUFDO0VBQzdGO0VBRUEsT0FBT2dILFFBQVE7QUFDakIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU0wRCx5QkFBeUIsR0FBQXRMLE9BQUEsQ0FBQXNMLHlCQUFBLEdBQUcsU0FBNUJBLHlCQUF5QkEsQ0FDcEMxRixLQUFlLEVBQUEyRixNQUFBO0VBQUEsSUFDTHBJLEtBQUssR0FBQW9JLE1BQUEsQ0FBZHhGLE9BQU87RUFBQSxPQUFBdkcsYUFBQSxDQUFBQSxhQUFBLEtBRUxvRyxLQUFLO0lBQ1J0RSxtQkFBbUIsRUFBRTZCLEtBQUs7SUFDMUIxQixxQkFBcUIsRUFBRTtFQUFJO0FBQUEsQ0FDM0I7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNK0oseUJBQXlCLEdBQUF4TCxPQUFBLENBQUF3TCx5QkFBQSxHQUFHLFNBQTVCQSx5QkFBeUJBLENBQ3BDNUYsS0FBZSxFQUFBNkYsTUFBQTtFQUFBLElBQ0x0SSxLQUFLLEdBQUFzSSxNQUFBLENBQWQxRixPQUFPO0VBQUEsT0FBQXZHLGFBQUEsQ0FBQUEsYUFBQSxLQUVMb0csS0FBSztJQUNSbEUsZUFBZSxFQUFFeUI7RUFBSztBQUFBLENBQ3RCOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBUzlCLG9CQUFvQkEsQ0FBQSxFQUFlO0VBQ2pELE9BQU87SUFDTGYsRUFBRSxFQUFFLElBQUk7SUFDUnVJLFdBQVcsRUFBRSxJQUFJO0lBQ2pCVCxLQUFLLEVBQUUsS0FBSztJQUNad0MsT0FBTyxFQUFFLEtBQUs7SUFDZGYsS0FBSyxFQUFFLElBQUk7SUFDWHhILEtBQUssRUFBRSxJQUFJO0lBQ1g4RSxHQUFHLEVBQUUsSUFBSTtJQUNUNUcsSUFBSSxFQUFFLElBQUk7SUFDVjJHLE1BQU0sRUFBRSxPQUFPO0lBQ2Z3RSxZQUFZLEVBQUU7RUFDaEIsQ0FBQztBQUNIIiwiaWdub3JlTGlzdCI6W119