"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toggleSplitMapUpdater = exports.replaceDataInMapUpdater = exports.loadFilesSuccessUpdater = exports.isValidConfig = exports.defaultAddDataToMapOptions = exports.combinedMapStyleChangeUpdater = exports.combinedLayerTypeChangeUpdater = exports.addDataToMapUpdater = exports.addDataToMapComposed = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _uiStateUpdaters = require("./ui-state-updaters");
var _visStateUpdaters = require("./vis-state-updaters");
var _mapStateUpdaters = require("./map-state-updaters");
var _mapStyleUpdaters = require("./map-style-updaters");
var _processors = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/processors/src");
var _composerHelpers = require("./composer-helpers");
var _utils = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/utils/src");
var _dataUtils = require("./data-utils");
var _constants = require("/Users/ihordykhta/Desktop/unfolded/kepler.gl/src/constants/src");
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      (0, _defineProperty2["default"])(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
} // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
// compose action to apply result multiple reducers, with the output of one

/**
 * Some actions will affect the entire kepler.lg instance state.
 * The updaters for these actions is exported as `combinedUpdaters`. These updater take the entire instance state
 * as the first argument. Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {combinedUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // add data to map after receiving data from remote sources
 *    case 'LOAD_REMOTE_RESOURCE_SUCCESS':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          // pass in kepler.gl instance state to combinedUpdaters
 *          map:  combinedUpdaters.addDataToMapUpdater(
 *           state.keplerGl.map,
 *           {
 *             payload: {
 *               datasets: action.datasets,
 *               options: {readOnly: true},
 *               config: action.config
 *              }
 *            }
 *          )
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable @typescript-eslint/no-unused-vars */
// @ts-ignore
var combinedUpdaters = null;
/* eslint-enable @typescript-eslint/no-unused-vars */

var isValidConfig = exports.isValidConfig = function isValidConfig(config) {
  return (0, _utils.isPlainObject)(config) && (0, _utils.isPlainObject)(config.config) && config.version;
};
var defaultAddDataToMapOptions = exports.defaultAddDataToMapOptions = {
  centerMap: true,
  keepExistingConfig: false,
  autoCreateLayers: true,
  autoCreateTooltips: true
};

/**
 * Combine data and full configuration update in a single action
 *
 * @memberof combinedUpdaters
 * @param {Object} state kepler.gl instance state, containing all subreducer state
 * @param {Object} action
 * @param {Object} action.payload `{datasets, options, config}`
 * @param action.payload.datasets - ***required** datasets can be a dataset or an array of datasets
 * Each dataset object needs to have `info` and `data` property.
 * @param [action.payload.options] option object `{centerMap: true}`
 * @param [action.payload.config] map config
 * @param [action.payload.info] map info contains title and description
 * @returns nextState
 *
 * @typedef {Object} Dataset
 * @property info -info of a dataset
 * @property info.id - id of this dataset. If config is defined, `id` should matches the `dataId` in config.
 * @property info.label - A display name of this dataset
 * @property data - ***required** The data object, in a tabular format with 2 properties `fields` and `rows`
 * @property data.fields - ***required** Array of fields,
 * @property data.fields.name - ***required** Name of the field,
 * @property data.rows - ***required** Array of rows, in a tabular format with `fields` and `rows`
 *
 * @public
 */
var addDataToMapUpdater = exports.addDataToMapUpdater = function addDataToMapUpdater(state, _ref) {
  var _datasets$, _datasets$2, _datasets$3, _parsedConfig, _parsedConfig2, _parsedConfig$uiState, _parsedConfig3;
  var payload = _ref.payload;
  var datasets = payload.datasets,
    config = payload.config,
    info = payload.info;
  var options = _objectSpread(_objectSpread({}, defaultAddDataToMapOptions), payload.options);

  // check if progressive loading dataset by batches, and update visState directly
  var isProgressiveLoading = Array.isArray(datasets) && ((_datasets$ = datasets[0]) === null || _datasets$ === void 0 ? void 0 : _datasets$.info.format) === 'arrow' && ((_datasets$2 = datasets[0]) === null || _datasets$2 === void 0 ? void 0 : _datasets$2.info.id) && ((_datasets$3 = datasets[0]) === null || _datasets$3 === void 0 ? void 0 : _datasets$3.info.id) in state.visState.datasets;
  if (isProgressiveLoading) {
    return (0, _composerHelpers.compose_)([(0, _composerHelpers.pick_)('visState')((0, _composerHelpers.apply_)(_visStateUpdaters.updateVisDataUpdater, {
      datasets: datasets,
      options: options,
      config: config
    }))])(state);
  }

  // @ts-expect-error
  var parsedConfig = config;
  if (isValidConfig(config)) {
    // if passed in saved config
    // @ts-expect-error
    parsedConfig = state.visState.schema.parseSavedConfig(config);
  }
  var oldLayers = state.visState.layers;
  var filterNewlyAddedLayers = function filterNewlyAddedLayers(layers) {
    return layers.filter(function (nl) {
      return !oldLayers.find(function (ol) {
        return ol === nl;
      });
    });
  };

  // Returns undefined if not found, to make typescript happy
  var findMapBoundsIfCentered = function findMapBoundsIfCentered(layers) {
    var bounds = options.centerMap && (0, _dataUtils.findMapBounds)(layers);
    return bounds ? bounds : undefined;
  };
  return (0, _composerHelpers.compose_)([(0, _composerHelpers.pick_)('visState')(
  // this part can be async
  (0, _composerHelpers.apply_)(_visStateUpdaters.updateVisDataUpdater, {
    datasets: datasets,
    options: options,
    config: parsedConfig
  })), (0, _composerHelpers.if_)(Boolean(info), (0, _composerHelpers.pick_)('visState')((0, _composerHelpers.apply_)(_visStateUpdaters.setMapInfoUpdater, {
    info: info
  }))),
  // Note that fit bounds here won't be called in case datasets are created in Tasks.
  // A separate Task to update bounds is created once the datasets are ready.
  (0, _composerHelpers.with_)(function (_ref2) {
    var visState = _ref2.visState;
    return (0, _composerHelpers.pick_)('mapState')((0, _composerHelpers.apply_)(_mapStateUpdaters.receiveMapConfigUpdater, (0, _composerHelpers.payload_)({
      config: parsedConfig,
      options: options,
      bounds: findMapBoundsIfCentered(filterNewlyAddedLayers(visState.layers))
    })));
  }), (0, _composerHelpers.pick_)('mapStyle')((0, _composerHelpers.apply_)(_mapStyleUpdaters.receiveMapConfigUpdater, (0, _composerHelpers.payload_)({
    config: parsedConfig,
    options: options
  }))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.apply_)(_uiStateUpdaters.loadFilesSuccessUpdater, (0, _composerHelpers.payload_)(null))), (0, _composerHelpers.if_)(Boolean((_parsedConfig = parsedConfig) === null || _parsedConfig === void 0 || (_parsedConfig = _parsedConfig.uiState) === null || _parsedConfig === void 0 || (_parsedConfig = _parsedConfig.mapControls) === null || _parsedConfig === void 0 || (_parsedConfig = _parsedConfig.mapLegend) === null || _parsedConfig === void 0 ? void 0 : _parsedConfig.active), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.apply_)(_uiStateUpdaters.toggleMapControlUpdater, (0, _composerHelpers.payload_)({
    panelId: 'mapLegend',
    index: 0
  })))), (0, _composerHelpers.if_)(Boolean((_parsedConfig2 = parsedConfig) === null || _parsedConfig2 === void 0 || (_parsedConfig2 = _parsedConfig2.uiState) === null || _parsedConfig2 === void 0 || (_parsedConfig2 = _parsedConfig2.mapControls) === null || _parsedConfig2 === void 0 || (_parsedConfig2 = _parsedConfig2.mapLegend) === null || _parsedConfig2 === void 0 ? void 0 : _parsedConfig2.settings), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.apply_)(_uiStateUpdaters.setMapControlSettingsUpdater, (0, _composerHelpers.payload_)({
    panelId: 'mapLegend',
    settings: (_parsedConfig$uiState = (_parsedConfig3 = parsedConfig) === null || _parsedConfig3 === void 0 || (_parsedConfig3 = _parsedConfig3.uiState) === null || _parsedConfig3 === void 0 || (_parsedConfig3 = _parsedConfig3.mapControls) === null || _parsedConfig3 === void 0 || (_parsedConfig3 = _parsedConfig3.mapLegend) === null || _parsedConfig3 === void 0 ? void 0 : _parsedConfig3.settings) !== null && _parsedConfig$uiState !== void 0 ? _parsedConfig$uiState : {}
  })))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.apply_)(_uiStateUpdaters.toggleModalUpdater, (0, _composerHelpers.payload_)(null))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.merge_)(Object.prototype.hasOwnProperty.call(options, 'readOnly') ? {
    readOnly: options.readOnly
  } : {}))])(state);
};
var loadFilesSuccessUpdater = exports.loadFilesSuccessUpdater = function loadFilesSuccessUpdater(state, action) {
  // still more to load
  var payloads = (0, _processors.filesToDataPayload)(action.result);
  var nextState = (0, _composerHelpers.compose_)([(0, _composerHelpers.pick_)('visState')((0, _composerHelpers.merge_)({
    fileLoading: false,
    fileLoadingProgress: {}
  }))])(state);
  // make multiple add data to map calls
  var stateWithData = (0, _composerHelpers.compose_)(payloads.map(function (p) {
    return (0, _composerHelpers.apply_)(addDataToMapUpdater, (0, _composerHelpers.payload_)(p));
  }))(nextState);
  return stateWithData;
};
var addDataToMapComposed = exports.addDataToMapComposed = addDataToMapUpdater;

/**
 * Helper which updates map overlay blending mode in visState,
 * but only if it's not currently in the `normal` mode.
 */
var updateOverlayBlending = function updateOverlayBlending(overlayBlending) {
  return function (visState) {
    if (visState.overlayBlending !== _constants.OVERLAY_BLENDINGS.normal.value) {
      return _objectSpread(_objectSpread({}, visState), {}, {
        overlayBlending: overlayBlending
      });
    }
    return visState;
  };
};

/**
 * Helper which updates `darkBaseMapEnabled` in all the layers in visState which
 * have this config setting (or in one specific layer if the `layerId` param is provided).
 */
var updateDarkBaseMapLayers = function updateDarkBaseMapLayers(darkBaseMapEnabled) {
  var layerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (visState) {
    return _objectSpread(_objectSpread({}, visState), {}, {
      layers: visState.layers.map(function (layer) {
        if (!layerId || layer.id === layerId) {
          if (Object.prototype.hasOwnProperty.call(layer.visConfigSettings, 'darkBaseMapEnabled')) {
            var visConfig = layer.config.visConfig;
            return layer.updateLayerConfig({
              visConfig: _objectSpread(_objectSpread({}, visConfig), {}, {
                darkBaseMapEnabled: darkBaseMapEnabled
              })
            });
          }
        }
        return layer;
      })
    });
  };
};

/**
 * Updater that changes the map style by calling mapStyleChangeUpdater on visState.
 * In addition to that, it does the following:
 *
 *   1. Update map overlay blending mode in accordance with the colorMode of the
 *      base map, but only if it's not in the `normal` mode.
 *
 *   2. Update all the layers which have the `darkBaseMapEnabled` config setting
 *      adjusting it in accordance with the colorMode of the base map.
 *
 */
var combinedMapStyleChangeUpdater = exports.combinedMapStyleChangeUpdater = function combinedMapStyleChangeUpdater(state, action) {
  var payload = action.payload;
  var mapStyle = state.mapStyle;
  var getColorMode = function getColorMode(key) {
    var _mapStyle$mapStyles$k;
    return (_mapStyle$mapStyles$k = mapStyle.mapStyles[key]) === null || _mapStyle$mapStyles$k === void 0 ? void 0 : _mapStyle$mapStyles$k.colorMode;
  };
  var prevColorMode = getColorMode(mapStyle.styleType);
  var nextColorMode = getColorMode(payload.styleType);
  var visState = state.visState;
  if (nextColorMode !== prevColorMode) {
    switch (nextColorMode) {
      case _constants.BASE_MAP_COLOR_MODES.DARK:
        visState = (0, _composerHelpers.compose_)([updateOverlayBlending(_constants.OVERLAY_BLENDINGS.screen.value), updateDarkBaseMapLayers(true)])(visState);
        break;
      case _constants.BASE_MAP_COLOR_MODES.LIGHT:
        visState = (0, _composerHelpers.compose_)([updateOverlayBlending(_constants.OVERLAY_BLENDINGS.darken.value), updateDarkBaseMapLayers(false)])(visState);
        break;
      default:
      // do nothing
    }
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    visState: visState,
    mapStyle: (0, _mapStyleUpdaters.mapStyleChangeUpdater)(mapStyle, {
      payload: _objectSpread({}, payload)
    })
  });
};

/**
 * Updater that changes the layer type by calling `layerTypeChangeUpdater` on visState.
 * In addition to that, if the new layer type has the `darkBaseMapEnabled` config
 * setting, we adjust it in accordance with the colorMode of the base map.s
 */
var combinedLayerTypeChangeUpdater = exports.combinedLayerTypeChangeUpdater = function combinedLayerTypeChangeUpdater(state, action) {
  var visState = state.visState;
  var oldLayerIndex = visState.layers.findIndex(function (layer) {
    return layer === action.oldLayer;
  });
  visState = (0, _visStateUpdaters.layerTypeChangeUpdater)(visState, action);
  var newLayer = visState.layers[oldLayerIndex];
  if (Object.prototype.hasOwnProperty.call(newLayer === null || newLayer === void 0 ? void 0 : newLayer.visConfigSettings, 'darkBaseMapEnabled')) {
    var mapStyle = state.mapStyle;
    var colorMode = mapStyle.mapStyles[mapStyle.styleType].colorMode;
    var darkBaseMapEnabled = newLayer.config.visConfig.darkBaseMapEnabled;
    switch (colorMode) {
      case _constants.BASE_MAP_COLOR_MODES.DARK:
        if (!darkBaseMapEnabled) {
          visState = updateDarkBaseMapLayers(true, newLayer.id)(visState);
        }
        break;
      case _constants.BASE_MAP_COLOR_MODES.LIGHT:
        if (darkBaseMapEnabled) {
          visState = updateDarkBaseMapLayers(false, newLayer.id)(visState);
        }
        break;
      default:
      // do nothing
    }
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    visState: visState
  });
};

/**
 * Make mapLegend active when toggleSplitMap action is called
 */
var toggleSplitMapUpdater = exports.toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {
  var _newState$uiState$map;
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    visState: (0, _visStateUpdaters.toggleSplitMapUpdater)(state.visState, action),
    uiState: (0, _uiStateUpdaters.toggleSplitMapUpdater)(state.uiState),
    mapState: (0, _mapStateUpdaters.toggleSplitMapUpdater)(state.mapState)
  });
  var isSplit = newState.visState.splitMaps.length !== 0;
  var isLegendActive = (_newState$uiState$map = newState.uiState.mapControls) === null || _newState$uiState$map === void 0 || (_newState$uiState$map = _newState$uiState$map.mapLegend) === null || _newState$uiState$map === void 0 ? void 0 : _newState$uiState$map.active;
  if (isSplit && !isLegendActive) {
    newState.uiState = (0, _uiStateUpdaters.toggleMapControlUpdater)(newState.uiState, {
      payload: {
        panelId: 'mapLegend',
        index: action.payload
      }
    });
  }
  return newState;
};
var defaultReplaceDataToMapOptions = {
  keepExistingConfig: true,
  centerMap: true,
  autoCreateLayers: false
};

/**
 * Updater replace a dataset in state
 */
var replaceDataInMapUpdater = exports.replaceDataInMapUpdater = function replaceDataInMapUpdater(state, _ref3) {
  var payload = _ref3.payload;
  var datasetToReplaceId = payload.datasetToReplaceId,
    datasetToUse = payload.datasetToUse,
    _payload$options = payload.options,
    options = _payload$options === void 0 ? {} : _payload$options;
  var addDataToMapOptions = _objectSpread(_objectSpread({}, defaultReplaceDataToMapOptions), options);

  // check if dataset is there
  if (!state.visState.datasets[datasetToReplaceId]) {
    return state;
  }
  // datasetToUse is ProtoDataset
  var dataIdToUse = datasetToUse.info.id;
  if (!dataIdToUse) {
    return state;
  }
  // remove dataset and put dependencies in toBeMerged
  var preparedState = _objectSpread(_objectSpread({}, state), {}, {
    visState: (0, _visStateUpdaters.prepareStateForDatasetReplace)(state.visState, datasetToReplaceId, dataIdToUse)
  });
  var nextState = addDataToMapUpdater(preparedState, (0, _composerHelpers.payload_)({
    datasets: datasetToUse,
    // should zoom to new dataset
    options: addDataToMapOptions
  }));
  return nextState;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfdWlTdGF0ZVVwZGF0ZXJzIiwicmVxdWlyZSIsIl92aXNTdGF0ZVVwZGF0ZXJzIiwiX21hcFN0YXRlVXBkYXRlcnMiLCJfbWFwU3R5bGVVcGRhdGVycyIsIl9wcm9jZXNzb3JzIiwiX2NvbXBvc2VySGVscGVycyIsIl91dGlscyIsIl9kYXRhVXRpbHMiLCJfY29uc3RhbnRzIiwib3duS2V5cyIsImUiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5MiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJjb21iaW5lZFVwZGF0ZXJzIiwiaXNWYWxpZENvbmZpZyIsImV4cG9ydHMiLCJjb25maWciLCJpc1BsYWluT2JqZWN0IiwidmVyc2lvbiIsImRlZmF1bHRBZGREYXRhVG9NYXBPcHRpb25zIiwiY2VudGVyTWFwIiwia2VlcEV4aXN0aW5nQ29uZmlnIiwiYXV0b0NyZWF0ZUxheWVycyIsImF1dG9DcmVhdGVUb29sdGlwcyIsImFkZERhdGFUb01hcFVwZGF0ZXIiLCJzdGF0ZSIsIl9yZWYiLCJfZGF0YXNldHMkIiwiX2RhdGFzZXRzJDIiLCJfZGF0YXNldHMkMyIsIl9wYXJzZWRDb25maWciLCJfcGFyc2VkQ29uZmlnMiIsIl9wYXJzZWRDb25maWckdWlTdGF0ZSIsIl9wYXJzZWRDb25maWczIiwicGF5bG9hZCIsImRhdGFzZXRzIiwiaW5mbyIsIm9wdGlvbnMiLCJpc1Byb2dyZXNzaXZlTG9hZGluZyIsIkFycmF5IiwiaXNBcnJheSIsImZvcm1hdCIsImlkIiwidmlzU3RhdGUiLCJjb21wb3NlXyIsInBpY2tfIiwiYXBwbHlfIiwidXBkYXRlVmlzRGF0YVVwZGF0ZXIiLCJwYXJzZWRDb25maWciLCJzY2hlbWEiLCJwYXJzZVNhdmVkQ29uZmlnIiwib2xkTGF5ZXJzIiwibGF5ZXJzIiwiZmlsdGVyTmV3bHlBZGRlZExheWVycyIsIm5sIiwiZmluZCIsIm9sIiwiZmluZE1hcEJvdW5kc0lmQ2VudGVyZWQiLCJib3VuZHMiLCJmaW5kTWFwQm91bmRzIiwidW5kZWZpbmVkIiwiaWZfIiwiQm9vbGVhbiIsInNldE1hcEluZm9VcGRhdGVyIiwid2l0aF8iLCJfcmVmMiIsInJlY2VpdmVNYXBDb25maWdVcGRhdGVyIiwicGF5bG9hZF8iLCJsb2FkRmlsZXNTdWNjZXNzVXBkYXRlciIsInVpU3RhdGUiLCJtYXBDb250cm9scyIsIm1hcExlZ2VuZCIsImFjdGl2ZSIsInRvZ2dsZU1hcENvbnRyb2xVcGRhdGVyIiwicGFuZWxJZCIsImluZGV4Iiwic2V0dGluZ3MiLCJzZXRNYXBDb250cm9sU2V0dGluZ3NVcGRhdGVyIiwidG9nZ2xlTW9kYWxVcGRhdGVyIiwibWVyZ2VfIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwicmVhZE9ubHkiLCJhY3Rpb24iLCJwYXlsb2FkcyIsImZpbGVzVG9EYXRhUGF5bG9hZCIsInJlc3VsdCIsIm5leHRTdGF0ZSIsImZpbGVMb2FkaW5nIiwiZmlsZUxvYWRpbmdQcm9ncmVzcyIsInN0YXRlV2l0aERhdGEiLCJtYXAiLCJwIiwiYWRkRGF0YVRvTWFwQ29tcG9zZWQiLCJ1cGRhdGVPdmVybGF5QmxlbmRpbmciLCJvdmVybGF5QmxlbmRpbmciLCJPVkVSTEFZX0JMRU5ESU5HUyIsIm5vcm1hbCIsInZhbHVlIiwidXBkYXRlRGFya0Jhc2VNYXBMYXllcnMiLCJkYXJrQmFzZU1hcEVuYWJsZWQiLCJsYXllcklkIiwibGF5ZXIiLCJ2aXNDb25maWdTZXR0aW5ncyIsInZpc0NvbmZpZyIsInVwZGF0ZUxheWVyQ29uZmlnIiwiY29tYmluZWRNYXBTdHlsZUNoYW5nZVVwZGF0ZXIiLCJtYXBTdHlsZSIsImdldENvbG9yTW9kZSIsImtleSIsIl9tYXBTdHlsZSRtYXBTdHlsZXMkayIsIm1hcFN0eWxlcyIsImNvbG9yTW9kZSIsInByZXZDb2xvck1vZGUiLCJzdHlsZVR5cGUiLCJuZXh0Q29sb3JNb2RlIiwiQkFTRV9NQVBfQ09MT1JfTU9ERVMiLCJEQVJLIiwic2NyZWVuIiwiTElHSFQiLCJkYXJrZW4iLCJtYXBTdHlsZUNoYW5nZVVwZGF0ZXIiLCJjb21iaW5lZExheWVyVHlwZUNoYW5nZVVwZGF0ZXIiLCJvbGRMYXllckluZGV4IiwiZmluZEluZGV4Iiwib2xkTGF5ZXIiLCJsYXllclR5cGVDaGFuZ2VVcGRhdGVyIiwibmV3TGF5ZXIiLCJ0b2dnbGVTcGxpdE1hcFVwZGF0ZXIiLCJfbmV3U3RhdGUkdWlTdGF0ZSRtYXAiLCJuZXdTdGF0ZSIsIm1hcFN0YXRlIiwiaXNTcGxpdCIsInNwbGl0TWFwcyIsImlzTGVnZW5kQWN0aXZlIiwiZGVmYXVsdFJlcGxhY2VEYXRhVG9NYXBPcHRpb25zIiwicmVwbGFjZURhdGFJbk1hcFVwZGF0ZXIiLCJfcmVmMyIsImRhdGFzZXRUb1JlcGxhY2VJZCIsImRhdGFzZXRUb1VzZSIsIl9wYXlsb2FkJG9wdGlvbnMiLCJhZGREYXRhVG9NYXBPcHRpb25zIiwiZGF0YUlkVG9Vc2UiLCJwcmVwYXJlZFN0YXRlIiwicHJlcGFyZVN0YXRlRm9yRGF0YXNldFJlcGxhY2UiXSwic291cmNlcyI6WyIuLi9zcmMvY29tYmluZWQtdXBkYXRlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IHtcbiAgdG9nZ2xlTW9kYWxVcGRhdGVyLFxuICBsb2FkRmlsZXNTdWNjZXNzVXBkYXRlciBhcyB1aVN0YXRlTG9hZEZpbGVzU3VjY2Vzc1VwZGF0ZXIsXG4gIHNldE1hcENvbnRyb2xTZXR0aW5nc1VwZGF0ZXIgYXMgdWlTdGF0ZVNldE1hcENvbnRyb2xTZXR0aW5nc1VwZGF0ZXIsXG4gIHRvZ2dsZU1hcENvbnRyb2xVcGRhdGVyIGFzIHVpU3RhdGVUb2dnbGVNYXBDb250cm9sVXBkYXRlcixcbiAgdG9nZ2xlTWFwQ29udHJvbFVwZGF0ZXIsXG4gIHRvZ2dsZVNwbGl0TWFwVXBkYXRlciBhcyB1aVN0YXRlVG9nZ2xlU3BsaXRNYXBVcGRhdGVyXG59IGZyb20gJy4vdWktc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtcbiAgdXBkYXRlVmlzRGF0YVVwZGF0ZXIgYXMgdmlzU3RhdGVVcGRhdGVWaXNEYXRhVXBkYXRlcixcbiAgc2V0TWFwSW5mb1VwZGF0ZXIsXG4gIGxheWVyVHlwZUNoYW5nZVVwZGF0ZXIsXG4gIHRvZ2dsZVNwbGl0TWFwVXBkYXRlciBhcyB2aXNTdGF0ZVRvZ2dsZVNwbGl0TWFwVXBkYXRlcixcbiAgcHJlcGFyZVN0YXRlRm9yRGF0YXNldFJlcGxhY2Vcbn0gZnJvbSAnLi92aXMtc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtcbiAgcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIgYXMgc3RhdGVNYXBDb25maWdVcGRhdGVyLFxuICB0b2dnbGVTcGxpdE1hcFVwZGF0ZXIgYXMgbWFwU3RhdGVUb2dnbGVTcGxpdE1hcFVwZGF0ZXJcbn0gZnJvbSAnLi9tYXAtc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtcbiAgbWFwU3R5bGVDaGFuZ2VVcGRhdGVyLFxuICByZWNlaXZlTWFwQ29uZmlnVXBkYXRlciBhcyBzdHlsZU1hcENvbmZpZ1VwZGF0ZXJcbn0gZnJvbSAnLi9tYXAtc3R5bGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtmaWxlc1RvRGF0YVBheWxvYWR9IGZyb20gJ0BrZXBsZXIuZ2wvcHJvY2Vzc29ycyc7XG5pbXBvcnQge3BheWxvYWRfLCBhcHBseV8sIHdpdGhfLCBpZl8sIGNvbXBvc2VfLCBtZXJnZV8sIHBpY2tffSBmcm9tICcuL2NvbXBvc2VyLWhlbHBlcnMnO1xuaW1wb3J0IHtNYXBTdGF0ZSwgVWlTdGF0ZSwgQWRkRGF0YVRvTWFwUGF5bG9hZCwgUGFyc2VkQ29uZmlnfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7TWFwU3R5bGV9IGZyb20gJy4vbWFwLXN0eWxlLXVwZGF0ZXJzJztcbmltcG9ydCB7UHJvdmlkZXJTdGF0ZX0gZnJvbSAnLi9wcm92aWRlci1zdGF0ZS11cGRhdGVycyc7XG5pbXBvcnQge1xuICBsb2FkRmlsZXNTdWNjZXNzVXBkYXRlckFjdGlvbixcbiAgTWFwU3R5bGVDaGFuZ2VVcGRhdGVyQWN0aW9uLFxuICBMYXllclR5cGVDaGFuZ2VVcGRhdGVyQWN0aW9uLFxuICBUb2dnbGVTcGxpdE1hcFVwZGF0ZXJBY3Rpb24sXG4gIFJlcGxhY2VEYXRhSW5NYXBQYXlsb2FkXG59IGZyb20gJ0BrZXBsZXIuZ2wvYWN0aW9ucyc7XG5pbXBvcnQge1Zpc1N0YXRlfSBmcm9tICdAa2VwbGVyLmdsL3NjaGVtYXMnO1xuaW1wb3J0IHtMYXllcn0gZnJvbSAnQGtlcGxlci5nbC9sYXllcnMnO1xuaW1wb3J0IHtpc1BsYWluT2JqZWN0fSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7ZmluZE1hcEJvdW5kc30gZnJvbSAnLi9kYXRhLXV0aWxzJztcbmltcG9ydCB7QkFTRV9NQVBfQ09MT1JfTU9ERVMsIE9WRVJMQVlfQkxFTkRJTkdTfSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5cbmV4cG9ydCB0eXBlIEtlcGxlckdsU3RhdGUgPSB7XG4gIHZpc1N0YXRlOiBWaXNTdGF0ZTtcbiAgbWFwU3RhdGU6IE1hcFN0YXRlO1xuICBtYXBTdHlsZTogTWFwU3R5bGU7XG4gIHVpU3RhdGU6IFVpU3RhdGU7XG4gIHByb3ZpZGVyU3RhdGU6IFByb3ZpZGVyU3RhdGU7XG59O1xuXG4vLyBjb21wb3NlIGFjdGlvbiB0byBhcHBseSByZXN1bHQgbXVsdGlwbGUgcmVkdWNlcnMsIHdpdGggdGhlIG91dHB1dCBvZiBvbmVcblxuLyoqXG4gKiBTb21lIGFjdGlvbnMgd2lsbCBhZmZlY3QgdGhlIGVudGlyZSBrZXBsZXIubGcgaW5zdGFuY2Ugc3RhdGUuXG4gKiBUaGUgdXBkYXRlcnMgZm9yIHRoZXNlIGFjdGlvbnMgaXMgZXhwb3J0ZWQgYXMgYGNvbWJpbmVkVXBkYXRlcnNgLiBUaGVzZSB1cGRhdGVyIHRha2UgdGhlIGVudGlyZSBpbnN0YW5jZSBzdGF0ZVxuICogYXMgdGhlIGZpcnN0IGFyZ3VtZW50LiBSZWFkIG1vcmUgYWJvdXQgW1VzaW5nIHVwZGF0ZXJzXSguLi9hZHZhbmNlZC11c2FnZS91c2luZy11cGRhdGVycy5tZClcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IGtlcGxlckdsUmVkdWNlciwge2NvbWJpbmVkVXBkYXRlcnN9IGZyb20gJ2tlcGxlci5nbC9yZWR1Y2Vycyc7XG4gKiAvLyBSb290IFJlZHVjZXJcbiAqIGNvbnN0IHJlZHVjZXJzID0gY29tYmluZVJlZHVjZXJzKHtcbiAqICBrZXBsZXJHbDoga2VwbGVyR2xSZWR1Y2VyLFxuICogIGFwcDogYXBwUmVkdWNlclxuICogfSk7XG4gKlxuICogY29uc3QgY29tcG9zZWRSZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAqICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gKiAgICAvLyBhZGQgZGF0YSB0byBtYXAgYWZ0ZXIgcmVjZWl2aW5nIGRhdGEgZnJvbSByZW1vdGUgc291cmNlc1xuICogICAgY2FzZSAnTE9BRF9SRU1PVEVfUkVTT1VSQ0VfU1VDQ0VTUyc6XG4gKiAgICAgIHJldHVybiB7XG4gKiAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAga2VwbGVyR2w6IHtcbiAqICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLFxuICogICAgICAgICAgLy8gcGFzcyBpbiBrZXBsZXIuZ2wgaW5zdGFuY2Ugc3RhdGUgdG8gY29tYmluZWRVcGRhdGVyc1xuICogICAgICAgICAgbWFwOiAgY29tYmluZWRVcGRhdGVycy5hZGREYXRhVG9NYXBVcGRhdGVyKFxuICogICAgICAgICAgIHN0YXRlLmtlcGxlckdsLm1hcCxcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gKiAgICAgICAgICAgICAgIGRhdGFzZXRzOiBhY3Rpb24uZGF0YXNldHMsXG4gKiAgICAgICAgICAgICAgIG9wdGlvbnM6IHtyZWFkT25seTogdHJ1ZX0sXG4gKiAgICAgICAgICAgICAgIGNvbmZpZzogYWN0aW9uLmNvbmZpZ1xuICogICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgfVxuICogICAgICAgICAgKVxuICogICAgICAgIH1cbiAqICAgICAgfTtcbiAqICB9XG4gKiAgcmV0dXJuIHJlZHVjZXJzKHN0YXRlLCBhY3Rpb24pO1xuICogfTtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjb21wb3NlZFJlZHVjZXI7XG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21iaW5lZFVwZGF0ZXJzID0gbnVsbDtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5cbmV4cG9ydCBjb25zdCBpc1ZhbGlkQ29uZmlnID0gY29uZmlnID0+XG4gIGlzUGxhaW5PYmplY3QoY29uZmlnKSAmJiBpc1BsYWluT2JqZWN0KGNvbmZpZy5jb25maWcpICYmIGNvbmZpZy52ZXJzaW9uO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdEFkZERhdGFUb01hcE9wdGlvbnMgPSB7XG4gIGNlbnRlck1hcDogdHJ1ZSxcbiAga2VlcEV4aXN0aW5nQ29uZmlnOiBmYWxzZSxcbiAgYXV0b0NyZWF0ZUxheWVyczogdHJ1ZSxcbiAgYXV0b0NyZWF0ZVRvb2x0aXBzOiB0cnVlXG59O1xuXG4vKipcbiAqIENvbWJpbmUgZGF0YSBhbmQgZnVsbCBjb25maWd1cmF0aW9uIHVwZGF0ZSBpbiBhIHNpbmdsZSBhY3Rpb25cbiAqXG4gKiBAbWVtYmVyb2YgY29tYmluZWRVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGtlcGxlci5nbCBpbnN0YW5jZSBzdGF0ZSwgY29udGFpbmluZyBhbGwgc3VicmVkdWNlciBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wYXlsb2FkIGB7ZGF0YXNldHMsIG9wdGlvbnMsIGNvbmZpZ31gXG4gKiBAcGFyYW0gYWN0aW9uLnBheWxvYWQuZGF0YXNldHMgLSAqKipyZXF1aXJlZCoqIGRhdGFzZXRzIGNhbiBiZSBhIGRhdGFzZXQgb3IgYW4gYXJyYXkgb2YgZGF0YXNldHNcbiAqIEVhY2ggZGF0YXNldCBvYmplY3QgbmVlZHMgdG8gaGF2ZSBgaW5mb2AgYW5kIGBkYXRhYCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBbYWN0aW9uLnBheWxvYWQub3B0aW9uc10gb3B0aW9uIG9iamVjdCBge2NlbnRlck1hcDogdHJ1ZX1gXG4gKiBAcGFyYW0gW2FjdGlvbi5wYXlsb2FkLmNvbmZpZ10gbWFwIGNvbmZpZ1xuICogQHBhcmFtIFthY3Rpb24ucGF5bG9hZC5pbmZvXSBtYXAgaW5mbyBjb250YWlucyB0aXRsZSBhbmQgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERhdGFzZXRcbiAqIEBwcm9wZXJ0eSBpbmZvIC1pbmZvIG9mIGEgZGF0YXNldFxuICogQHByb3BlcnR5IGluZm8uaWQgLSBpZCBvZiB0aGlzIGRhdGFzZXQuIElmIGNvbmZpZyBpcyBkZWZpbmVkLCBgaWRgIHNob3VsZCBtYXRjaGVzIHRoZSBgZGF0YUlkYCBpbiBjb25maWcuXG4gKiBAcHJvcGVydHkgaW5mby5sYWJlbCAtIEEgZGlzcGxheSBuYW1lIG9mIHRoaXMgZGF0YXNldFxuICogQHByb3BlcnR5IGRhdGEgLSAqKipyZXF1aXJlZCoqIFRoZSBkYXRhIG9iamVjdCwgaW4gYSB0YWJ1bGFyIGZvcm1hdCB3aXRoIDIgcHJvcGVydGllcyBgZmllbGRzYCBhbmQgYHJvd3NgXG4gKiBAcHJvcGVydHkgZGF0YS5maWVsZHMgLSAqKipyZXF1aXJlZCoqIEFycmF5IG9mIGZpZWxkcyxcbiAqIEBwcm9wZXJ0eSBkYXRhLmZpZWxkcy5uYW1lIC0gKioqcmVxdWlyZWQqKiBOYW1lIG9mIHRoZSBmaWVsZCxcbiAqIEBwcm9wZXJ0eSBkYXRhLnJvd3MgLSAqKipyZXF1aXJlZCoqIEFycmF5IG9mIHJvd3MsIGluIGEgdGFidWxhciBmb3JtYXQgd2l0aCBgZmllbGRzYCBhbmQgYHJvd3NgXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYWRkRGF0YVRvTWFwVXBkYXRlciA9IChcbiAgc3RhdGU6IEtlcGxlckdsU3RhdGUsXG4gIHtwYXlsb2FkfToge3BheWxvYWQ6IEFkZERhdGFUb01hcFBheWxvYWR9XG4pOiBLZXBsZXJHbFN0YXRlID0+IHtcbiAgY29uc3Qge2RhdGFzZXRzLCBjb25maWcsIGluZm99ID0gcGF5bG9hZDtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRBZGREYXRhVG9NYXBPcHRpb25zLFxuICAgIC4uLnBheWxvYWQub3B0aW9uc1xuICB9O1xuXG4gIC8vIGNoZWNrIGlmIHByb2dyZXNzaXZlIGxvYWRpbmcgZGF0YXNldCBieSBiYXRjaGVzLCBhbmQgdXBkYXRlIHZpc1N0YXRlIGRpcmVjdGx5XG4gIGNvbnN0IGlzUHJvZ3Jlc3NpdmVMb2FkaW5nID1cbiAgICBBcnJheS5pc0FycmF5KGRhdGFzZXRzKSAmJlxuICAgIGRhdGFzZXRzWzBdPy5pbmZvLmZvcm1hdCA9PT0gJ2Fycm93JyAmJlxuICAgIGRhdGFzZXRzWzBdPy5pbmZvLmlkICYmXG4gICAgZGF0YXNldHNbMF0/LmluZm8uaWQgaW4gc3RhdGUudmlzU3RhdGUuZGF0YXNldHM7XG4gIGlmIChpc1Byb2dyZXNzaXZlTG9hZGluZykge1xuICAgIHJldHVybiBjb21wb3NlXzxLZXBsZXJHbFN0YXRlPihbXG4gICAgICBwaWNrXygndmlzU3RhdGUnKShcbiAgICAgICAgYXBwbHlfPFZpc1N0YXRlLCBhbnk+KHZpc1N0YXRlVXBkYXRlVmlzRGF0YVVwZGF0ZXIsIHtcbiAgICAgICAgICBkYXRhc2V0cyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGNvbmZpZ1xuICAgICAgICB9KVxuICAgICAgKVxuICAgIF0pKHN0YXRlKTtcbiAgfVxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgbGV0IHBhcnNlZENvbmZpZzogUGFyc2VkQ29uZmlnID0gY29uZmlnO1xuXG4gIGlmIChpc1ZhbGlkQ29uZmlnKGNvbmZpZykpIHtcbiAgICAvLyBpZiBwYXNzZWQgaW4gc2F2ZWQgY29uZmlnXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHBhcnNlZENvbmZpZyA9IHN0YXRlLnZpc1N0YXRlLnNjaGVtYS5wYXJzZVNhdmVkQ29uZmlnKGNvbmZpZyk7XG4gIH1cbiAgY29uc3Qgb2xkTGF5ZXJzID0gc3RhdGUudmlzU3RhdGUubGF5ZXJzO1xuICBjb25zdCBmaWx0ZXJOZXdseUFkZGVkTGF5ZXJzID0gKGxheWVyczogTGF5ZXJbXSkgPT5cbiAgICBsYXllcnMuZmlsdGVyKG5sID0+ICFvbGRMYXllcnMuZmluZChvbCA9PiBvbCA9PT0gbmwpKTtcblxuICAvLyBSZXR1cm5zIHVuZGVmaW5lZCBpZiBub3QgZm91bmQsIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweVxuICBjb25zdCBmaW5kTWFwQm91bmRzSWZDZW50ZXJlZCA9IChsYXllcnM6IExheWVyW10pID0+IHtcbiAgICBjb25zdCBib3VuZHMgPSBvcHRpb25zLmNlbnRlck1hcCAmJiBmaW5kTWFwQm91bmRzKGxheWVycyk7XG4gICAgcmV0dXJuIGJvdW5kcyA/IGJvdW5kcyA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICByZXR1cm4gY29tcG9zZV88S2VwbGVyR2xTdGF0ZT4oW1xuICAgIHBpY2tfKCd2aXNTdGF0ZScpKFxuICAgICAgLy8gdGhpcyBwYXJ0IGNhbiBiZSBhc3luY1xuICAgICAgYXBwbHlfPFZpc1N0YXRlLCBhbnk+KHZpc1N0YXRlVXBkYXRlVmlzRGF0YVVwZGF0ZXIsIHtcbiAgICAgICAgZGF0YXNldHMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGNvbmZpZzogcGFyc2VkQ29uZmlnXG4gICAgICB9KVxuICAgICksXG5cbiAgICBpZl8oQm9vbGVhbihpbmZvKSwgcGlja18oJ3Zpc1N0YXRlJykoYXBwbHlfPFZpc1N0YXRlLCBhbnk+KHNldE1hcEluZm9VcGRhdGVyLCB7aW5mb30pKSksXG4gICAgLy8gTm90ZSB0aGF0IGZpdCBib3VuZHMgaGVyZSB3b24ndCBiZSBjYWxsZWQgaW4gY2FzZSBkYXRhc2V0cyBhcmUgY3JlYXRlZCBpbiBUYXNrcy5cbiAgICAvLyBBIHNlcGFyYXRlIFRhc2sgdG8gdXBkYXRlIGJvdW5kcyBpcyBjcmVhdGVkIG9uY2UgdGhlIGRhdGFzZXRzIGFyZSByZWFkeS5cbiAgICB3aXRoXygoe3Zpc1N0YXRlfSkgPT5cbiAgICAgIHBpY2tfKCdtYXBTdGF0ZScpKFxuICAgICAgICBhcHBseV8oXG4gICAgICAgICAgc3RhdGVNYXBDb25maWdVcGRhdGVyLFxuICAgICAgICAgIHBheWxvYWRfKHtcbiAgICAgICAgICAgIGNvbmZpZzogcGFyc2VkQ29uZmlnLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGJvdW5kczogZmluZE1hcEJvdW5kc0lmQ2VudGVyZWQoZmlsdGVyTmV3bHlBZGRlZExheWVycyh2aXNTdGF0ZS5sYXllcnMpKVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIHBpY2tfKCdtYXBTdHlsZScpKGFwcGx5XyhzdHlsZU1hcENvbmZpZ1VwZGF0ZXIsIHBheWxvYWRfKHtjb25maWc6IHBhcnNlZENvbmZpZywgb3B0aW9uc30pKSksXG4gICAgcGlja18oJ3VpU3RhdGUnKShhcHBseV8odWlTdGF0ZUxvYWRGaWxlc1N1Y2Nlc3NVcGRhdGVyLCBwYXlsb2FkXyhudWxsKSkpLFxuXG4gICAgaWZfKFxuICAgICAgQm9vbGVhbihwYXJzZWRDb25maWc/LnVpU3RhdGU/Lm1hcENvbnRyb2xzPy5tYXBMZWdlbmQ/LmFjdGl2ZSksXG4gICAgICBwaWNrXygndWlTdGF0ZScpKFxuICAgICAgICBhcHBseV8odWlTdGF0ZVRvZ2dsZU1hcENvbnRyb2xVcGRhdGVyLCBwYXlsb2FkXyh7cGFuZWxJZDogJ21hcExlZ2VuZCcsIGluZGV4OiAwfSkpXG4gICAgICApXG4gICAgKSxcblxuICAgIGlmXyhcbiAgICAgIEJvb2xlYW4ocGFyc2VkQ29uZmlnPy51aVN0YXRlPy5tYXBDb250cm9scz8ubWFwTGVnZW5kPy5zZXR0aW5ncyksXG4gICAgICBwaWNrXygndWlTdGF0ZScpKFxuICAgICAgICBhcHBseV8oXG4gICAgICAgICAgdWlTdGF0ZVNldE1hcENvbnRyb2xTZXR0aW5nc1VwZGF0ZXIsXG4gICAgICAgICAgcGF5bG9hZF8oe1xuICAgICAgICAgICAgcGFuZWxJZDogJ21hcExlZ2VuZCcsXG4gICAgICAgICAgICBzZXR0aW5nczogcGFyc2VkQ29uZmlnPy51aVN0YXRlPy5tYXBDb250cm9scz8ubWFwTGVnZW5kPy5zZXR0aW5ncyA/PyB7fVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIHBpY2tfKCd1aVN0YXRlJykoYXBwbHlfKHRvZ2dsZU1vZGFsVXBkYXRlciwgcGF5bG9hZF8obnVsbCkpKSxcbiAgICBwaWNrXygndWlTdGF0ZScpKFxuICAgICAgbWVyZ2VfKFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3JlYWRPbmx5JylcbiAgICAgICAgICA/IHtyZWFkT25seTogb3B0aW9ucy5yZWFkT25seX1cbiAgICAgICAgICA6IHt9XG4gICAgICApXG4gICAgKVxuICBdKShzdGF0ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgbG9hZEZpbGVzU3VjY2Vzc1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBLZXBsZXJHbFN0YXRlLFxuICBhY3Rpb246IGxvYWRGaWxlc1N1Y2Nlc3NVcGRhdGVyQWN0aW9uXG4pOiBLZXBsZXJHbFN0YXRlID0+IHtcbiAgLy8gc3RpbGwgbW9yZSB0byBsb2FkXG4gIGNvbnN0IHBheWxvYWRzID0gZmlsZXNUb0RhdGFQYXlsb2FkKGFjdGlvbi5yZXN1bHQpO1xuICBjb25zdCBuZXh0U3RhdGUgPSBjb21wb3NlXyhbXG4gICAgcGlja18oJ3Zpc1N0YXRlJykoXG4gICAgICBtZXJnZV8oe1xuICAgICAgICBmaWxlTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGZpbGVMb2FkaW5nUHJvZ3Jlc3M6IHt9XG4gICAgICB9KVxuICAgIClcbiAgXSkoc3RhdGUpO1xuICAvLyBtYWtlIG11bHRpcGxlIGFkZCBkYXRhIHRvIG1hcCBjYWxsc1xuICBjb25zdCBzdGF0ZVdpdGhEYXRhID0gY29tcG9zZV8ocGF5bG9hZHMubWFwKHAgPT4gYXBwbHlfKGFkZERhdGFUb01hcFVwZGF0ZXIsIHBheWxvYWRfKHApKSkpKFxuICAgIG5leHRTdGF0ZVxuICApO1xuICByZXR1cm4gc3RhdGVXaXRoRGF0YSBhcyBLZXBsZXJHbFN0YXRlO1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZERhdGFUb01hcENvbXBvc2VkID0gYWRkRGF0YVRvTWFwVXBkYXRlcjtcblxuLyoqXG4gKiBIZWxwZXIgd2hpY2ggdXBkYXRlcyBtYXAgb3ZlcmxheSBibGVuZGluZyBtb2RlIGluIHZpc1N0YXRlLFxuICogYnV0IG9ubHkgaWYgaXQncyBub3QgY3VycmVudGx5IGluIHRoZSBgbm9ybWFsYCBtb2RlLlxuICovXG5jb25zdCB1cGRhdGVPdmVybGF5QmxlbmRpbmcgPSBvdmVybGF5QmxlbmRpbmcgPT4gdmlzU3RhdGUgPT4ge1xuICBpZiAodmlzU3RhdGUub3ZlcmxheUJsZW5kaW5nICE9PSBPVkVSTEFZX0JMRU5ESU5HUy5ub3JtYWwudmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udmlzU3RhdGUsXG4gICAgICBvdmVybGF5QmxlbmRpbmdcbiAgICB9O1xuICB9XG4gIHJldHVybiB2aXNTdGF0ZTtcbn07XG5cbi8qKlxuICogSGVscGVyIHdoaWNoIHVwZGF0ZXMgYGRhcmtCYXNlTWFwRW5hYmxlZGAgaW4gYWxsIHRoZSBsYXllcnMgaW4gdmlzU3RhdGUgd2hpY2hcbiAqIGhhdmUgdGhpcyBjb25maWcgc2V0dGluZyAob3IgaW4gb25lIHNwZWNpZmljIGxheWVyIGlmIHRoZSBgbGF5ZXJJZGAgcGFyYW0gaXMgcHJvdmlkZWQpLlxuICovXG5jb25zdCB1cGRhdGVEYXJrQmFzZU1hcExheWVycyA9XG4gIChkYXJrQmFzZU1hcEVuYWJsZWQ6IGJvb2xlYW4sIGxheWVySWQ6IHN0cmluZyB8IG51bGwgPSBudWxsKSA9PlxuICB2aXNTdGF0ZSA9PiAoe1xuICAgIC4uLnZpc1N0YXRlLFxuICAgIGxheWVyczogdmlzU3RhdGUubGF5ZXJzLm1hcChsYXllciA9PiB7XG4gICAgICBpZiAoIWxheWVySWQgfHwgbGF5ZXIuaWQgPT09IGxheWVySWQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsYXllci52aXNDb25maWdTZXR0aW5ncywgJ2RhcmtCYXNlTWFwRW5hYmxlZCcpKSB7XG4gICAgICAgICAgY29uc3Qge3Zpc0NvbmZpZ30gPSBsYXllci5jb25maWc7XG4gICAgICAgICAgcmV0dXJuIGxheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICAgICAgICAgIHZpc0NvbmZpZzogey4uLnZpc0NvbmZpZywgZGFya0Jhc2VNYXBFbmFibGVkfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfSlcbiAgfSk7XG5cbi8qKlxuICogVXBkYXRlciB0aGF0IGNoYW5nZXMgdGhlIG1hcCBzdHlsZSBieSBjYWxsaW5nIG1hcFN0eWxlQ2hhbmdlVXBkYXRlciBvbiB2aXNTdGF0ZS5cbiAqIEluIGFkZGl0aW9uIHRvIHRoYXQsIGl0IGRvZXMgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAgIDEuIFVwZGF0ZSBtYXAgb3ZlcmxheSBibGVuZGluZyBtb2RlIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgY29sb3JNb2RlIG9mIHRoZVxuICogICAgICBiYXNlIG1hcCwgYnV0IG9ubHkgaWYgaXQncyBub3QgaW4gdGhlIGBub3JtYWxgIG1vZGUuXG4gKlxuICogICAyLiBVcGRhdGUgYWxsIHRoZSBsYXllcnMgd2hpY2ggaGF2ZSB0aGUgYGRhcmtCYXNlTWFwRW5hYmxlZGAgY29uZmlnIHNldHRpbmdcbiAqICAgICAgYWRqdXN0aW5nIGl0IGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgY29sb3JNb2RlIG9mIHRoZSBiYXNlIG1hcC5cbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBjb21iaW5lZE1hcFN0eWxlQ2hhbmdlVXBkYXRlciA9IChcbiAgc3RhdGU6IEtlcGxlckdsU3RhdGUsXG4gIGFjdGlvbjogTWFwU3R5bGVDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBLZXBsZXJHbFN0YXRlID0+IHtcbiAgY29uc3Qge3BheWxvYWR9ID0gYWN0aW9uO1xuICBjb25zdCB7bWFwU3R5bGV9ID0gc3RhdGU7XG4gIGNvbnN0IGdldENvbG9yTW9kZSA9IGtleSA9PiBtYXBTdHlsZS5tYXBTdHlsZXNba2V5XT8uY29sb3JNb2RlO1xuICBjb25zdCBwcmV2Q29sb3JNb2RlID0gZ2V0Q29sb3JNb2RlKG1hcFN0eWxlLnN0eWxlVHlwZSk7XG4gIGNvbnN0IG5leHRDb2xvck1vZGUgPSBnZXRDb2xvck1vZGUocGF5bG9hZC5zdHlsZVR5cGUpO1xuICBsZXQge3Zpc1N0YXRlfSA9IHN0YXRlO1xuICBpZiAobmV4dENvbG9yTW9kZSAhPT0gcHJldkNvbG9yTW9kZSkge1xuICAgIHN3aXRjaCAobmV4dENvbG9yTW9kZSkge1xuICAgICAgY2FzZSBCQVNFX01BUF9DT0xPUl9NT0RFUy5EQVJLOlxuICAgICAgICB2aXNTdGF0ZSA9IGNvbXBvc2VfKFtcbiAgICAgICAgICB1cGRhdGVPdmVybGF5QmxlbmRpbmcoT1ZFUkxBWV9CTEVORElOR1Muc2NyZWVuLnZhbHVlKSxcbiAgICAgICAgICB1cGRhdGVEYXJrQmFzZU1hcExheWVycyh0cnVlKVxuICAgICAgICBdKSh2aXNTdGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCQVNFX01BUF9DT0xPUl9NT0RFUy5MSUdIVDpcbiAgICAgICAgdmlzU3RhdGUgPSBjb21wb3NlXyhbXG4gICAgICAgICAgdXBkYXRlT3ZlcmxheUJsZW5kaW5nKE9WRVJMQVlfQkxFTkRJTkdTLmRhcmtlbi52YWx1ZSksXG4gICAgICAgICAgdXBkYXRlRGFya0Jhc2VNYXBMYXllcnMoZmFsc2UpXG4gICAgICAgIF0pKHZpc1N0YXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIHZpc1N0YXRlLFxuICAgIG1hcFN0eWxlOiBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIobWFwU3R5bGUsIHtwYXlsb2FkOiB7Li4ucGF5bG9hZH19KVxuICB9O1xufTtcblxuLyoqXG4gKiBVcGRhdGVyIHRoYXQgY2hhbmdlcyB0aGUgbGF5ZXIgdHlwZSBieSBjYWxsaW5nIGBsYXllclR5cGVDaGFuZ2VVcGRhdGVyYCBvbiB2aXNTdGF0ZS5cbiAqIEluIGFkZGl0aW9uIHRvIHRoYXQsIGlmIHRoZSBuZXcgbGF5ZXIgdHlwZSBoYXMgdGhlIGBkYXJrQmFzZU1hcEVuYWJsZWRgIGNvbmZpZ1xuICogc2V0dGluZywgd2UgYWRqdXN0IGl0IGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgY29sb3JNb2RlIG9mIHRoZSBiYXNlIG1hcC5zXG4gKi9cbmV4cG9ydCBjb25zdCBjb21iaW5lZExheWVyVHlwZUNoYW5nZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBLZXBsZXJHbFN0YXRlLFxuICBhY3Rpb246IExheWVyVHlwZUNoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IEtlcGxlckdsU3RhdGUgPT4ge1xuICBsZXQge3Zpc1N0YXRlfSA9IHN0YXRlO1xuICBjb25zdCBvbGRMYXllckluZGV4ID0gdmlzU3RhdGUubGF5ZXJzLmZpbmRJbmRleChsYXllciA9PiBsYXllciA9PT0gYWN0aW9uLm9sZExheWVyKTtcbiAgdmlzU3RhdGUgPSBsYXllclR5cGVDaGFuZ2VVcGRhdGVyKHZpc1N0YXRlLCBhY3Rpb24pO1xuICBjb25zdCBuZXdMYXllciA9IHZpc1N0YXRlLmxheWVyc1tvbGRMYXllckluZGV4XTtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXdMYXllcj8udmlzQ29uZmlnU2V0dGluZ3MsICdkYXJrQmFzZU1hcEVuYWJsZWQnKSkge1xuICAgIGNvbnN0IHttYXBTdHlsZX0gPSBzdGF0ZTtcbiAgICBjb25zdCB7Y29sb3JNb2RlfSA9IG1hcFN0eWxlLm1hcFN0eWxlc1ttYXBTdHlsZS5zdHlsZVR5cGVdO1xuICAgIGNvbnN0IHtkYXJrQmFzZU1hcEVuYWJsZWR9ID0gbmV3TGF5ZXIuY29uZmlnLnZpc0NvbmZpZztcbiAgICBzd2l0Y2ggKGNvbG9yTW9kZSkge1xuICAgICAgY2FzZSBCQVNFX01BUF9DT0xPUl9NT0RFUy5EQVJLOlxuICAgICAgICBpZiAoIWRhcmtCYXNlTWFwRW5hYmxlZCkge1xuICAgICAgICAgIHZpc1N0YXRlID0gdXBkYXRlRGFya0Jhc2VNYXBMYXllcnModHJ1ZSwgbmV3TGF5ZXIuaWQpKHZpc1N0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQkFTRV9NQVBfQ09MT1JfTU9ERVMuTElHSFQ6XG4gICAgICAgIGlmIChkYXJrQmFzZU1hcEVuYWJsZWQpIHtcbiAgICAgICAgICB2aXNTdGF0ZSA9IHVwZGF0ZURhcmtCYXNlTWFwTGF5ZXJzKGZhbHNlLCBuZXdMYXllci5pZCkodmlzU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICB2aXNTdGF0ZVxuICB9O1xufTtcblxuLyoqXG4gKiBNYWtlIG1hcExlZ2VuZCBhY3RpdmUgd2hlbiB0b2dnbGVTcGxpdE1hcCBhY3Rpb24gaXMgY2FsbGVkXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVTcGxpdE1hcFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBLZXBsZXJHbFN0YXRlLFxuICBhY3Rpb246IFRvZ2dsZVNwbGl0TWFwVXBkYXRlckFjdGlvblxuKTogS2VwbGVyR2xTdGF0ZSA9PiB7XG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIHZpc1N0YXRlOiB2aXNTdGF0ZVRvZ2dsZVNwbGl0TWFwVXBkYXRlcihzdGF0ZS52aXNTdGF0ZSwgYWN0aW9uKSxcbiAgICB1aVN0YXRlOiB1aVN0YXRlVG9nZ2xlU3BsaXRNYXBVcGRhdGVyKHN0YXRlLnVpU3RhdGUpLFxuICAgIG1hcFN0YXRlOiBtYXBTdGF0ZVRvZ2dsZVNwbGl0TWFwVXBkYXRlcihzdGF0ZS5tYXBTdGF0ZSlcbiAgfTtcblxuICBjb25zdCBpc1NwbGl0ID0gbmV3U3RhdGUudmlzU3RhdGUuc3BsaXRNYXBzLmxlbmd0aCAhPT0gMDtcbiAgY29uc3QgaXNMZWdlbmRBY3RpdmUgPSBuZXdTdGF0ZS51aVN0YXRlLm1hcENvbnRyb2xzPy5tYXBMZWdlbmQ/LmFjdGl2ZTtcbiAgaWYgKGlzU3BsaXQgJiYgIWlzTGVnZW5kQWN0aXZlKSB7XG4gICAgbmV3U3RhdGUudWlTdGF0ZSA9IHRvZ2dsZU1hcENvbnRyb2xVcGRhdGVyKG5ld1N0YXRlLnVpU3RhdGUsIHtcbiAgICAgIHBheWxvYWQ6IHtwYW5lbElkOiAnbWFwTGVnZW5kJywgaW5kZXg6IGFjdGlvbi5wYXlsb2FkfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufTtcblxuY29uc3QgZGVmYXVsdFJlcGxhY2VEYXRhVG9NYXBPcHRpb25zID0ge1xuICBrZWVwRXhpc3RpbmdDb25maWc6IHRydWUsXG4gIGNlbnRlck1hcDogdHJ1ZSxcbiAgYXV0b0NyZWF0ZUxheWVyczogZmFsc2Vcbn07XG5cbi8qKlxuICogVXBkYXRlciByZXBsYWNlIGEgZGF0YXNldCBpbiBzdGF0ZVxuICovXG5leHBvcnQgY29uc3QgcmVwbGFjZURhdGFJbk1hcFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBLZXBsZXJHbFN0YXRlLFxuICB7cGF5bG9hZH06IHtwYXlsb2FkOiBSZXBsYWNlRGF0YUluTWFwUGF5bG9hZH1cbik6IEtlcGxlckdsU3RhdGUgPT4ge1xuICBjb25zdCB7ZGF0YXNldFRvUmVwbGFjZUlkLCBkYXRhc2V0VG9Vc2UsIG9wdGlvbnMgPSB7fX0gPSBwYXlsb2FkO1xuICBjb25zdCBhZGREYXRhVG9NYXBPcHRpb25zID0gey4uLmRlZmF1bHRSZXBsYWNlRGF0YVRvTWFwT3B0aW9ucywgLi4ub3B0aW9uc307XG5cbiAgLy8gY2hlY2sgaWYgZGF0YXNldCBpcyB0aGVyZVxuICBpZiAoIXN0YXRlLnZpc1N0YXRlLmRhdGFzZXRzW2RhdGFzZXRUb1JlcGxhY2VJZF0pIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgLy8gZGF0YXNldFRvVXNlIGlzIFByb3RvRGF0YXNldFxuICBjb25zdCBkYXRhSWRUb1VzZSA9IGRhdGFzZXRUb1VzZS5pbmZvLmlkO1xuICBpZiAoIWRhdGFJZFRvVXNlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIC8vIHJlbW92ZSBkYXRhc2V0IGFuZCBwdXQgZGVwZW5kZW5jaWVzIGluIHRvQmVNZXJnZWRcbiAgY29uc3QgcHJlcGFyZWRTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICB2aXNTdGF0ZTogcHJlcGFyZVN0YXRlRm9yRGF0YXNldFJlcGxhY2Uoc3RhdGUudmlzU3RhdGUsIGRhdGFzZXRUb1JlcGxhY2VJZCwgZGF0YUlkVG9Vc2UpXG4gIH07XG5cbiAgY29uc3QgbmV4dFN0YXRlID0gYWRkRGF0YVRvTWFwVXBkYXRlcihcbiAgICBwcmVwYXJlZFN0YXRlLFxuICAgIHBheWxvYWRfKHtcbiAgICAgIGRhdGFzZXRzOiBkYXRhc2V0VG9Vc2UsXG4gICAgICAvLyBzaG91bGQgem9vbSB0byBuZXcgZGF0YXNldFxuICAgICAgb3B0aW9uczogYWRkRGF0YVRvTWFwT3B0aW9uc1xuICAgIH0pXG4gICk7XG5cbiAgcmV0dXJuIG5leHRTdGF0ZTtcbn07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBR0EsSUFBQUEsZ0JBQUEsR0FBQUMsT0FBQTtBQVFBLElBQUFDLGlCQUFBLEdBQUFELE9BQUE7QUFPQSxJQUFBRSxpQkFBQSxHQUFBRixPQUFBO0FBSUEsSUFBQUcsaUJBQUEsR0FBQUgsT0FBQTtBQUlBLElBQUFJLFdBQUEsR0FBQUosT0FBQTtBQUNBLElBQUFLLGdCQUFBLEdBQUFMLE9BQUE7QUFhQSxJQUFBTSxNQUFBLEdBQUFOLE9BQUE7QUFDQSxJQUFBTyxVQUFBLEdBQUFQLE9BQUE7QUFDQSxJQUFBUSxVQUFBLEdBQUFSLE9BQUE7QUFBNkUsU0FBQVMsUUFBQUMsQ0FBQSxFQUFBQyxDQUFBO0VBQUEsSUFBQUMsQ0FBQSxHQUFBQyxNQUFBLENBQUFDLElBQUEsQ0FBQUosQ0FBQTtFQUFBLElBQUFHLE1BQUEsQ0FBQUUscUJBQUE7SUFBQSxJQUFBQyxDQUFBLEdBQUFILE1BQUEsQ0FBQUUscUJBQUEsQ0FBQUwsQ0FBQTtJQUFBQyxDQUFBLEtBQUFLLENBQUEsR0FBQUEsQ0FBQSxDQUFBQyxNQUFBLFdBQUFOLENBQUE7TUFBQSxPQUFBRSxNQUFBLENBQUFLLHdCQUFBLENBQUFSLENBQUEsRUFBQUMsQ0FBQSxFQUFBUSxVQUFBO0lBQUEsS0FBQVAsQ0FBQSxDQUFBUSxJQUFBLENBQUFDLEtBQUEsQ0FBQVQsQ0FBQSxFQUFBSSxDQUFBO0VBQUE7RUFBQSxPQUFBSixDQUFBO0FBQUE7QUFBQSxTQUFBVSxjQUFBWixDQUFBO0VBQUEsU0FBQUMsQ0FBQSxNQUFBQSxDQUFBLEdBQUFZLFNBQUEsQ0FBQUMsTUFBQSxFQUFBYixDQUFBO0lBQUEsSUFBQUMsQ0FBQSxX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