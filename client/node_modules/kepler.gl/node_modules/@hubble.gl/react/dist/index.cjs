var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  BasicControls: () => BasicControls,
  EncoderDropdown: () => EncoderDropdown,
  ExportVideoModal: () => export_video_modal_default,
  ExportVideoPanelContainer: () => ExportVideoPanelContainer,
  InjectKeplerUI: () => InjectKeplerUI,
  KeplerUIContext: () => KeplerUIContext,
  QuickAnimation: () => QuickAnimation,
  RenderPlayer: () => RenderPlayer,
  ResolutionGuide: () => ResolutionGuide,
  WithKeplerUI: () => WithKeplerUI,
  createKeplerLayers: () => createKeplerLayers,
  injectKeplerUI: () => injectKeplerUI,
  useDeckAdapter: () => useDeckAdapter,
  useDeckAnimation: () => useDeckAnimation,
  useHubbleGl: () => useHubbleGl,
  useNextFrame: () => useNextFrame
});
module.exports = __toCommonJS(dist_exports);

// dist/components/basic-controls.js
var import_react8 = __toESM(require("react"), 1);

// dist/components/encoder-dropdown.js
var import_react2 = __toESM(require("react"), 1);

// dist/components/input.js
var import_react = __toESM(require("react"), 1);
var import_styled_components = __toESM(require("styled-components"), 1);
var InputContainer = import_styled_components.default.div`
  position: relative;
  width: 100%;
  font:
    14px / 20px Helvetica,
    Arial,
    sans-serif;
  box-sizing: border-box;

  &:last-child {
    margin-bottom: 20px;
  }

  > * {
    vertical-align: middle;
    white-space: nowrap;
  }
  label {
    display: inline-block;
    width: 40%;
    margin-right: 10%;
    margin-top: 2px;
    margin-bottom: 2px;
  }
  input,
  a,
  button,
  select {
    background: #fff;
    font-size: 0.9em;
    text-transform: none;
    text-overflow: ellipsis;
    overflow: hidden;
    display: inline-block;
    padding: 0 4px;
    margin: 0;
    width: 50%;
    height: 20px;
    line-height: 1.833;
    text-align: left;
  }
  button {
    color: initial;
  }
  button:disabled {
    color: #aaa;
    cursor: default;
    background: #eee;
  }
  input {
    border: solid 1px #ccc;

    &:disabled {
      background: #eee;
    }
    &[type='checkbox'] {
      height: auto;
    }
  }

  .tooltip {
    left: 50%;
    top: 24px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 200ms;
  }
  &:hover .tooltip {
    opacity: 1;
  }
`;
var GenericInput = class extends import_react.PureComponent {
  _onChange(evt) {
    const { value, type } = evt.target;
    let newValue = value;
    if (type === "checkbox") {
      newValue = evt.target.checked;
    }
    if (type === "range") {
      newValue = Number(value);
      if (this.props.min !== void 0) {
        newValue = Math.max(this.props.min, newValue);
      }
      if (this.props.max !== void 0) {
        newValue = Math.min(this.props.max, newValue);
      }
    }
    this.props.onChange(this.props.name, newValue);
  }
  _resetFunction() {
    return this.props.onChange(this.props.name, this.props.altValue);
  }
  render() {
    const { displayName, type, displayValue, disabled } = this.props;
    const props = { ...this.props };
    delete props.displayName;
    delete props.displayValue;
    delete props.altType;
    delete props.altValue;
    if (type === "link") {
      return import_react.default.createElement(
        "div",
        { className: "input" },
        import_react.default.createElement("label", null, displayName),
        import_react.default.createElement("a", { href: displayValue, target: "_new" }, displayValue)
      );
    }
    if (type === "function" || type === "json") {
      const editable = "altValue" in this.props;
      return import_react.default.createElement(
        "div",
        { className: "input" },
        import_react.default.createElement("label", null, displayName),
        import_react.default.createElement("button", { type: "button", disabled: !editable || disabled, onClick: this._resetFunction.bind(this) }, displayValue)
      );
    }
    if (type === "select") {
      return import_react.default.createElement(
        InputContainer,
        null,
        import_react.default.createElement(
          "div",
          { className: "input" },
          import_react.default.createElement("label", null, displayName),
          import_react.default.createElement("select", { disabled, onChange: this._onChange.bind(this), value: displayValue }, props.options.map((value, i) => import_react.default.createElement("option", { key: i, value }, value)))
        )
      );
    }
    if (type === "checkbox") {
      props.checked = props.value;
    }
    return import_react.default.createElement(
      InputContainer,
      null,
      import_react.default.createElement("label", null, displayName),
      import_react.default.createElement(
        "div",
        { className: "tooltip" },
        displayName,
        ": ",
        String(displayValue)
      ),
      import_react.default.createElement("input", { ...props, value: displayValue, onChange: this._onChange.bind(this) })
    );
  }
};

// dist/components/encoders.js
var import_core = require("@hubble.gl/core");
var PREVIEW = "Preview";
var WEBM = "WebM";
var JPEG = "JPEG Frames";
var PNG = "PNG Frames";
var GIF = "GIF";
var ENCODER_LIST = [PREVIEW, WEBM, JPEG, PNG, GIF];
var ENCODERS = {
  [PREVIEW]: import_core.PreviewEncoder,
  [GIF]: import_core.GifEncoder,
  [WEBM]: import_core.WebMEncoder,
  [JPEG]: import_core.JPEGSequenceEncoder,
  [PNG]: import_core.PNGSequenceEncoder
};

// dist/components/encoder-dropdown.js
function EncoderDropdown({ disabled, encoder, setEncoder }) {
  return import_react2.default.createElement(GenericInput, { type: "select", disabled, displayName: "Encoder", displayValue: encoder, onChange: (_, newValue) => setEncoder(newValue), options: ENCODER_LIST });
}

// dist/components/basic-controls.js
var import_styled_components3 = __toESM(require("styled-components"), 1);

// dist/components/icons/play.js
var import_react4 = __toESM(require("react"), 1);
var import_prop_types2 = __toESM(require("prop-types"), 1);

// dist/components/icons/base.js
var import_react3 = __toESM(require("react"), 1);
var import_prop_types = __toESM(require("prop-types"), 1);
var getStyleClassFromColor = (totalColor, colors) => new Array(totalColor).fill(1).reduce((accu, c, i) => `${accu}.cr${i + 1} {fill:${colors[i % colors.length]};}`, "");
var _Base = class extends import_react3.Component {
  render() {
    const { height, width, viewBox, style, children, predefinedClassName, className, colors, totalColor, ...props } = this.props;
    const svgHeight = height;
    const svgWidth = width || svgHeight;
    const fillStyle = Array.isArray(colors) && totalColor && getStyleClassFromColor(totalColor, colors);
    return import_react3.default.createElement(
      "svg",
      { viewBox, width: svgWidth, height: svgHeight, style, className: `${predefinedClassName} ${className}`, ...props },
      fillStyle ? import_react3.default.createElement("style", { type: "text/css" }, fillStyle) : null,
      children
    );
  }
};
var Base = _Base;
(() => {
  _Base.displayName = "Base Icon";
})();
(() => {
  _Base.propTypes = {
    /** Set the height of the icon, ex. '16px' */
    height: import_prop_types.default.string,
    /** Set the width of the icon, ex. '16px' */
    width: import_prop_types.default.string,
    /** Set the viewbox of the svg */
    viewBox: import_prop_types.default.string,
    /** Path element */
    children: import_prop_types.default.node,
    predefinedClassName: import_prop_types.default.string,
    className: import_prop_types.default.string
  };
})();
(() => {
  _Base.defaultProps = {
    height: null,
    width: null,
    viewBox: "0 0 64 64",
    predefinedClassName: "",
    className: "",
    style: {
      fill: "currentColor"
    }
  };
})();

// dist/components/icons/play.js
var _Play = class extends import_react4.Component {
  render() {
    return import_react4.default.createElement(
      Base,
      { ...this.props },
      import_react4.default.createElement("path", { fill: "none", d: "M0 0h24v24H0z" }),
      import_react4.default.createElement("path", { d: "M19.376 12.416L8.777 19.482A.5.5 0 0 1 8 19.066V4.934a.5.5 0 0 1 .777-.416l10.599 7.066a.5.5 0 0 1 0 .832z" })
    );
  }
};
var Play = _Play;
(() => {
  _Play.propTypes = {
    /** Set the height of the icon, ex. '16px' */
    height: import_prop_types2.default.string
  };
})();
(() => {
  _Play.defaultProps = {
    height: "16px",
    predefinedClassName: "data-ex-icons-play",
    viewBox: "0 0 24 24"
  };
})();

// dist/components/icons/stop.js
var import_react5 = __toESM(require("react"), 1);
var import_prop_types3 = __toESM(require("prop-types"), 1);
var _Stop = class extends import_react5.Component {
  render() {
    return import_react5.default.createElement(
      Base,
      { ...this.props },
      import_react5.default.createElement("path", { fill: "none", d: "M0 0h24v24H0z" }),
      import_react5.default.createElement("path", { d: "M6 5h12a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1z" })
    );
  }
};
var Stop = _Stop;
(() => {
  _Stop.propTypes = {
    /** Set the height of the icon, ex. '16px' */
    height: import_prop_types3.default.string
  };
})();
(() => {
  _Stop.defaultProps = {
    height: "16px",
    predefinedClassName: "data-ex-icons-stop",
    viewBox: "0 0 24 24"
  };
})();

// dist/components/icons/download-video.js
var import_react6 = __toESM(require("react"), 1);
var import_prop_types4 = __toESM(require("prop-types"), 1);
var _DownloadVideo = class extends import_react6.Component {
  render() {
    return import_react6.default.createElement(
      Base,
      { ...this.props },
      import_react6.default.createElement("path", { d: "M16 4c.552 0 1 .448 1 1v4.2l5.213-3.65c.226-.158.538-.103.697.124.058.084.09.184.09.286v12.08c0 .276-.224.5-.5.5-.103 0-.203-.032-.287-.09L17 14.8V19c0 .552-.448 1-1 1H2c-.552 0-1-.448-1-1V5c0-.552.448-1 1-1h14zm-6 4H8v4H5l4 4 4-4h-3V8z" })
    );
  }
};
var DownloadVideo = _DownloadVideo;
(() => {
  _DownloadVideo.propTypes = {
    /** Set the height of the icon, ex. '16px' */
    height: import_prop_types4.default.string
  };
})();
(() => {
  _DownloadVideo.defaultProps = {
    height: "16px",
    predefinedClassName: "data-ex-icons-download-video",
    viewBox: "0 0 24 24"
  };
})();

// dist/components/render-player.js
var import_react7 = __toESM(require("react"), 1);
var import_core2 = require("@loaders.gl/core");
var import_zip = require("@loaders.gl/zip");
var import_styled_components2 = __toESM(require("styled-components"), 1);
var parseImages = async (blob, encoder) => {
  const images = await (0, import_core2.parse)(blob, import_zip.ZipLoader);
  const imageBlobs = {};
  for (const image in images) {
    imageBlobs[image] = URL.createObjectURL(new Blob([images[image]], { type: encoder === JPEG ? "image/jpeg" : "image/png" }));
  }
  return imageBlobs;
};
var VideoPlayer = import_styled_components2.default.video`
  margin: 8px 0;
  width: 100%;
`;
var GifPlayer = import_styled_components2.default.img`
  margin: 8px 0;
  width: 100%;
`;
var ScrollBox = import_styled_components2.default.div`
  width: 500px;
  height: 400px;
  position: relative;
  overflow: auto;
  margin: 8px 0;
`;
var ImageGallery = import_styled_components2.default.div`
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
`;
var Thumbnail = import_styled_components2.default.img`
  width: 64px;
`;
function RenderPlayer({ encoder, blob }) {
  const [src, setSrc] = (0, import_react7.useState)("");
  const [gallery, setGallery] = (0, import_react7.useState)({});
  (0, import_react7.useEffect)(() => {
    setSrc("");
  }, [encoder]);
  (0, import_react7.useEffect)(() => {
    if (blob) {
      switch (encoder) {
        case GIF:
        case WEBM: {
          setSrc(URL.createObjectURL(blob));
          break;
        }
        case PNG:
        case JPEG: {
          if (blob.type === "application/zip") {
            parseImages(blob).then(setGallery);
          }
          break;
        }
        default: {
          break;
        }
      }
    } else {
      setSrc("");
      setGallery({});
    }
  }, [blob]);
  switch (encoder) {
    case WEBM: {
      return import_react7.default.createElement(VideoPlayer, { src, controls: true, autoPlay: true });
    }
    case GIF: {
      return import_react7.default.createElement(GifPlayer, { src });
    }
    case PNG:
    case JPEG: {
      return import_react7.default.createElement(
        ScrollBox,
        null,
        import_react7.default.createElement(
          "div",
          { style: { position: "absolute" } },
          import_react7.default.createElement(ImageGallery, null, Object.entries(gallery).map(([name, value]) => {
            return import_react7.default.createElement(Thumbnail, { key: name, src: value, title: name });
          }))
        )
      );
    }
    default: {
      return null;
    }
  }
}

// dist/components/basic-controls.js
var RenderResult = import_styled_components3.default.div`
  position: absolute;
  z-index: 1;
  top: 0;
  right: 0;
  background-color: #fff;
  margin: 24px;
  padding: 10px 24px;
  box-shadow: rgba(0, 0, 0, 0.16) 0px 1px 4px;
  min-width: 300px;
  max-height: calc(100% - 48px);
`;
var RenderControls = import_styled_components3.default.div``;
var ButtonGroup = import_styled_components3.default.div`
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 8px;
  justify-content: flex-end;
`;
var Result = import_styled_components3.default.div`
  display: ${(props) => props.$show ? "block" : "none"};
  max-width: 500px;
`;
var Status = import_styled_components3.default.div`
  display: flex;
  align-items: center;
`;
var H3 = import_styled_components3.default.h3`
  font-size: 16px;
  margin: 8px 0;
  font-family: Helvetica, Arial, sans-serif;
`;
var Download = import_styled_components3.default.div`
  color: blue;
  cursor: pointer;
  padding: 0 8px;
  display: ${(props) => props.$show ? "flex" : "none"};
`;
var TogglePlayer = import_styled_components3.default.div`
  font-family: Helvetica, Arial, sans-serif;
  display: inline-block;
  user-select: none;
  margin: 8px 0;
  text-decoration: underline;
  float: right;
  &:hover {
    color: blue;
  }
`;
function BasicControls({ children, adapter, busy, setBusy, formatConfigs, timecode, embed = true, filename = void 0 }) {
  const [encoder, setEncoder] = (0, import_react8.useState)(WEBM);
  const [blob, setBlob] = (0, import_react8.useState)(void 0);
  const [renderStatus, setRenderStatus] = (0, import_react8.useState)(void 0);
  const [showPlayer, setShowPlayer] = (0, import_react8.useState)(true);
  const renderText = (0, import_react8.useMemo)(() => {
    switch (renderStatus) {
      case "in-progress":
        return "Rendering animation...";
      case "saving":
        return "Processing render...";
      case "rendered":
        return "Render complete!";
      default:
        return "Renderer idle...";
    }
  }, [renderStatus]);
  (0, import_react8.useEffect)(() => {
    setBlob(void 0);
    setRenderStatus(void 0);
  }, [encoder]);
  const onSave = (0, import_react8.useCallback)((newBlob) => {
    setBlob(newBlob);
    setRenderStatus("rendered");
  }, []);
  const onRender = (0, import_react8.useCallback)(() => {
    adapter.render({
      Encoder: ENCODERS[encoder],
      formatConfigs,
      filename,
      timecode,
      onStopped: () => setRenderStatus("saving"),
      onComplete: () => setBusy(false),
      onSave: embed && onSave
    });
    setRenderStatus("in-progress");
    setBusy(true);
  }, [adapter, onSave, encoder, embed, formatConfigs, timecode, filename]);
  const onStop = (0, import_react8.useCallback)(() => {
    adapter.stop({
      onStopped: () => setRenderStatus("saving"),
      onComplete: () => setBusy(false),
      onSave: embed && onSave
    });
  }, [adapter, onSave, embed]);
  return import_react8.default.createElement(
    RenderResult,
    null,
    import_react8.default.createElement(
      "div",
      null,
      import_react8.default.createElement(
        Status,
        null,
        import_react8.default.createElement(H3, null, renderText),
        import_react8.default.createElement(
          Download,
          { "$show": Boolean(blob), title: "Download", onClick: () => {
            adapter.videoCapture.download(blob);
          } },
          import_react8.default.createElement(DownloadVideo, { height: "18px" })
        )
      ),
      import_react8.default.createElement(
        RenderControls,
        null,
        import_react8.default.createElement(EncoderDropdown, { disabled: busy, encoder, setEncoder }),
        import_react8.default.createElement(
          ButtonGroup,
          null,
          import_react8.default.createElement("button", { disabled: busy, onClick: onRender }, "Render"),
          import_react8.default.createElement("button", { disabled: !busy || renderStatus === "saving", onClick: onStop }, "Interrupt")
        )
      ),
      import_react8.default.createElement(
        Result,
        { "$show": Boolean(blob) },
        import_react8.default.createElement(TogglePlayer, { onClick: () => setShowPlayer(!showPlayer) }, showPlayer ? "Hide Player" : "Show Player"),
        showPlayer && import_react8.default.createElement(RenderPlayer, { encoder, blob })
      ),
      import_react8.default.createElement("div", { style: { marginTop: "8px" } }, children)
    )
  );
}

// dist/components/resolution-guide.js
var import_react9 = __toESM(require("react"), 1);
function ResolutionGuide() {
  return import_react9.default.createElement(
    "div",
    { style: { position: "relative" } },
    import_react9.default.createElement(Outline, { width: 2560, height: 1440, name: "2160p, 2K" }),
    import_react9.default.createElement(Outline, { width: 2560, height: 1440, name: "1440p" }),
    import_react9.default.createElement(Outline, { width: 1920, height: 1080, name: "1080p, Full HD" }),
    import_react9.default.createElement(Outline, { width: 1280, height: 720, name: "720p, HD" }),
    import_react9.default.createElement(Outline, { width: 854, height: 480, name: "480p, WSD" }),
    import_react9.default.createElement(Outline, { width: 640, height: 480, name: "480p, SD" }),
    import_react9.default.createElement(Outline, { width: 640, height: 360, name: "360p" }),
    import_react9.default.createElement(Outline, { width: 426, height: 240, name: "240p" })
  );
}
function Outline({ width, height, name }) {
  return import_react9.default.createElement(
    "div",
    { style: { position: "absolute", width, height, outline: "2px dashed black" } },
    import_react9.default.createElement(
      "div",
      { style: {
        position: "absolute",
        bottom: -20,
        right: 0,
        fontSize: "14px",
        font: "normal 14px/20px 'Uber Move',Helvetica,Arial,sans-serif"
      } },
      name,
      " (",
      width,
      " x ",
      height,
      ")"
    )
  );
}

// dist/components/export-video/export-video-modal.js
var import_react10 = __toESM(require("react"), 1);
var import_react_modal = __toESM(require("react-modal"), 1);
var import_styled_components5 = require("styled-components");

// dist/components/export-video/styled-components.js
var import_styled_components4 = __toESM(require("styled-components"), 1);

// dist/components/export-video/constants.js
var DEFAULT_ICON_BUTTON_HEIGHT = "16px";
var DEFAULT_PADDING = 32;
var DEFAULT_ROW_GAP = 24;
var DEFAULT_SETTINGS_WIDTH = 280;
var DEFAULT_FILENAME = "kepler.gl";
var DEFAULT_PREVIEW_RESOLUTIONS = { "16:9": "1280x720", "4:3": "1280x960" };
var FORMATS = [
  {
    value: "gif",
    label: "GIF"
  },
  {
    value: "webm",
    label: "WebM Video"
  },
  {
    value: "png",
    label: "PNG Sequence"
  },
  {
    value: "jpeg",
    label: "JPEG Sequence"
  }
];
var ASPECT_RATIOS = { "4_3": "4:3", "16_9": "16:9" };
var RESOLUTIONS = [
  {
    value: "960x540",
    label: "Good (540p)",
    width: 960,
    height: 540,
    aspectRatio: ASPECT_RATIOS["16_9"]
  },
  {
    value: "1280x720",
    label: "High (720p)",
    width: 1280,
    height: 720,
    aspectRatio: ASPECT_RATIOS["16_9"]
  },
  {
    value: "1920x1080",
    label: "Highest (1080p)",
    width: 1920,
    height: 1080,
    aspectRatio: ASPECT_RATIOS["16_9"]
  },
  {
    value: "640x480",
    label: "Good (480p)",
    width: 640,
    height: 480,
    aspectRatio: ASPECT_RATIOS["4_3"]
  },
  {
    value: "1280x960",
    label: "High (960p)",
    width: 1280,
    height: 960,
    aspectRatio: ASPECT_RATIOS["4_3"]
  },
  {
    value: "1920x1440",
    label: "Highest (1440p)",
    width: 1920,
    height: 1440,
    aspectRatio: ASPECT_RATIOS["4_3"]
  }
];
var isResolution = (value) => (option) => option.value === value;
function getResolutionSetting(value) {
  return RESOLUTIONS.find(isResolution(value)) || RESOLUTIONS[0];
}

// dist/components/export-video/styled-components.js
var SliderWrapper = import_styled_components4.default.div`
  display: flex;
  position: relative;
  flex-grow: 1;
  margin-right: 24px;
  margin-left: 24px;
`;
var StyledLabelCell = import_styled_components4.default.div`
  align-self: center;
  color: ${(props) => props.theme.labelColor};
  font-weight: 400;
  font-size: 11px;
`;
var StyledValueCell = import_styled_components4.default.div`
  align-self: center;
  color: ${(props) => props.theme.textColor};
  font-weight: 500;
  font-size: 11px;
  padding: 0 12px;
`;
var InputGrid = import_styled_components4.default.div`
  display: grid;
  grid-template-columns: 88px auto;
  grid-template-rows: repeat(
    ${(props) => props.$rows},
    ${(props) => props.$rowHeight ? props.$rowHeight : "34px"}
  );
  grid-row-gap: ${DEFAULT_ROW_GAP}px;
`;
var ButtonGroup2 = import_styled_components4.default.div`
  display: flex;
`;
var ModalContainer = import_styled_components4.default.div`
  position: relative;
`;
var PanelCloseInner = import_styled_components4.default.div`
  display: flex;
  justify-content: flex-end;
`;
var StyledTitle = import_styled_components4.default.div`
  color: ${(props) => props.theme.titleTextColor};
  font-size: 20px;
  font-weight: 400;
  line-height: ${(props) => props.theme.lineHeight};
  padding-bottom: 16px;
`;
var PanelBodyInner = import_styled_components4.default.div`
  display: grid;
  grid-template-columns: ${(props) => props.$exportVideoWidth}px ${DEFAULT_SETTINGS_WIDTH}px;
  grid-template-rows: auto;
  grid-column-gap: ${DEFAULT_ROW_GAP}px;
`;
var Panel = import_styled_components4.default.div`
  width: ${(props) => props.$exportVideoWidth + 2 * DEFAULT_PADDING + DEFAULT_ROW_GAP + DEFAULT_SETTINGS_WIDTH}px;
  padding: ${DEFAULT_PADDING}px;
`;
var TimelineControls = import_styled_components4.default.div`
  position: relative;
  display: flex;
  justify-content: center;
  padding-top: 16px;
`;
var timelinePlayButtonStyle = {
  cursor: "pointer",
  height: "32px",
  width: "32px",
  fill: "#FFF"
};
var LoaderWrapper = import_styled_components4.default.div`
  display: ${(props) => props.$rendering === false ? "none" : "flex"};
  position: absolute;
  background: rgba(0, 0, 0, 0.5);
  width: ${(props) => props.$width}px;
  height: ${(props) => props.$height}px;
  align-items: center;
  justify-content: center;
`;
var RenderingFeedbackContainer = import_styled_components4.default.div`
  color: white;
  position: absolute;
  top: ${(props) => props.$height - 180}px;
`;
var VideoLengthDisplay = import_styled_components4.default.div`
  align-self: center;
  padding-left: 8px;
`;
var ExportVideoPanelHeader = import_styled_components4.default.div`
  display: flex;
  justify-content: space-between;
`;
var DeckCanvas = import_styled_components4.default.div`
  width: ${(props) => props.$width}px;
  height: ${(props) => props.$height}px;
  position: relative;
`;

// dist/components/export-video/export-video-modal.js
var import_reselect = require("reselect");
var _ExportVideoModal = class extends import_react10.Component {
  constructor() {
    super(...arguments);
    this.root = (0, import_react10.createRef)();
    this.settingsPosSelector = (0, import_reselect.createSelector)(this.showSettingsSelector, this.themeSelector, (showSettings, theme = {}) => {
      const { defaultSettingsPos, bottomBuffer, settingsHeight } = this.props;
      if (showSettings === false || !this.root || !this.root.current)
        return defaultSettingsPos;
      const { sidePanelInnerPadding = 16, sidePanel = {}, sidePanelScrollBarWidth = 10 } = theme;
      const sidePanelLeft = (sidePanel.margin || {}).left || 20;
      const offsetX = sidePanelInnerPadding + sidePanelLeft + sidePanelScrollBarWidth;
      const bounding = this.root.current.getBoundingClientRect();
      const { x, y, width } = bounding;
      const top = y + settingsHeight <= window.innerHeight - bottomBuffer ? y : window.innerHeight - bottomBuffer - settingsHeight;
      return { top: `${top}px`, left: `${x + width + offsetX}px` };
    });
    this.modalStylesSelector = (0, import_reselect.createSelector)(this.themeSelector, (theme) => ({
      content: {
        top: "auto",
        left: "auto",
        right: "50%",
        bottom: "50%",
        transform: "translate(50%, 50%)",
        padding: "0px 0px 0px 0px",
        border: 0,
        backgroundColor: theme.sidePanelBg,
        borderRadius: theme.panelBorderRadius || "2px"
      },
      overlay: {
        backgroundColor: "rgba(0, 0, 0, .5)",
        zIndex: this.props.theme && this.props.theme.modalOverLayZ || 1e3
      }
    }));
  }
  // derive settings position based on root component
  showSettingsSelector(props) {
    return props.showSettings;
  }
  themeSelector(props) {
    return props.theme;
  }
  render() {
    const { isOpen, theme, children } = this.props;
    const modalStyles = this.modalStylesSelector(this.props);
    return import_react10.default.createElement(
      import_styled_components5.ThemeProvider,
      { theme },
      import_react10.default.createElement(ModalContainer, { className: "export-video-modal", ref: this.root }, this.root.current ? import_react10.default.createElement(import_react_modal.default, { isOpen, style: modalStyles, ariaHideApp: false, parentSelector: () => {
        return this.root.current || {
          removeChild: () => {
          },
          appendChild: () => {
          },
          contains: () => {
          }
        };
      } }, children) : null)
    );
  }
};
var ExportVideoModal = _ExportVideoModal;
(() => {
  _ExportVideoModal.defaultProps = {
    defaultSettingsPos: { top: "320px", left: "320px" },
    bottomBuffer: 212
  };
})();
var export_video_modal_default = ExportVideoModal;

// dist/components/export-video/export-video-panel-container.js
var import_react18 = __toESM(require("react"), 1);
var import_popmotion = require("popmotion");
var import_core4 = require("@hubble.gl/core");

// dist/components/export-video/export-video-panel.js
var import_react17 = __toESM(require("react"), 1);
var import_styled_components12 = require("styled-components");

// dist/components/export-video/export-video-panel-settings.js
var import_react14 = __toESM(require("react"), 1);
var import_styled_components9 = require("styled-components");

// dist/components/inject-kepler.js
var import_react11 = __toESM(require("react"), 1);
var KeplerUIContext = (0, import_react11.createContext)(null);
var WithKeplerUI = KeplerUIContext.Consumer;
var InjectKeplerUI = ({ children, keplerUI }) => import_react11.default.createElement(KeplerUIContext.Provider, { value: keplerUI }, children);
var injectKeplerUI = (Component8, keplerUI) => (props) => import_react11.default.createElement(
  KeplerUIContext.Provider,
  { value: keplerUI },
  import_react11.default.createElement(Component8, { ...props })
);

// dist/components/export-video/modal-tab-animation.js
var import_react12 = __toESM(require("react"), 1);

// dist/components/export-video/utils.js
var import_helpers = require("@turf/helpers");
var import_transform_translate = __toESM(require("@turf/transform-translate"), 1);
var import_core3 = require("@deck.gl/core");
function scaleToVideoExport(viewState, container) {
  const viewport = new import_core3.WebMercatorViewport(viewState);
  const nw = viewport.unproject([0, 0]);
  const se = viewport.unproject([viewport.width, viewport.height]);
  const videoViewport = new import_core3.WebMercatorViewport({
    ...viewState,
    width: container.width,
    height: container.height
  }).fitBounds([nw, se]);
  const { height, width, latitude, longitude, zoom, altitude } = videoViewport;
  return {
    height,
    width,
    latitude,
    longitude,
    pitch: viewState.pitch,
    zoom,
    bearing: viewState.bearing,
    altitude
  };
}
function parseSetCameraType(strCameraType, viewState) {
  const modifiedViewState = { ...viewState };
  const match = strCameraType.match(/\b(?!to)\b\S+\w/g);
  const turfPoint = (0, import_helpers.point)([modifiedViewState.longitude, modifiedViewState.latitude]);
  if (match[0] === "Orbit") {
    modifiedViewState.bearing = modifiedViewState.bearing + parseInt(match[1], 10);
  }
  const setChecker = /* @__PURE__ */ new Set(["East", "South", "West", "North"]);
  if (setChecker.has(match[0])) {
    if (match[0] === "East") {
      const translatedPoly = (0, import_transform_translate.default)(turfPoint, 10, 270);
      modifiedViewState.longitude = translatedPoly.geometry.coordinates[0];
    } else if (match[0] === "South") {
      const translatedPoly = (0, import_transform_translate.default)(turfPoint, 10, 0);
      modifiedViewState.latitude = translatedPoly.geometry.coordinates[1];
    } else if (match[0] === "West") {
      const translatedPoly = (0, import_transform_translate.default)(turfPoint, 10, 90);
      modifiedViewState.longitude = translatedPoly.geometry.coordinates[0];
    } else if (match[0] === "North") {
      const translatedPoly = (0, import_transform_translate.default)(turfPoint, 10, 180);
      modifiedViewState.latitude = translatedPoly.geometry.coordinates[1];
    }
  }
  if (match[0] === "Zoom") {
    if (match[1] === "In") {
      modifiedViewState.zoom = modifiedViewState.zoom + 3;
    } else if (match[1] === "Out") {
      modifiedViewState.zoom = modifiedViewState.zoom - 3;
    }
  }
  return modifiedViewState;
}
function printDuration(durationMs, showMs = false) {
  const millisecondsInt = Math.floor(durationMs % 1e3);
  const secondsInt = Math.floor(durationMs / 1e3) % 60;
  const minutesInt = Math.floor(durationMs / (1e3 * 60)) % 60;
  const hoursInt = Math.floor(durationMs / (1e3 * 60 * 60)) % 24;
  const hours = hoursInt === 0 ? "" : hoursInt < 10 ? `0${hoursInt}:` : `${hoursInt}:`;
  const minutes = minutesInt < 10 ? `0${minutesInt}` : minutesInt;
  const seconds = secondsInt < 10 ? `0${secondsInt}` : secondsInt;
  const milliseconds = showMs ? `.${millisecondsInt.toString()[0]}` : "";
  return `${hours}${minutes}:${seconds}${milliseconds}`;
}
var MB = 8 * 1024 * 1024;
var COMPRESSION_RATIO = 0.8;
var BIT_DEPTH = 6;
function estimateFileSize(frameRate, resolution, durationMs, mediaType) {
  const seconds = Math.floor(durationMs / 1e3);
  if (mediaType === "gif") {
    return `${Math.floor(resolution[0] * resolution[1] * BIT_DEPTH / MB * (frameRate * seconds) * COMPRESSION_RATIO)} MB`;
  }
  if (mediaType === "webm") {
    return `${Math.ceil(resolution[0] / 1280 * frameRate * seconds * 0.125)} MB`;
  }
  if (mediaType === "png") {
    return `${Math.floor(resolution[0] * resolution[1] * BIT_DEPTH / MB * ((frameRate + 1) * seconds) * COMPRESSION_RATIO)} MB`;
  }
  if (mediaType === "jpeg") {
    return `${Math.floor(resolution[0] * resolution[1] * BIT_DEPTH / MB * ((frameRate + 1) * seconds) * (COMPRESSION_RATIO - 0.4))} MB`;
  }
  return "Size estimation unavailable";
}

// dist/components/export-video/modal-tab-animation.js
function AnimationTab({ settings, disabled }) {
  return import_react12.default.createElement(WithKeplerUI, null, ({ Slider, ItemSelector }) => import_react12.default.createElement(
    import_react12.default.Fragment,
    null,
    import_react12.default.createElement(
      InputGrid,
      { "$rows": 5 },
      import_react12.default.createElement(StyledLabelCell, null, "Duration"),
      import_react12.default.createElement(
        StyledValueCell,
        { style: { paddingLeft: "0px", paddingRight: "0px" } },
        import_react12.default.createElement(
          SliderWrapper,
          { style: { width: "100%", marginLeft: "0px" }, className: "modal-duration__slider" },
          import_react12.default.createElement(Slider, { showValues: false, enableBarDrag: !disabled, isRanged: false, value0: 100, value1: settings.durationMs, step: 100, minValue: 100, maxValue: 1e4, style: { width: "70px" }, onSlider1Change: (val) => {
            settings.setDuration(val);
          } }),
          import_react12.default.createElement(VideoLengthDisplay, null, printDuration(settings.durationMs, true))
        )
      ),
      import_react12.default.createElement(StyledLabelCell, null, "Camera"),
      import_react12.default.createElement(ItemSelector, { selectedItems: settings.cameraPreset, options: [
        "None",
        "Orbit (90\xBA)",
        "Orbit (180\xBA)",
        "Orbit (360\xBA)",
        "Zoom Out",
        "Zoom In"
      ], multiSelect: false, searchable: false, onChange: settings.setCameraPreset, disabled })
    )
  ));
}
var modal_tab_animation_default = AnimationTab;

// dist/components/export-video/modal-tab-settings.js
var import_react13 = __toESM(require("react"), 1);
var getOptionValue = (r) => r.value;
var displayOption = (r) => r.label;
var getSelectedItems = (options, value) => options.find((o) => o.value === value);
function SettingsTab({ settings, resolution, disabled }) {
  const [aspRatio, setAspRatio] = (0, import_react13.useState)(ASPECT_RATIOS["16_9"]);
  return import_react13.default.createElement(WithKeplerUI, null, ({ Input, ItemSelector }) => import_react13.default.createElement(
    import_react13.default.Fragment,
    null,
    import_react13.default.createElement(
      InputGrid,
      { "$rows": 5 },
      import_react13.default.createElement(StyledLabelCell, null, "File Name"),
      import_react13.default.createElement(Input, { value: settings.fileName, placeholder: settings.fileNamePlaceholder, onChange: (e) => settings.setFileName(e.target.value), disabled }),
      import_react13.default.createElement(StyledLabelCell, null, "Media Type"),
      import_react13.default.createElement(ItemSelector, { selectedItems: getSelectedItems(FORMATS, settings.mediaType), options: FORMATS, getOptionValue, displayOption, multiSelect: false, searchable: false, onChange: settings.setMediaType, disabled }),
      import_react13.default.createElement(StyledLabelCell, null, "Ratio"),
      import_react13.default.createElement(ItemSelector, { selectedItems: aspRatio, options: [ASPECT_RATIOS["4_3"], ASPECT_RATIOS["16_9"]], multiSelect: false, searchable: false, onChange: (ratio) => {
        setAspRatio(ratio);
        settings.setResolution(DEFAULT_PREVIEW_RESOLUTIONS[ratio]);
      }, disabled }),
      import_react13.default.createElement(StyledLabelCell, null, "Quality"),
      import_react13.default.createElement(ItemSelector, { selectedItems: getSelectedItems(RESOLUTIONS, settings.resolution), options: RESOLUTIONS.filter((o) => o.aspectRatio === aspRatio), getOptionValue, displayOption, multiSelect: false, searchable: false, onChange: settings.setResolution, disabled }),
      import_react13.default.createElement(StyledLabelCell, null, "File Size"),
      import_react13.default.createElement(
        StyledValueCell,
        null,
        "Approx.",
        " ",
        estimateFileSize(settings.frameRate, resolution, settings.durationMs, settings.mediaType)
      )
    )
  ));
}
var modal_tab_settings_default = SettingsTab;

// dist/components/export-video/export-video-panel-settings.js
var import_lodash = __toESM(require("lodash.get"), 1);
function ExportVideoPanelSettings({ settings, resolution, disabled }) {
  const loadingMethods = [
    // Each entry creates new tabs with ModalTabsFactory
    // id: The tab id in state
    // label: What the text of the tab will be
    // elementType: The component to render
    {
      id: "export-modal-tab-animation",
      label: "exportVideoModal.animation",
      elementType: modal_tab_animation_default
    },
    {
      id: "export-modal-tab-settings",
      label: "exportVideoModal.settings",
      elementType: modal_tab_settings_default
    }
  ];
  const getDefaultMethod = (methods) => Array.isArray(methods) ? (0, import_lodash.default)(methods, [0]) : null;
  const [currentMethod, toggleMethod] = (0, import_react14.useState)(getDefaultMethod(loadingMethods));
  const ModalTab = currentMethod.elementType;
  return import_react14.default.createElement(WithKeplerUI, null, ({ ModalTabsFactory }) => {
    const ModalTabs = ModalTabsFactory();
    return import_react14.default.createElement(
      "div",
      { className: "export-video-modal-tab-container" },
      import_react14.default.createElement(ModalTabs, { currentMethod: currentMethod.id, loadingMethods, toggleMethod }),
      currentMethod && import_react14.default.createElement(
        ModalTab,
        { settings, resolution, disabled }
      )
    );
  });
}
var ThemedExportVideoPanelSettings = (0, import_styled_components9.withTheme)(ExportVideoPanelSettings);
var export_video_panel_settings_default = ThemedExportVideoPanelSettings;

// dist/components/export-video/export-video-panel-preview.js
var import_react16 = __toESM(require("react"), 1);
var import_typed = __toESM(require("@deck.gl/react/typed"), 1);
var import_react_map_gl = __toESM(require("react-map-gl"), 1);
var import_typed2 = require("@deck.gl/mapbox/typed");
var import_lodash2 = __toESM(require("lodash.isequal"), 1);

// dist/components/export-video/rendering-spinner.js
var import_react15 = __toESM(require("react"), 1);
function RenderingSpinner({ rendering, saving, width, height, adapter, durationMs }) {
  const percentRendered = Math.floor(adapter.videoCapture.timeMs / durationMs * 100).toFixed(0);
  const showRenderingPercent = adapter.videoCapture.timeMs < durationMs && adapter.enabled;
  const [message, setMessage] = (0, import_react15.useState)("Saving...");
  (0, import_react15.useEffect)(() => {
    let waitTimeout;
    if (saving) {
      waitTimeout = window.setTimeout(() => setMessage("Saving...Hang Tight."), 2e3);
    } else {
      setMessage("Saving...");
      if (waitTimeout)
        window.clearTimeout(waitTimeout);
    }
    return () => {
      if (waitTimeout)
        window.clearTimeout(waitTimeout);
    };
  }, [saving]);
  return import_react15.default.createElement(WithKeplerUI, null, ({ LoadingSpinner }) => import_react15.default.createElement(
    LoaderWrapper,
    { className: "loader-wrapper", "$width": width, "$height": height, "$rendering": rendering },
    import_react15.default.createElement(LoadingSpinner, null),
    import_react15.default.createElement(
      RenderingFeedbackContainer,
      { className: "rendering-feedback-container", "$height": height },
      showRenderingPercent && import_react15.default.createElement(
        "div",
        { className: "rendering-percent" },
        percentRendered,
        " %"
      ),
      saving && import_react15.default.createElement("div", { className: "saving-message" }, message)
    )
  ));
}

// dist/kepler-layers.js
var import_reselect2 = require("reselect");
var layersSelector = (state) => state.visState.layers;
var layerDataSelector = (state) => state.visState.layerData;
var getMapLayersFromSplitMaps = (splitMaps, mapIndex) => {
  var _a;
  return (_a = splitMaps[mapIndex || 0]) == null ? void 0 : _a.layers;
};
var splitMapSelector = (state) => state.visState.splitMaps;
var splitMapIndexSelector = (_, mapIndex) => mapIndex;
var mapLayersSelector = (0, import_reselect2.createSelector)(splitMapSelector, splitMapIndexSelector, getMapLayersFromSplitMaps);
var layersToRenderSelector = (0, import_reselect2.createSelector)(
  layersSelector,
  layerDataSelector,
  mapLayersSelector,
  // {[id]: true \ false}
  (layers, layerData, splitMapLayers) => layers.reduce((accu, layer, idx) => ({
    ...accu,
    [layer.id]: layer.config.isVisible && layer.shouldRenderLayer(layerData[idx]) && _isVisibleSplitMapLayer(layer, splitMapLayers) && layer.overlayType === "deckgl"
  }), {})
);
function _isVisibleSplitMapLayer(layer, splitMapLayers) {
  return !splitMapLayers || splitMapLayers && splitMapLayers[layer.id];
}
function _onLayerSetDomain(idx, colorDomain) {
}
function renderLayer(overlays, idx, map, viewState, isVisible, beforeId) {
  const { visState: { datasets, layers, layerData, hoverInfo, clicked, interactionConfig, animationConfig }, mapState } = map;
  const layer = layers[idx];
  const data = layerData[idx];
  const { gpuFilter } = datasets[layer.config.dataId] || {};
  const objectHovered = clicked || hoverInfo;
  const layerCallbacks = {
    onSetLayerDomain: (val) => _onLayerSetDomain(idx, val)
  };
  if (!isVisible) {
    return overlays;
  }
  const layerOverlay = layer.renderLayer({
    data,
    gpuFilter,
    idx,
    interactionConfig,
    layerCallbacks,
    mapState: { ...mapState, ...viewState },
    animationConfig,
    objectHovered
  }).map((deckLayer) => deckLayer.clone({
    pickable: false,
    // @ts-expect-error MapboxOverlay layers are extended to include beforeId
    beforeId,
    visible: true
  }));
  return overlays.concat(layerOverlay || []);
}
function createKeplerLayers(map, viewState, mapIndex = void 0, beforeId) {
  const layersToRender = layersToRenderSelector(map, mapIndex);
  const { layerOrder, layerData, layers } = map.visState;
  if (layerData && layerData.length) {
    const overlays = [...layerOrder].map((layerId) => ({ layerId, visible: layersToRender[layerId] })).reduce((overlays2, layerMeta, idx) => renderLayer(overlays2, idx, map, viewState, layerMeta.visible, beforeId), []);
    return overlays;
  }
  return [];
}

// dist/components/export-video/set-ref.js
function setRef(ref, value) {
  if (!ref)
    return;
  if (typeof ref === "function") {
    ref(value);
  } else {
    ref.current = value;
  }
}

// dist/components/export-video/export-video-panel-preview.js
var DeckGLOverlay = (0, import_react16.forwardRef)((props, ref) => {
  const deck = (0, import_react_map_gl.useControl)(() => new import_typed2.MapboxOverlay({ ...props, interleaved: true }));
  deck.setProps(props);
  setRef(ref, deck._deck);
  return null;
});
var ExportVideoPanelPreview = class extends import_react16.Component {
  constructor(props) {
    super(props);
    const mapStyle = this.props.mapData.mapStyle;
    const { url, accessToken } = mapStyle.mapStyles[mapStyle.styleType];
    this.mapRef = import_react16.default.createRef();
    this.deckRef = import_react16.default.createRef();
    this.state = {
      mapStyle: url,
      // Unsure if mapStyle would ever change but allowing it just in case
      mapboxAccessToken: accessToken,
      memoDevicePixelRatio: 1
    };
    this._onMapLoad = this._onMapLoad.bind(this);
    this._resizeVideo = this._resizeVideo.bind(this);
    this._onAfterRender = this._onAfterRender.bind(this);
    this._resizeVideo();
  }
  componentDidUpdate(prevProps) {
    if (!(0, import_lodash2.default)(prevProps.resolution, this.props.resolution)) {
      this._resizeVideo();
    }
  }
  componentWillUnmount() {
    if (this.mapRef.current) {
      const map = this.mapRef.current.getMap();
      const listeners = [...map._listeners.render];
      listeners.forEach((listener) => {
        map.off("render", listener);
      });
    }
  }
  _resizeVideo() {
    const { exportVideoWidth, resolution, disableBaseMap } = this.props;
    this._setDevicePixelRatio(resolution[0] / exportVideoWidth);
    if (disableBaseMap) {
      return;
    }
    if (this.mapRef.current) {
      const map = this.mapRef.current.getMap();
      map.resize();
    }
  }
  _setDevicePixelRatio(devicePixelRatio) {
    window.devicePixelRatio = devicePixelRatio;
  }
  _getContainer() {
    const { exportVideoWidth, resolution } = this.props;
    const aspectRatio = resolution[0] / resolution[1];
    return { height: exportVideoWidth / aspectRatio, width: exportVideoWidth };
  }
  createLayers(beforeId) {
    const { deckProps, mapData, viewState } = this.props;
    if (deckProps && deckProps.layers) {
      return deckProps.layers;
    }
    const mapIndex = 0;
    return createKeplerLayers(mapData, viewState, mapIndex, beforeId);
  }
  _onAfterRender() {
    this.props.adapter.onAfterRender(() => {
      this.forceUpdate();
    }, this.props.disableBaseMap || this.mapRef.current.getMap().areTilesLoaded());
  }
  _onMapLoad() {
    const map = this.mapRef.current.getMap();
    map.on("render", this._onAfterRender);
  }
  render() {
    const { rendering, saving, viewState, setViewState, adapter, durationMs, resolution, deckProps, mapProps, disableBaseMap, mapboxLayerBeforeId } = this.props;
    const { mapStyle, mapboxAccessToken } = this.state;
    const deck = this.deckRef.current;
    const { width, height } = this._getContainer();
    const doubleResolution = { width: resolution[0] * 2, height: resolution[1] * 2 };
    const keplerLayers = this.createLayers(mapboxLayerBeforeId);
    return import_react16.default.createElement(
      import_react16.default.Fragment,
      null,
      import_react16.default.createElement(DeckCanvas, { id: "deck-canvas", "$width": width, "$height": height }, disableBaseMap ? import_react16.default.createElement(import_typed.default, { ref: (ref) => setRef(this.deckRef, ref == null ? void 0 : ref.deck), ...adapter.getProps({ deck, extraProps: { ...deckProps, layers: keplerLayers } }), ...this._getContainer() }) : import_react16.default.createElement(
        import_react_map_gl.default,
        {
          // style={doubleResolution}
          ref: this.mapRef,
          style: { width, height },
          antialias: true,
          ...mapProps,
          ...viewState,
          mapStyle,
          mapboxAccessToken,
          onLoad: this._onMapLoad,
          onMove: (e) => setViewState(e.viewState),
          projection: { name: "mercator" }
        },
        import_react16.default.createElement(DeckGLOverlay, { ref: this.deckRef, glOptions: { stencil: true }, ...adapter.getProps({ deck, extraProps: { ...deckProps, layers: keplerLayers } }) })
      )),
      rendering && import_react16.default.createElement(RenderingSpinner, { rendering, saving, width, height, adapter, durationMs })
    );
  }
};

// dist/components/export-video/export-video-panel.js
var PanelClose = ({ handleClose }) => import_react17.default.createElement(WithKeplerUI, null, ({ IconButton, Icons }) => import_react17.default.createElement(
  PanelCloseInner,
  { className: "export-video-panel__close" },
  import_react17.default.createElement(
    IconButton,
    { style: { alignItems: "start" }, className: "export-video-panel__button", link: true, onClick: handleClose },
    import_react17.default.createElement(Icons.Delete, { height: DEFAULT_ICON_BUTTON_HEIGHT })
  )
));
var PanelBody = ({ exportVideoWidth, mapData, adapter, setViewState, settings, resolution, viewState, deckProps, mapProps, disableBaseMap, mapboxLayerBeforeId, handlePreviewVideo, handleRenderVideo, handleStop, rendering, previewing, saving }) => import_react17.default.createElement(WithKeplerUI, null, ({ Button }) => import_react17.default.createElement(
  PanelBodyInner,
  { className: "export-video-panel__body", "$exportVideoWidth": exportVideoWidth },
  import_react17.default.createElement(ExportVideoPanelPreview, { mapData, adapter, setViewState, exportVideoWidth, resolution, viewState, rendering, saving, durationMs: settings.durationMs, deckProps, mapProps, disableBaseMap, mapboxLayerBeforeId }),
  import_react17.default.createElement(export_video_panel_settings_default, { settings, resolution, disabled: rendering || previewing }),
  import_react17.default.createElement(TimelineControls, { className: "timeline-controls" }, rendering || previewing ? import_react17.default.createElement(Stop, { style: timelinePlayButtonStyle, onClick: () => handleStop({}) }) : import_react17.default.createElement(Play, { style: timelinePlayButtonStyle, onClick: handlePreviewVideo })),
  import_react17.default.createElement(
    ButtonGroup2,
    null,
    import_react17.default.createElement(Button, { style: { marginTop: "16px", width: "100%", height: "32px" }, className: "export-video-button", onClick: handleRenderVideo, disabled: rendering || previewing }, "Render")
  )
));
var ExportVideoPanel = ({
  theme,
  // UI Props
  exportVideoWidth,
  handleClose,
  header,
  // Map Props
  mapData,
  setViewState,
  mapboxLayerBeforeId,
  // Settings Props
  settings,
  // Hubble Props
  adapter,
  handlePreviewVideo,
  handleRenderVideo,
  handleStop,
  rendering,
  previewing,
  saving,
  resolution,
  viewState,
  deckProps,
  mapProps,
  disableBaseMap
}) => {
  return import_react17.default.createElement(
    Panel,
    { "$exportVideoWidth": exportVideoWidth, className: "export-video-panel" },
    header !== false ? import_react17.default.createElement(
      ExportVideoPanelHeader,
      { className: "export-video-panel__header" },
      import_react17.default.createElement(StyledTitle, { className: "export-video-panel__title" }, "Export Video"),
      import_react17.default.createElement(PanelClose, { handleClose })
    ) : null,
    import_react17.default.createElement(PanelBody, { exportVideoWidth, mapData, adapter, settings, setViewState, resolution, viewState, deckProps, mapProps, disableBaseMap, mapboxLayerBeforeId, handlePreviewVideo, handleRenderVideo, handleStop, rendering, previewing, saving })
  );
};
var ThemedExportVideoPanel = (0, import_styled_components12.withTheme)(ExportVideoPanel);
var export_video_panel_default = ThemedExportVideoPanel;

// dist/components/export-video/export-video-panel-container.js
var import_constants5 = require("@kepler.gl/constants");
var ENCODERS2 = {
  gif: import_core4.GifEncoder,
  webm: import_core4.WebMEncoder,
  jpeg: import_core4.JPEGSequenceEncoder,
  png: import_core4.PNGSequenceEncoder
};
var ExportVideoPanelContainer = class extends import_react18.Component {
  constructor(props) {
    super(props);
    this.setMediaType = this.setMediaType.bind(this);
    this.setCameraPreset = this.setCameraPreset.bind(this);
    this.setFileName = this.setFileName.bind(this);
    this.setResolution = this.setResolution.bind(this);
    this.setViewState = this.setViewState.bind(this);
    this.onPreviewVideo = this.onPreviewVideo.bind(this);
    this.onRenderVideo = this.onRenderVideo.bind(this);
    this.onStop = this.onStop.bind(this);
    this.setDuration = this.setDuration.bind(this);
    this.getCameraKeyframes = this.getCameraKeyframes.bind(this);
    this.getFilterKeyframes = this.getFilterKeyframes.bind(this);
    this.getTripKeyframes = this.getTripKeyframes.bind(this);
    const { initialState, mapData: { mapState }, glContext } = props;
    this.state = {
      mediaType: "gif",
      cameraPreset: "None",
      fileName: "",
      resolution: "1280x720",
      durationMs: 1e3,
      rendering: false,
      // Will set a spinner overlay if true
      previewing: false,
      saving: false,
      ...initialState || {}
    };
    const viewState = scaleToVideoExport(mapState, this._getContainer());
    this.state = {
      ...this.state,
      viewState,
      memo: { viewState },
      adapter: new import_core4.DeckAdapter({ glContext })
    };
  }
  componentDidMount() {
    const { onTripFrameUpdate, onFilterFrameUpdate, getTimeRangeFilterKeyframes } = this.props;
    const animation = new import_core4.KeplerAnimation({
      ...this.getFilterKeyframes(),
      ...this.getTripKeyframes(),
      cameraKeyframe: this.getCameraKeyframes(),
      onCameraFrameUpdate: this.setViewState,
      onTripFrameUpdate,
      onFilterFrameUpdate,
      getTimeRangeFilterKeyframes
    });
    this.state.adapter.animationManager.attachAnimation(animation);
  }
  componentWillUnmount() {
    this.onStop({ abort: true });
  }
  getFileName() {
    const { defaultFileName } = this.props;
    const { fileName } = this.state;
    if (fileName === "")
      return defaultFileName;
    return fileName;
  }
  getCanvasSize() {
    const { resolution } = this.state;
    const { width, height } = getResolutionSetting(resolution);
    return { width, height };
  }
  _getContainer() {
    const { width, height } = this.getCanvasSize();
    const { exportVideoWidth } = this.props;
    const aspectRatio = width / height;
    return { height: exportVideoWidth / aspectRatio, width: exportVideoWidth };
  }
  getFormatConfigs() {
    const { width, height } = this.getCanvasSize();
    return {
      webm: {
        quality: 0.8
      },
      jpeg: {
        archive: "zip",
        quality: 0.8
      },
      png: {
        archive: "zip"
      },
      gif: {
        sampleInterval: 1e3,
        width,
        height
      }
    };
  }
  getTimecode() {
    const { durationMs } = this.state;
    return {
      start: 0,
      end: durationMs,
      framerate: 30
    };
  }
  getEncoder() {
    const { mediaType } = this.state;
    return ENCODERS2[mediaType];
  }
  getCameraKeyframes() {
    const { viewState, cameraPreset, durationMs } = this.state;
    const { longitude, latitude, zoom, pitch, bearing } = viewState;
    const { width, height } = this.getCanvasSize();
    return {
      timings: [0, durationMs],
      keyframes: [
        {
          longitude,
          latitude,
          zoom,
          pitch,
          bearing
        },
        parseSetCameraType(cameraPreset, viewState)
      ],
      easings: [import_popmotion.easeInOut],
      width,
      height
    };
  }
  getFilterKeyframes() {
    const { mapData: { visState: { filters } }, animatableFilters } = this.props;
    const filterKeyframes = (Array.isArray(animatableFilters) && animatableFilters.length ? animatableFilters : (
      // only animate an enlarged time filter if animatable filters aren't specified.
      filters.filter((f) => f.type === "timeRange" && f.view === import_constants5.FILTER_VIEW_TYPES.enlarged)
    )).map((f) => ({
      id: f.id,
      timings: [0, this.state.durationMs]
    }));
    if (filterKeyframes.length) {
      return {
        filters,
        filterKeyframes
      };
    }
    return {};
  }
  getTripKeyframes() {
    const { mapData: { visState: { layers, animationConfig } } } = this.props;
    const animatableLayer = layers.filter((l) => l.config.animation && l.config.animation.enabled && l.config.isVisible);
    const readyToAnimation = Array.isArray(animationConfig.domain) && Number.isFinite(animationConfig.currentTime);
    const showAnimationControl = animatableLayer.length && readyToAnimation;
    if (showAnimationControl) {
      return {
        animationConfig,
        tripKeyframe: { timings: [0, this.state.durationMs] }
      };
    }
    return {};
  }
  setStateAndNotify(update) {
    const { props: { onSettingsChange }, state } = this;
    this.setState({ ...state, ...update });
    if (onSettingsChange) {
      const { mediaType, cameraPreset, fileName, resolution, durationMs } = state;
      onSettingsChange({
        mediaType,
        cameraPreset,
        fileName,
        resolution,
        durationMs,
        ...update
      });
    }
  }
  setMediaType(mediaType) {
    this.setStateAndNotify({ mediaType });
  }
  setCameraPreset(cameraPreset) {
    this.setStateAndNotify({ cameraPreset });
  }
  setFileName(fileName) {
    this.setStateAndNotify({ fileName });
  }
  setResolution(resolution) {
    this.setStateAndNotify({ resolution });
  }
  setViewState(viewState) {
    this.setState({ viewState });
  }
  onPreviewVideo() {
    const { adapter } = this.state;
    const filename = this.getFileName();
    const formatConfigs = this.getFormatConfigs();
    const timecode = this.getTimecode();
    this.setState({ previewing: true, memo: { viewState: { ...this.state.viewState } } });
    const onComplete = () => {
      this.setState({ previewing: false, viewState: { ...this.state.memo.viewState } });
    };
    adapter.animationManager.setKeyframes("kepler", {
      ...this.getFilterKeyframes(),
      ...this.getTripKeyframes(),
      cameraKeyframe: this.getCameraKeyframes()
    });
    adapter.render({
      Encoder: import_core4.PreviewEncoder,
      formatConfigs,
      timecode,
      filename,
      onComplete
    });
  }
  onRenderVideo() {
    const { adapter } = this.state;
    const filename = this.getFileName();
    const Encoder = this.getEncoder();
    const formatConfigs = this.getFormatConfigs();
    const timecode = this.getTimecode();
    this.setState({ rendering: true, saving: false, memo: { viewState: { ...this.state.viewState } } });
    const onComplete = () => {
      this.setState({ rendering: false, saving: false, viewState: { ...this.state.memo.viewState } });
    };
    adapter.animationManager.setKeyframes("kepler", {
      ...this.getFilterKeyframes(),
      ...this.getTripKeyframes(),
      cameraKeyframe: this.getCameraKeyframes()
    });
    adapter.render({
      Encoder,
      formatConfigs,
      timecode,
      filename,
      onStopped: () => this.setState({ saving: true }),
      onComplete
    });
  }
  onStop({ abort = false }) {
    const { adapter } = this.state;
    adapter.stop({
      abort,
      onStopped: () => this.setState({ saving: true }),
      onComplete: () => {
        this.setState({
          previewing: false,
          rendering: false,
          viewState: { ...this.state.memo.viewState }
        });
      }
    });
  }
  setDuration(durationMs) {
    this.setStateAndNotify({ durationMs });
  }
  render() {
    const { exportVideoWidth, handleClose, mapData, header, deckProps, mapProps, disableBaseMap, mapboxLayerBeforeId, defaultFileName } = this.props;
    const { adapter, durationMs, mediaType, cameraPreset, fileName, resolution, viewState, rendering, previewing, saving } = this.state;
    const timecode = this.getTimecode();
    const settings = {
      mediaType,
      setMediaType: this.setMediaType,
      cameraPreset,
      setCameraPreset: this.setCameraPreset,
      fileName,
      setFileName: this.setFileName,
      fileNamePlaceholder: defaultFileName,
      resolution,
      setResolution: this.setResolution,
      durationMs,
      setDuration: this.setDuration,
      frameRate: timecode.framerate
    };
    let canvasSize = this.getCanvasSize();
    if (previewing) {
      canvasSize = this._getContainer();
    }
    return import_react18.default.createElement(
      export_video_panel_default,
      {
        // UI Props
        exportVideoWidth,
        handleClose,
        header,
        // Map Props
        mapData,
        viewState,
        setViewState: this.setViewState,
        deckProps,
        mapProps,
        disableBaseMap,
        mapboxLayerBeforeId,
        // Settings Props
        settings,
        // Hubble Props
        adapter,
        resolution: [canvasSize.width, canvasSize.height],
        handlePreviewVideo: this.onPreviewVideo,
        handleRenderVideo: this.onRenderVideo,
        handleStop: this.onStop,
        rendering,
        previewing,
        saving
      }
    );
  }
};
ExportVideoPanelContainer.defaultProps = {
  exportVideoWidth: 540,
  header: true,
  glContext: void 0,
  deckProps: {},
  mapProps: {},
  disableStaticMap: false,
  defaultFileName: DEFAULT_FILENAME
};

// dist/components/quick-animation.js
var import_react20 = __toESM(require("react"), 1);
var import_typed3 = __toESM(require("@deck.gl/react/typed"), 1);

// dist/hooks.js
var import_react19 = require("react");
var import_core5 = require("@hubble.gl/core");
function useNextFrame() {
  const [, updateState] = (0, import_react19.useState)({});
  return (0, import_react19.useCallback)(() => updateState({}), []);
}
function useDeckAdapter(deckAnimation, initialViewState = void 0) {
  const [layers, setLayers] = (0, import_react19.useState)([]);
  const [cameraFrame, setCameraFrame] = (0, import_react19.useState)(initialViewState);
  const adapter = (0, import_react19.useMemo)(() => {
    const a = new import_core5.DeckAdapter({});
    deckAnimation.setOnLayersUpdate(setLayers);
    if (initialViewState) {
      deckAnimation.setOnCameraUpdate(setCameraFrame);
    }
    a.animationManager.attachAnimation(deckAnimation);
    deckAnimation.draw();
    return a;
  }, []);
  return { adapter, layers, cameraFrame, setCameraFrame };
}
function useDeckAnimation(params) {
  return (0, import_react19.useMemo)(() => new import_core5.DeckAnimation(params), []);
}
function useHubbleGl({ deckRef, mapRef = void 0, deckAnimation, initialViewState = void 0 }) {
  const deck = (0, import_react19.useMemo)(() => deckRef.current, [deckRef.current]);
  const nextFrame = useNextFrame();
  const { adapter, layers, cameraFrame, setCameraFrame } = useDeckAdapter(deckAnimation, initialViewState);
  const onMapLoad = (0, import_react19.useCallback)(() => {
    if (mapRef) {
      const map = mapRef.current.getMap();
      map.on("render", () => adapter.onAfterRender(nextFrame, map.areTilesLoaded()));
    }
  }, [adapter, nextFrame]);
  if (!mapRef) {
    return {
      adapter,
      cameraFrame,
      setCameraFrame,
      mapProps: {},
      deckProps: adapter.getProps({
        deck,
        onNextFrame: nextFrame,
        extraProps: {
          layers
        }
      })
    };
  }
  return {
    adapter,
    cameraFrame,
    setCameraFrame,
    onMapLoad,
    mapProps: {
      onLoad: onMapLoad,
      preventStyleDiffing: true
    },
    deckProps: adapter.getProps({
      deck,
      extraProps: {
        layers
      }
    })
  };
}

// dist/components/quick-animation.js
var QuickAnimation = ({ initialViewState, animation, timecode, resolution = { width: 640, height: 480 }, formatConfigs = {}, deckProps = {} }) => {
  const deckRef = (0, import_react20.useRef)(null);
  const deck = (0, import_react20.useMemo)(() => deckRef.current && deckRef.current.deck, [deckRef.current]);
  const [busy, setBusy] = (0, import_react20.useState)(false);
  const onNextFrame = useNextFrame();
  const { adapter, layers, cameraFrame, setCameraFrame } = useDeckAdapter(animation, initialViewState);
  const mergedFormatConfigs = {
    webm: {
      quality: 0.8
    },
    png: {
      archive: "zip"
    },
    jpeg: {
      archive: "zip",
      quality: 0.8
    },
    gif: {
      sampleInterval: 1,
      width: resolution.width,
      height: resolution.height
    },
    ...formatConfigs
  };
  const mergedTimecode = {
    framerate: 30,
    start: 0,
    ...timecode
  };
  return import_react20.default.createElement(
    import_react20.default.Fragment,
    null,
    import_react20.default.createElement(
      "div",
      { style: { position: "relative" } },
      import_react20.default.createElement(import_typed3.default, { ref: deckRef, style: { position: "unset" }, viewState: cameraFrame, onViewStateChange: ({ viewState: vs }) => {
        setCameraFrame(vs);
      }, controller: true, width: resolution.width, height: resolution.height, layers, ...adapter.getProps({ deck, onNextFrame, extraProps: deckProps }) })
    ),
    import_react20.default.createElement(BasicControls, { adapter, busy, setBusy, formatConfigs: mergedFormatConfigs, timecode: mergedTimecode })
  );
};
//# sourceMappingURL=index.cjs.map
