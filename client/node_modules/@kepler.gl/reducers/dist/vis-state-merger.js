"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VIS_STATE_MERGERS = void 0;
exports.createLayerFromConfig = createLayerFromConfig;
exports.insertLayerAtRightOrder = insertLayerAtRightOrder;
exports.isSavedLayerConfigV1 = isSavedLayerConfigV1;
exports.mergeAnimationConfig = mergeAnimationConfig;
exports.mergeDatasetsByOrder = mergeDatasetsByOrder;
exports.mergeEditor = mergeEditor;
exports.mergeEffects = mergeEffects;
exports.mergeFilters = mergeFilters;
exports.mergeInteractionTooltipConfig = mergeInteractionTooltipConfig;
exports.mergeInteractions = mergeInteractions;
exports.mergeLayerBlending = mergeLayerBlending;
exports.mergeLayers = mergeLayers;
exports.mergeOverlayBlending = mergeOverlayBlending;
exports.mergeSplitMaps = mergeSplitMaps;
exports.parseLayerConfig = parseLayerConfig;
exports.replaceFilterDatasetIds = replaceFilterDatasetIds;
exports.serializeEffect = serializeEffect;
exports.serializeFilter = serializeFilter;
exports.serializeLayer = serializeLayer;
exports.serializeVisState = serializeVisState;
exports.validateColumn = validateColumn;
exports.validateLayerWithData = validateLayerWithData;
exports.validateLayersByDatasets = validateLayersByDatasets;
exports.validateSavedLayerColumns = validateSavedLayerColumns;
exports.validateSavedTextLabel = validateSavedTextLabel;
exports.validateSavedVisualChannels = validateSavedVisualChannels;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _uniq = _interopRequireDefault(require("lodash/uniq"));
var _pick = _interopRequireDefault(require("lodash/pick"));
var _flattenDeep = _interopRequireDefault(require("lodash/flattenDeep"));
var _deepmerge = _interopRequireDefault(require("deepmerge"));
var _utils = require("@kepler.gl/utils");
var _effects = require("@kepler.gl/effects");
var _commonUtils = require("@kepler.gl/common-utils");
var _constants = require("@kepler.gl/constants");
var _schemas = require("@kepler.gl/schemas");
var _table = require("@kepler.gl/table");
var _layerUtils = require("./layer-utils");
var _excluded = ["enabled"];
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
/**
 * Merge loaded filters with current state, if no fields or data are loaded
 * save it for later
 *
 */
function mergeFilters(state, filtersToMerge, fromConfig) {
  var preserveFilterOrder = fromConfig ? filtersToMerge === null || filtersToMerge === void 0 ? void 0 : filtersToMerge.map(function (l) {
    return l.id;
  }) : state.preserveFilterOrder;
  if (!Array.isArray(filtersToMerge) || !filtersToMerge.length) {
    return state;
  }
  var _validateFiltersUpdat = (0, _utils.validateFiltersUpdateDatasets)(state, filtersToMerge),
    validated = _validateFiltersUpdat.validated,
    failed = _validateFiltersUpdat.failed,
    updatedDatasets = _validateFiltersUpdat.updatedDatasets;
  var updatedFilters = insertItemBasedOnPreservedOrder(state.filters, validated, preserveFilterOrder);

  // merge filter with existing
  updatedFilters = (0, _table.resetFilterGpuMode)(updatedFilters);
  updatedFilters = (0, _table.assignGpuChannels)(updatedFilters);
  // filter data
  var datasetsToFilter = (0, _uniq["default"])((0, _flattenDeep["default"])(validated.map(function (f) {
    return f.dataId;
  })));
  var filtered = (0, _utils.applyFiltersToDatasets)(datasetsToFilter, updatedDatasets, updatedFilters, state.layers);
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: updatedFilters,
    datasets: filtered,
    preserveFilterOrder: preserveFilterOrder,
    filterToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.filterToBeMerged), (0, _toConsumableArray2["default"])(failed))
  });
}

// replace dataId in saved Filter
function replaceFilterDatasetIds(savedFilter, dataId, dataIdToUse) {
  var replaced = [];
  savedFilter.forEach(function (filter) {
    if (filter.dataId.includes(dataId)) {
      var _filter$plotType;
      var newDataId = filter.dataId.map(function (d) {
        return d === dataId ? dataIdToUse : d;
      });
      var plotType;
      // TODO: more generic approach to save plotType.colorsByDataId
      if ((_filter$plotType = filter.plotType) !== null && _filter$plotType !== void 0 && (_filter$plotType = _filter$plotType.colorsByDataId) !== null && _filter$plotType !== void 0 && _filter$plotType[dataId]) {
        var _filter$plotType2;
        // replace colorByDataId in filter.plotType
        var _ref = ((_filter$plotType2 = filter.plotType) === null || _filter$plotType2 === void 0 ? void 0 : _filter$plotType2.colorsByDataId) || {},
          color = _ref[dataId],
          rest = (0, _objectWithoutProperties2["default"])(_ref, [dataId].map(_toPropertyKey));
        plotType = _objectSpread(_objectSpread({}, filter.plotType), {}, {
          colorsByDataId: _objectSpread(_objectSpread({}, rest), {}, (0, _defineProperty2["default"])({}, dataIdToUse, color))
        });
      }
      replaced.push(_objectSpread(_objectSpread({}, filter), {}, {
        dataId: newDataId
      }, plotType ? {
        plotType: plotType
      } : {}));
    }
  });
  return replaced.length ? replaced : null;
}
function isSavedLayerConfigV1(layerConfig) {
  // exported layer configuration contains visualChannels property
  return layerConfig === null || layerConfig === void 0 ? void 0 : layerConfig.visualChannels;
}
function parseLayerConfig(schema, layerConfig) {
  var _schema$parseSavedCon;
  // assume the layer config is current version
  var savedConfig = {
    version: _schemas.CURRENT_VERSION,
    config: {
      visState: {
        layers: [layerConfig],
        layerOrder: [layerConfig.id]
      }
    }
  };
  return (_schema$parseSavedCon = schema.parseSavedConfig(savedConfig)) === null || _schema$parseSavedCon === void 0 || (_schema$parseSavedCon = _schema$parseSavedCon.visState) === null || _schema$parseSavedCon === void 0 || (_schema$parseSavedCon = _schema$parseSavedCon.layers) === null || _schema$parseSavedCon === void 0 ? void 0 : _schema$parseSavedCon[0];
}
function insertItemBasedOnPreservedOrder(currentItems, items) {
  var preservedOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var defaultStart = arguments.length > 3 ? arguments[3] : undefined;
  var newItems = (0, _toConsumableArray2["default"])(currentItems);
  var _iterator = _createForOfIteratorHelper(items),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;
      var expectedIdx = preservedOrder.indexOf(item.id);
      // insertAt the end by default
      var insertAt = defaultStart ? 0 : newItems.length;
      if (expectedIdx > 0) {
        // look for layer to insert after
        var i = expectedIdx + 1;
        var preceedIdx = -1;
        var _loop = function _loop() {
          // keep looking for preceed layer that is already loaded
          var preceedItemId = preservedOrder[i - 1];
          preceedIdx = newItems.findIndex(function (d) {
            return d.id === preceedItemId;
          });
        };
        while (i-- > 0 && preceedIdx < 0) {
          _loop();
        }
        if (preceedIdx > -1) {
          // if found
          insertAt = preceedIdx + 1;
        }
      }
      newItems = (0, _utils.arrayInsert)(newItems, insertAt, item);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return newItems;
}
function createLayerFromConfig(state, layerConfig) {
  // check if the layer config is parsed
  var parsedLayerConfig = isSavedLayerConfigV1(layerConfig) ? parseLayerConfig(state.schema, layerConfig) : layerConfig;
  if (!parsedLayerConfig) {
    return null;
  }
  // first validate config against dataset
  var _validateLayersByData = validateLayersByDatasets(state.datasets, state.layerClasses, [parsedLayerConfig], {
      allowEmptyColumn: true
    }),
    validated = _validateLayersByData.validated,
    failed = _validateLayersByData.failed;
  if (failed !== null && failed !== void 0 && failed.length || !validated.length) {
    // failed
    return null;
  }
  var newLayer = validated[0];
  newLayer.updateLayerDomain(state.datasets);
  return newLayer;
}

/**
 * Get loaded filter from state
 */
function serializeFilter(newFilter, schema) {
  var _serializedVisState$f;
  var serializedVisState = serializeVisState({
    filters: [newFilter]
  }, schema);
  return serializedVisState === null || serializedVisState === void 0 || (_serializedVisState$f = serializedVisState.filters) === null || _serializedVisState$f === void 0 ? void 0 : _serializedVisState$f[0];
}

/**
 * Get loaded layer from state
 */
function serializeLayer(newLayer, schema) {
  var _serializedVisState$l;
  var serializedVisState = serializeVisState({
    layers: [newLayer],
    layerOrder: [newLayer.id]
  }, schema);
  return serializedVisState === null || serializedVisState === void 0 || (_serializedVisState$l = serializedVisState.layers) === null || _serializedVisState$l === void 0 ? void 0 : _serializedVisState$l[0];
}

/**
 * Get loaded effect from state
 */
function serializeEffect(newEffect, schema) {
  var _serializedVisState$e;
  var serializedVisState = serializeVisState({
    effects: [newEffect],
    effectOrder: [newEffect.id]
  }, schema);
  return serializedVisState === null || serializedVisState === void 0 || (_serializedVisState$e = serializedVisState.effects) === null || _serializedVisState$e === void 0 ? void 0 : _serializedVisState$e[0];
}

/**
 * Get vis state config
 */
function serializeVisState(visState, schema) {
  var _schema$parseSavedCon2;
  var savedState = schema.getConfigToSave({
    visState: visState
  });
  return savedState ? (_schema$parseSavedCon2 = schema.parseSavedConfig(savedState)) === null || _schema$parseSavedCon2 === void 0 ? void 0 : _schema$parseSavedCon2.visState : undefined;
}
/**
 * Merge layers from de-serialized state, if no fields or data are loaded
 * save it for later
 *
 */
function mergeLayers(state) {
  var layersToMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var fromConfig = arguments.length > 2 ? arguments[2] : undefined;
  var preserveLayerOrder = fromConfig ? (0, _layerUtils.getLayerOrderFromLayers)(layersToMerge) : state.preserveLayerOrder;
  if (!Array.isArray(layersToMerge) || !layersToMerge.length) {
    return state;
  }
  // don't merge layer if dataset is being merged
  var unmerged = [];
  var toMerge = [];
  layersToMerge.forEach(function (l) {
    var _l$config;
    if (l !== null && l !== void 0 && (_l$config = l.config) !== null && _l$config !== void 0 && _l$config.dataId && state.isMergingDatasets[l.config.dataId]) {
      unmerged.push(l);
    } else {
      toMerge.push(l);
    }
  });
  var _validateLayersByData2 = validateLayersByDatasets(state.datasets, state.layerClasses, toMerge),
    mergedLayer = _validateLayersByData2.validated,
    failed = _validateLayersByData2.failed;
  unmerged.push.apply(unmerged, (0, _toConsumableArray2["default"])(failed));
  // put new layers in front of current layers
  var _insertLayerAtRightOr = insertLayerAtRightOrder(state.layers, mergedLayer, state.layerOrder, preserveLayerOrder),
    newLayerOrder = _insertLayerAtRightOr.newLayerOrder,
    newLayers = _insertLayerAtRightOr.newLayers;
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    layerOrder: newLayerOrder,
    preserveLayerOrder: preserveLayerOrder,
    layerToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.layerToBeMerged), unmerged)
  });
}
function insertLayerAtRightOrder(currentLayers, layersToInsert, currentOrder) {
  var preservedOrder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  if (!(layersToInsert !== null && layersToInsert !== void 0 && layersToInsert.length)) {
    return {
      newLayers: currentLayers,
      newLayerOrder: currentOrder
    };
  }
  // perservedOrder ['a', 'b', 'c'];
  // layerOrder ['a', 'b', 'c']
  var currentLayerQueue = currentOrder.map(function (id) {
    return (0, _utils.findById)(id)(currentLayers);
  }).filter(function (layer) {
    return Boolean(layer);
  });
  var newLayers = currentLayers.concat(layersToInsert);
  var newLayerOrderQueue = insertItemBasedOnPreservedOrder(currentLayerQueue, layersToInsert, preservedOrder, true);

  // reconstruct layerOrder after insert
  var newLayerOrder = (0, _layerUtils.getLayerOrderFromLayers)(newLayerOrderQueue);
  return {
    newLayerOrder: newLayerOrder,
    newLayers: newLayers
  };
}

/**
 * Merge interactions with saved config
 *
 */
function mergeInteractions(state, interactionToBeMerged) {
  var merged = {};
  var unmerged = {};
  if (interactionToBeMerged) {
    Object.keys(interactionToBeMerged).forEach(function (key) {
      if (!state.interactionConfig[key]) {
        return;
      }
      var currentConfig = key === 'tooltip' || key === 'brush' ? state.interactionConfig[key].config : null;
      var _ref2 = interactionToBeMerged[key] || {},
        enabled = _ref2.enabled,
        configSaved = (0, _objectWithoutProperties2["default"])(_ref2, _excluded);
      var configToMerge = configSaved;
      if (key === 'tooltip') {
        var _mergeInteractionTool = mergeInteractionTooltipConfig(state, configSaved),
          mergedTooltip = _mergeInteractionTool.mergedTooltip,
          unmergedTooltip = _mergeInteractionTool.unmergedTooltip;

        // merge new dataset tooltips with original dataset tooltips
        configToMerge = {
          fieldsToShow: _objectSpread(_objectSpread({}, currentConfig.fieldsToShow), mergedTooltip)
        };
        if (Object.keys(unmergedTooltip).length) {
          // @ts-expect-error
          unmerged.tooltip = {
            fieldsToShow: unmergedTooltip,
            enabled: Boolean(enabled)
          };
        }
      }
      merged[key] = _objectSpread(_objectSpread({}, state.interactionConfig[key]), {}, {
        enabled: Boolean(enabled)
      }, currentConfig ? {
        config: (0, _pick["default"])(_objectSpread(_objectSpread({}, currentConfig), configToMerge), Object.keys(currentConfig))
      } : {});
    });
  }
  var nextState = _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: _objectSpread(_objectSpread({}, state.interactionConfig), merged),
    interactionToBeMerged: savedUnmergedInteraction(state, unmerged)
  });
  return nextState;
}
function combineInteractionConfigs(configs) {
  var combined = _objectSpread({}, configs[0]);
  // handle each property key of an `InteractionConfig`, e.g. tooltip, geocoder, brush, coordinate
  // by combining values for each among all passed in configs
  var _loop2 = function _loop2(key) {
    var toBeCombinedProps = configs.map(function (c) {
      return c[key];
    });

    // all of these have an enabled boolean
    combined[key] = {
      // are any of the configs' enabled values true?
      enabled: toBeCombinedProps.some(function (p) {
        return p === null || p === void 0 ? void 0 : p.enabled;
      })
    };
    if (key === 'tooltip') {
      // are any of the configs' compareMode values true?
      combined[key].compareMode = toBeCombinedProps.some(function (p) {
        return p === null || p === void 0 ? void 0 : p.compareMode;
      });

      // return the compare type mode, it will be either absolute or relative
      combined[key].compareType = getValueWithHighestOccurrence(toBeCombinedProps.map(function (p) {
        return p.compareType;
      }));

      // combine fieldsToShow among all dataset ids
      combined[key].fieldsToShow = toBeCombinedProps.map(function (p) {
        return p.fieldsToShow;
      }).reduce(function (acc, nextFieldsToShow) {
        var _loop3 = function _loop3(nextDataIdKey) {
          var nextTooltipFields = nextFieldsToShow[nextDataIdKey];
          if (!acc[nextDataIdKey]) {
            // if the dataset id is not present in the accumulator
            // then add it with its tooltip fields
            acc[nextDataIdKey] = nextTooltipFields;
          } else {
            // otherwise the dataset id is already present in the accumulator
            // so only add the next tooltip fields for this dataset's array if they are not already present,
            // using the tooltipField.name property for uniqueness
            nextTooltipFields.forEach(function (nextTF) {
              if (!acc[nextDataIdKey].find(function (_ref3) {
                var name = _ref3.name;
                return nextTF.name === name;
              })) {
                acc[nextDataIdKey].push(nextTF);
              }
            });
          }
        };
        for (var nextDataIdKey in nextFieldsToShow) {
          _loop3(nextDataIdKey);
        }
        return acc;
      }, {});
    }
    if (key === 'brush') {
      var _aggregate;
      // keep the biggest brush size
      combined[key].size = (_aggregate = (0, _utils.aggregate)(toBeCombinedProps, _constants.AGGREGATION_TYPES.maximum, function (p) {
        return p.size;
      })) !== null && _aggregate !== void 0 ? _aggregate : null;
    }
  };
  for (var key in combined) {
    _loop2(key);
  }
  return combined;
}
function savedUnmergedInteraction(state, unmerged) {
  var _unmerged$tooltip, _unmerged$tooltip2, _state$interactionToB, _unmerged$tooltip3;
  if (!(unmerged !== null && unmerged !== void 0 && (_unmerged$tooltip = unmerged.tooltip) !== null && _unmerged$tooltip !== void 0 && _unmerged$tooltip.fieldsToShow)) {
    return state.interactionToBeMerged;
  }
  return {
    tooltip: _objectSpread(_objectSpread(_objectSpread({}, state.interactionToBeMerged.tooltip), typeof (unmerged === null || unmerged === void 0 || (_unmerged$tooltip2 = unmerged.tooltip) === null || _unmerged$tooltip2 === void 0 ? void 0 : _unmerged$tooltip2.enabled) === 'boolean' ? {
      enabled: unmerged.tooltip.enabled
    } : {}), {}, {
      fieldsToShow: _objectSpread(_objectSpread({}, (_state$interactionToB = state.interactionToBeMerged) === null || _state$interactionToB === void 0 || (_state$interactionToB = _state$interactionToB.tooltip) === null || _state$interactionToB === void 0 ? void 0 : _state$interactionToB.fieldsToShow), unmerged === null || unmerged === void 0 || (_unmerged$tooltip3 = unmerged.tooltip) === null || _unmerged$tooltip3 === void 0 ? void 0 : _unmerged$tooltip3.fieldsToShow)
    })
  };
}
function replaceInteractionDatasetIds(interactionConfig, dataId, dataIdToReplace) {
  var _interactionConfig$to;
  if (interactionConfig !== null && interactionConfig !== void 0 && (_interactionConfig$to = interactionConfig.tooltip) !== null && _interactionConfig$to !== void 0 && _interactionConfig$to.fieldsToShow[dataId]) {
    var _interactionConfig$to2;
    return _objectSpread(_objectSpread({}, interactionConfig), {}, {
      tooltip: _objectSpread(_objectSpread({}, interactionConfig.tooltip), {}, {
        fieldsToShow: (0, _defineProperty2["default"])({}, dataIdToReplace, interactionConfig === null || interactionConfig === void 0 || (_interactionConfig$to2 = interactionConfig.tooltip) === null || _interactionConfig$to2 === void 0 ? void 0 : _interactionConfig$to2.fieldsToShow[dataId])
      })
    });
  }
  return null;
}

/**
 * Merge splitMaps config with current visStete.
 * 1. if current map is split, but splitMap DOESNOT contain maps
 *    : don't merge anything
 * 2. if current map is NOT split, but splitMaps contain maps
 *    : add to splitMaps, and add current layers to splitMaps
 */
function mergeSplitMaps(state) {
  var splitMaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var merged = (0, _toConsumableArray2["default"])(state.splitMaps);
  var unmerged = [];
  splitMaps.forEach(function (sm, i) {
    var entries = Object.entries(sm.layers);
    if (entries.length > 0) {
      entries.forEach(function (_ref4) {
        var _ref5 = (0, _slicedToArray2["default"])(_ref4, 2),
          id = _ref5[0],
          value = _ref5[1];
        // check if layer exists
        var pushTo = state.layers.find(function (l) {
          return l.id === id;
        }) ? merged : unmerged;

        // create map panel if current map is not split
        pushTo[i] = pushTo[i] || _objectSpread(_objectSpread({}, sm), {}, {
          layers: pushTo === merged ? (0, _utils.getInitialMapLayersForSplitMap)(state.layers) : []
        });
        pushTo[i].layers = _objectSpread(_objectSpread({}, pushTo[i].layers), {}, (0, _defineProperty2["default"])({}, id, value));
      });
    } else {
      // We are merging if there are no layers in both split map
      merged.push(sm);
    }
  });
  return _objectSpread(_objectSpread({}, state), {}, {
    splitMaps: merged,
    splitMapsToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.splitMapsToBeMerged), unmerged)
  });
}

/**
 * Merge effects with saved config
 */
function mergeEffects(state, effects, fromConfig) {
  var newEffects = [].concat((0, _toConsumableArray2["default"])(state.effects), (0, _toConsumableArray2["default"])((effects || []).map(function (effect) {
    return fromConfig ? (0, _effects.createEffect)(_deepmerge["default"].all([effect, {
      // collapse all panels when loading effects
      isConfigActive: false
    }])) : effect;
  }).filter(function (effect) {
    return Boolean(effect && effect.isValidToSave());
  })));
  return _objectSpread(_objectSpread({}, state), {}, {
    effects: newEffects,
    effectOrder: newEffects.map(function (effect) {
      return effect.id;
    })
  });
}

/**
 * Merge interactionConfig.tooltip with saved config,
 * validate fieldsToShow
 *
 * @param state
 * @param tooltipConfig
 * @return - {mergedTooltip: {}, unmergedTooltip: {}}
 */
function mergeInteractionTooltipConfig(state) {
  var tooltipConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var unmergedTooltip = {};
  var mergedTooltip = {};
  if (!tooltipConfig || !tooltipConfig.fieldsToShow || !Object.keys(tooltipConfig.fieldsToShow).length) {
    return {
      mergedTooltip: mergedTooltip,
      unmergedTooltip: unmergedTooltip
    };
  }
  var _loop4 = function _loop4() {
    if (!state.datasets[dataId] || state.isMergingDatasets[dataId]) {
      // is not yet loaded
      unmergedTooltip[dataId] = tooltipConfig.fieldsToShow[dataId];
    } else {
      // if dataset is loaded
      var allFields = state.datasets[dataId].fields.map(function (d) {
        return d.name;
      });
      var foundFieldsToShow = tooltipConfig.fieldsToShow[dataId].filter(function (field) {
        return allFields.includes(field.name);
      });
      mergedTooltip[dataId] = foundFieldsToShow;
    }
  };
  for (var dataId in tooltipConfig.fieldsToShow) {
    _loop4();
  }
  return {
    mergedTooltip: mergedTooltip,
    unmergedTooltip: unmergedTooltip
  };
}
/**
 * Merge layerBlending with saved
 *
 */
function mergeLayerBlending(state, layerBlending) {
  if (layerBlending && _constants.LAYER_BLENDINGS[layerBlending]) {
    return _objectSpread(_objectSpread({}, state), {}, {
      layerBlending: layerBlending
    });
  }
  return state;
}

/**
 * Combines multiple layer blending configs into a single string
 * by returning the one with the highest occurrence
 */
function combineLayerBlendingConfigs(configs) {
  // return the mode of the layer blending type
  return getValueWithHighestOccurrence(configs);
}

/**
 * Merge overlayBlending with saved
 */
function mergeOverlayBlending(state, overlayBlending) {
  if (overlayBlending && _constants.OVERLAY_BLENDINGS[overlayBlending]) {
    return _objectSpread(_objectSpread({}, state), {}, {
      overlayBlending: overlayBlending
    });
  }
  return state;
}

/**
 * Combines multiple overlay blending configs into a single string
 * by returning the one with the highest occurrence
 **/
function combineOverlayBlendingConfigs(configs) {
  // return the mode of the overlay blending type
  return getValueWithHighestOccurrence(configs);
}

/**
 * Merge animation config
 */
function mergeAnimationConfig(state, animation) {
  if (animation && animation.currentTime) {
    return _objectSpread(_objectSpread({}, state), {}, {
      animationConfig: _objectSpread(_objectSpread(_objectSpread({}, state.animationConfig), animation), {}, {
        domain: null
      })
    });
  }
  return state;
}
function combineAnimationConfigs(configs) {
  var _aggregate2, _aggregate3;
  // get the smallest values of currentTime and speed among all configs
  return {
    currentTime: (_aggregate2 = (0, _utils.aggregate)(configs, _constants.AGGREGATION_TYPES.minimum, function (c) {
      return c.currentTime;
    })) !== null && _aggregate2 !== void 0 ? _aggregate2 : null,
    speed: (_aggregate3 = (0, _utils.aggregate)(configs, _constants.AGGREGATION_TYPES.minimum, function (c) {
      return c.speed;
    })) !== null && _aggregate3 !== void 0 ? _aggregate3 : null
  };
}

/**
 * Validate saved layer columns with new data,
 * update fieldIdx based on new fields
 *
 * @param fields
 * @param savedCols
 * @param emptyCols
 * @param options
 * @return - validated columns or null
 */

function validateSavedLayerColumns(fields) {
  var savedCols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var emptyCols = arguments.length > 2 ? arguments[2] : undefined;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // Prepare columns for the validator
  var columns = {};
  var _loop5 = function _loop5() {
    var key = _Object$keys[_i];
    columns[key] = _objectSpread({}, emptyCols[key]);
    var saved = savedCols[key];
    if (saved) {
      var fieldIdx = fields.findIndex(function (_ref6) {
        var name = _ref6.name;
        return name === saved;
      });
      if (fieldIdx > -1) {
        // update found columns
        columns[key].fieldIdx = fieldIdx;
        columns[key].value = saved;
      }
    }
  };
  for (var _i = 0, _Object$keys = Object.keys(emptyCols); _i < _Object$keys.length; _i++) {
    _loop5();
  }

  // find actual column fieldIdx, in case it has changed
  var allColFound = Object.keys(columns).every(function (key) {
    return validateColumn(columns[key], columns, fields);
  });
  var rv = allColFound ? columns : null;
  if (options.throwOnError) {
    var requiredColumns = Object.keys(emptyCols).filter(function (k) {
      return !emptyCols[k].optional;
    });
    var missingColumns = requiredColumns.filter(function (k) {
      return !(columns !== null && columns !== void 0 && columns[k].value);
    });
    if (missingColumns.length) {
      throw new Error("Layer has missing or invalid columns: ".concat(missingColumns.join(', ')));
    }
    var configColumns = Object.keys(savedCols);
    var invalidColumns = configColumns.filter(function (k) {
      var _columns$k;
      return !(columns !== null && columns !== void 0 && (_columns$k = columns[k]) !== null && _columns$k !== void 0 && _columns$k.value);
    });
    if (invalidColumns.length) {
      throw new Error("Layer has invalid columns: ".concat(invalidColumns.join(', ')));
    }
  }
  return rv;
}

/**
 * Validate layer column
 */
function validateColumn(column, columns, allFields) {
  if (column.optional || column.value) {
    return true;
  }
  if (column.validator) {
    return column.validator(column, columns, allFields);
  }
  return false;
}

/**
 * Validate saved text label config with new data
 * refer to vis-state-schema.js TextLabelSchemaV1
 *
 * @param {Array<Object>} fields
 * @param {Object} savedTextLabel
 * @param {Object} options
 * @return {Object} - validated textlabel
 */
function validateSavedTextLabel(fields, _ref7, savedTextLabel) {
  var _ref8 = (0, _slicedToArray2["default"])(_ref7, 1),
    layerTextLabel = _ref8[0];
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var savedTextLabels = Array.isArray(savedTextLabel) ? savedTextLabel : [savedTextLabel];

  // validate field
  return savedTextLabels.map(function (textLabel) {
    var field = textLabel.field ? fields.find(function (fd) {
      return Object.keys(textLabel.field).every(function (key) {
        return textLabel.field[key] === fd[key];
      });
    }) : null;
    if (field === undefined && options.throwOnError) {
      throw new Error("Layer has invalid text label field: ".concat(JSON.stringify(textLabel.field)));
    }
    return Object.keys(layerTextLabel).reduce(function (accu, key) {
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, key === 'field' ? field : textLabel[key] || layerTextLabel[key]));
    }, {});
  });
}

/**
 * Validate saved visual channels config with new data,
 * refer to vis-state-schema.js VisualChannelSchemaV1
 */
function validateSavedVisualChannels(fields, newLayer, savedLayer) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  Object.values(newLayer.visualChannels).forEach(function (_ref9) {
    var field = _ref9.field,
      scale = _ref9.scale,
      key = _ref9.key;
    var foundField;
    if (savedLayer.config) {
      if (savedLayer.config[field]) {
        foundField = fields.find(function (fd) {
          return savedLayer.config && fd.name === savedLayer.config[field].name;
        });
      }
      var foundChannel = _objectSpread(_objectSpread({}, foundField ? (0, _defineProperty2["default"])({}, field, foundField) : {}), savedLayer.config[scale] ? (0, _defineProperty2["default"])({}, scale, savedLayer.config[scale]) : {});
      if (Object.keys(foundChannel).length) {
        newLayer.updateLayerConfig(foundChannel);
      }
      newLayer.validateVisualChannel(key);
      if (options.throwOnError) {
        var _savedLayer$config, _newLayer$config$fiel;
        var fieldName = (_savedLayer$config = savedLayer.config) === null || _savedLayer$config === void 0 || (_savedLayer$config = _savedLayer$config[field]) === null || _savedLayer$config === void 0 ? void 0 : _savedLayer$config.name;
        if (fieldName && fieldName !== ((_newLayer$config$fiel = newLayer.config[field]) === null || _newLayer$config$fiel === void 0 ? void 0 : _newLayer$config$fiel.name)) {
          throw new Error("Layer has invalid visual channel field: ".concat(field));
        }
      }
    }
  });
  return newLayer;
}
function validateLayersByDatasets(datasets, layerClasses) {
  var layers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var options = arguments.length > 3 ? arguments[3] : undefined;
  var validated = [];
  var failed = [];
  layers.forEach(function (layer) {
    var _layer$config;
    var validateLayer = null;
    if (layer !== null && layer !== void 0 && (_layer$config = layer.config) !== null && _layer$config !== void 0 && _layer$config.dataId) {
      if (datasets[layer.config.dataId]) {
        // datasets are already loaded
        validateLayer = validateLayerWithData(datasets[layer.config.dataId], layer, layerClasses, options);
      }
    }
    if (validateLayer) {
      validated.push(validateLayer);
    } else {
      // datasets not yet loaded
      failed.push(layer);
    }
  });
  return {
    validated: validated,
    failed: failed
  };
}

/**
 * Get required columns for validation based on column mode
 */
function _getColumnConfigForValidation(newLayer) {
  // find column fieldIdx
  var columnConfig = newLayer.getLayerColumns();
  // if columnMode is defined, find column mode config
  var colModeConfig = newLayer.config.columnMode ? (newLayer.supportedColumnModes || []).find(function (colMode) {
    return colMode.key === newLayer.config.columnMode;
  }) : null;
  if (colModeConfig) {
    // only validate columns in column mode
    columnConfig = [].concat((0, _toConsumableArray2["default"])(colModeConfig.requiredColumns || []), (0, _toConsumableArray2["default"])(colModeConfig.optionalColumns || [])).reduce(function (accu, key) {
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, columnConfig[key]));
    }, {});
  }
  return columnConfig;
}

/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 */
// eslint-disable-next-line complexity
function validateLayerWithData(dataset, savedLayer, layerClasses) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var fields = dataset.fields,
    dataId = dataset.id;
  var type = savedLayer.type;
  var throwOnError = options.throwOnError;
  // layer doesnt have a valid type
  if (!type || !Object.prototype.hasOwnProperty.call(layerClasses, type) || !savedLayer.config) {
    if (throwOnError) {
      throw new Error("Layer has invalid type \"".concat(type, "\" or config is missing"));
    }
    return null;
  }
  var newLayer = new layerClasses[type]({
    id: savedLayer.id,
    dataId: dataId,
    label: savedLayer.config.label,
    color: savedLayer.config.color,
    isVisible: savedLayer.config.isVisible,
    hidden: savedLayer.config.hidden,
    columnMode: savedLayer.config.columnMode,
    highlightColor: savedLayer.config.highlightColor
  });
  var columnConfig = _getColumnConfigForValidation(newLayer);
  if (Object.keys(columnConfig)) {
    var columns = validateSavedLayerColumns(fields, savedLayer.config.columns, columnConfig, options);
    if (columns) {
      newLayer.updateLayerConfig({
        columns: _objectSpread(_objectSpread({}, newLayer.config.columns), columns)
      });
    } else if (!options.allowEmptyColumn) {
      return null;
    }
  }
  var textLabel = savedLayer.config.textLabel && newLayer.config.textLabel ? validateSavedTextLabel(fields, newLayer.config.textLabel, savedLayer.config.textLabel, options) : newLayer.config.textLabel;

  // copy visConfig over to emptyLayer to make sure it has all the props
  var copiedVisConfig = newLayer.copyLayerConfig(newLayer.config.visConfig, savedLayer.config.visConfig || {}, {
    shallowCopy: ['colorRange', 'strokeColorRange']
  });

  // call layer methods to validate visConfig when switching dataset
  var visConfig = newLayer.validateVisConfig ? newLayer.validateVisConfig(dataset, copiedVisConfig) : copiedVisConfig;
  newLayer.updateLayerConfig({
    visConfig: visConfig,
    textLabel: textLabel
  });

  // visual channel field is saved to be {name, type}
  // find visual channel field by matching both name and type
  // refer to vis-state-schema.js VisualChannelSchemaV1
  newLayer = validateSavedVisualChannels(fields, newLayer, savedLayer, options);
  if (throwOnError) {
    if (!newLayer.isValidToSave()) {
      throw new Error("Layer is not valid to save: ".concat(newLayer.id));
    }
  }
  return newLayer;
}
function mergeEditor(state, savedEditor) {
  var _savedEditor$visible;
  if (!savedEditor) {
    return state;
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      features: [].concat((0, _toConsumableArray2["default"])(state.editor.features), (0, _toConsumableArray2["default"])(savedEditor.features || [])),
      // if savedEditor.visible is undefined keep state.editor.visible
      visible: (_savedEditor$visible = savedEditor.visible) !== null && _savedEditor$visible !== void 0 ? _savedEditor$visible : state.editor.visible
    })
  });
}
function combineEditorConfigs(configs) {
  return configs.reduce(function (acc, nextConfig) {
    return _objectSpread(_objectSpread({}, acc), {}, {
      features: [].concat((0, _toConsumableArray2["default"])(acc.features), (0, _toConsumableArray2["default"])(nextConfig.features || []))
    });
  }, {
    // start with:
    // - empty array for features accumulation
    // - and are any of the configs' visible values true?
    features: [],
    visible: configs.some(function (c) {
      return c === null || c === void 0 ? void 0 : c.visible;
    })
  });
}

/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 */
function mergeDatasetsByOrder(state, newDataEntries) {
  var merged = _objectSpread(_objectSpread({}, state.datasets), newDataEntries);
  if (Array.isArray(state.preserveDatasetOrder)) {
    // preserveDatasetOrder  might not include the  new datasets
    var newDatasetIds = Object.keys(merged).filter(function (id) {
      var _state$preserveDatase;
      return !((_state$preserveDatase = state.preserveDatasetOrder) !== null && _state$preserveDatase !== void 0 && _state$preserveDatase.includes(id));
    });
    return [].concat((0, _toConsumableArray2["default"])(state.preserveDatasetOrder), (0, _toConsumableArray2["default"])(newDatasetIds)).reduce(function (accu, dataId) {
      return _objectSpread(_objectSpread({}, accu), merged[dataId] ? (0, _defineProperty2["default"])({}, dataId, merged[dataId]) : {});
    }, {});
  }
  return merged;
}

/**
 * Simliar purpose to aggregation utils `getMode` function,
 * but returns the mode in the same value type without coercing to a string.
 * It ignores `undefined` or `null` values, but returns `null` if no mode could be calculated.
 */
function getValueWithHighestOccurrence(arr) {
  var _ref13;
  var tallys = new Map();
  arr.forEach(function (value) {
    if ((0, _commonUtils.notNullorUndefined)(value)) {
      if (!tallys.has(value)) {
        tallys.set(value, 1);
      } else {
        tallys.set(value, tallys.get(value) + 1);
      }
    }
  });
  // return the value with the highest total occurrence count
  if (tallys.size === 0) {
    return null;
  }
  return (_ref13 = (0, _toConsumableArray2["default"])(tallys.entries())) === null || _ref13 === void 0 ? void 0 : _ref13.reduce(function (acc, next) {
    return next[1] > acc[1] ? next : acc;
  })[0];
}
var VIS_STATE_MERGERS = exports.VIS_STATE_MERGERS = [{
  merge: mergeLayers,
  prop: 'layers',
  toMergeProp: 'layerToBeMerged',
  preserveOrder: 'preserveLayerOrder'
}, {
  merge: mergeFilters,
  prop: 'filters',
  toMergeProp: 'filterToBeMerged',
  preserveOrder: 'preserveFilterOrder',
  replaceParentDatasetIds: replaceFilterDatasetIds
}, {
  merge: mergeEffects,
  prop: 'effects'
}, {
  merge: mergeInteractions,
  prop: 'interactionConfig',
  toMergeProp: 'interactionToBeMerged',
  replaceParentDatasetIds: replaceInteractionDatasetIds,
  saveUnmerged: savedUnmergedInteraction,
  combineConfigs: combineInteractionConfigs
}, {
  merge: mergeLayerBlending,
  prop: 'layerBlending',
  combineConfigs: combineLayerBlendingConfigs
}, {
  merge: mergeOverlayBlending,
  prop: 'overlayBlending',
  combineConfigs: combineOverlayBlendingConfigs
}, {
  merge: mergeSplitMaps,
  prop: 'splitMaps',
  toMergeProp: 'splitMapsToBeMerged'
}, {
  merge: mergeAnimationConfig,
  prop: 'animationConfig',
  combineConfigs: combineAnimationConfigs
}, {
  merge: mergeEditor,
  prop: 'editor',
  combineConfigs: combineEditorConfigs
}];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfdW5pcSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3BpY2siLCJfZmxhdHRlbkRlZXAiLCJfZGVlcG1lcmdlIiwiX3V0aWxzIiwiX2VmZmVjdHMiLCJfY29tbW9uVXRpbHMiLCJfY29uc3RhbnRzIiwiX3NjaGVtYXMiLCJfdGFibGUiLCJfbGF5ZXJVdGlscyIsIl9leGNsdWRlZCIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiciIsImUiLCJ0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBcnJheSIsImlzQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJsZW5ndGgiLCJfbiIsIkYiLCJzIiwibiIsImRvbmUiLCJ2YWx1ZSIsImYiLCJUeXBlRXJyb3IiLCJvIiwiYSIsInUiLCJjYWxsIiwibmV4dCIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwiX3RvUHJvcGVydHlLZXkiLCJpIiwiX3RvUHJpbWl0aXZlIiwiX3R5cGVvZiIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwib3duS2V5cyIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm1lcmdlRmlsdGVycyIsInN0YXRlIiwiZmlsdGVyc1RvTWVyZ2UiLCJmcm9tQ29uZmlnIiwicHJlc2VydmVGaWx0ZXJPcmRlciIsIm1hcCIsImwiLCJpZCIsIl92YWxpZGF0ZUZpbHRlcnNVcGRhdCIsInZhbGlkYXRlRmlsdGVyc1VwZGF0ZURhdGFzZXRzIiwidmFsaWRhdGVkIiwiZmFpbGVkIiwidXBkYXRlZERhdGFzZXRzIiwidXBkYXRlZEZpbHRlcnMiLCJpbnNlcnRJdGVtQmFzZWRPblByZXNlcnZlZE9yZGVyIiwiZmlsdGVycyIsInJlc2V0RmlsdGVyR3B1TW9kZSIsImFzc2lnbkdwdUNoYW5uZWxzIiwiZGF0YXNldHNUb0ZpbHRlciIsInVuaXEiLCJmbGF0dGVuRGVlcCIsImRhdGFJZCIsImZpbHRlcmVkIiwiYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyIsImxheWVycyIsImRhdGFzZXRzIiwiZmlsdGVyVG9CZU1lcmdlZCIsImNvbmNhdCIsIl90b0NvbnN1bWFibGVBcnJheTIiLCJyZXBsYWNlRmlsdGVyRGF0YXNldElkcyIsInNhdmVkRmlsdGVyIiwiZGF0YUlkVG9Vc2UiLCJyZXBsYWNlZCIsImluY2x1ZGVzIiwiX2ZpbHRlciRwbG90VHlwZSIsIm5ld0RhdGFJZCIsImQiLCJwbG90VHlwZSIsImNvbG9yc0J5RGF0YUlkIiwiX2ZpbHRlciRwbG90VHlwZTIiLCJfcmVmIiwiY29sb3IiLCJyZXN0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMiIsImlzU2F2ZWRMYXllckNvbmZpZ1YxIiwibGF5ZXJDb25maWciLCJ2aXN1YWxDaGFubmVscyIsInBhcnNlTGF5ZXJDb25maWciLCJzY2hlbWEiLCJfc2NoZW1hJHBhcnNlU2F2ZWRDb24iLCJzYXZlZENvbmZpZyIsInZlcnNpb24iLCJDVVJSRU5UX1ZFUlNJT04iLCJjb25maWciLCJ2aXNTdGF0ZSIsImxheWVyT3JkZXIiLCJwYXJzZVNhdmVkQ29uZmlnIiwiY3VycmVudEl0ZW1zIiwiaXRlbXMiLCJwcmVzZXJ2ZWRPcmRlciIsInVuZGVmaW5lZCIsImRlZmF1bHRTdGFydCIsIm5ld0l0ZW1zIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJpdGVtIiwiZXhwZWN0ZWRJZHgiLCJpbmRleE9mIiwiaW5zZXJ0QXQiLCJwcmVjZWVkSWR4IiwiX2xvb3AiLCJwcmVjZWVkSXRlbUlkIiwiZmluZEluZGV4IiwiYXJyYXlJbnNlcnQiLCJlcnIiLCJjcmVhdGVMYXllckZyb21Db25maWciLCJwYXJzZWRMYXllckNvbmZpZyIsIl92YWxpZGF0ZUxheWVyc0J5RGF0YSIsInZhbGlkYXRlTGF5ZXJzQnlEYXRhc2V0cyIsImxheWVyQ2xhc3NlcyIsImFsbG93RW1wdHlDb2x1bW4iLCJuZXdMYXllciIsInVwZGF0ZUxheWVyRG9tYWluIiwic2VyaWFsaXplRmlsdGVyIiwibmV3RmlsdGVyIiwiX3NlcmlhbGl6ZWRWaXNTdGF0ZSRmIiwic2VyaWFsaXplZFZpc1N0YXRlIiwic2VyaWFsaXplVmlzU3RhdGUiLCJzZXJpYWxpemVMYXllciIsIl9zZXJpYWxpemVkVmlzU3RhdGUkbCIsInNlcmlhbGl6ZUVmZmVjdCIsIm5ld0VmZmVjdCIsIl9zZXJpYWxpemVkVmlzU3RhdGUkZSIsImVmZmVjdHMiLCJlZmZlY3RPcmRlciIsIl9zY2hlbWEkcGFyc2VTYXZlZENvbjIiLCJzYXZlZFN0YXRlIiwiZ2V0Q29uZmlnVG9TYXZlIiwibWVyZ2VMYXllcnMiLCJsYXllcnNUb01lcmdlIiwicHJlc2VydmVMYXllck9yZGVyIiwiZ2V0TGF5ZXJPcmRlckZyb21MYXllcnMiLCJ1bm1lcmdlZCIsInRvTWVyZ2UiLCJfbCRjb25maWciLCJpc01lcmdpbmdEYXRhc2V0cyIsIl92YWxpZGF0ZUxheWVyc0J5RGF0YTIiLCJtZXJnZWRMYXllciIsIl9pbnNlcnRMYXllckF0UmlnaHRPciIsImluc2VydExheWVyQXRSaWdodE9yZGVyIiwibmV3TGF5ZXJPcmRlciIsIm5ld0xheWVycyIsImxheWVyVG9CZU1lcmdlZCIsImN1cnJlbnRMYXllcnMiLCJsYXllcnNUb0luc2VydCIsImN1cnJlbnRPcmRlciIsImN1cnJlbnRMYXllclF1ZXVlIiwiZmluZEJ5SWQiLCJsYXllciIsIkJvb2xlYW4iLCJuZXdMYXllck9yZGVyUXVldWUiLCJtZXJnZUludGVyYWN0aW9ucyIsImludGVyYWN0aW9uVG9CZU1lcmdlZCIsIm1lcmdlZCIsImtleSIsImludGVyYWN0aW9uQ29uZmlnIiwiY3VycmVudENvbmZpZyIsIl9yZWYyIiwiZW5hYmxlZCIsImNvbmZpZ1NhdmVkIiwiY29uZmlnVG9NZXJnZSIsIl9tZXJnZUludGVyYWN0aW9uVG9vbCIsIm1lcmdlSW50ZXJhY3Rpb25Ub29sdGlwQ29uZmlnIiwibWVyZ2VkVG9vbHRpcCIsInVubWVyZ2VkVG9vbHRpcCIsImZpZWxkc1RvU2hvdyIsInRvb2x0aXAiLCJwaWNrIiwibmV4dFN0YXRlIiwic2F2ZWRVbm1lcmdlZEludGVyYWN0aW9uIiwiY29tYmluZUludGVyYWN0aW9uQ29uZmlncyIsImNvbmZpZ3MiLCJjb21iaW5lZCIsIl9sb29wMiIsInRvQmVDb21iaW5lZFByb3BzIiwiYyIsInNvbWUiLCJwIiwiY29tcGFyZU1vZGUiLCJjb21wYXJlVHlwZSIsImdldFZhbHVlV2l0aEhpZ2hlc3RPY2N1cnJlbmNlIiwicmVkdWNlIiwiYWNjIiwibmV4dEZpZWxkc1RvU2hvdyIsIl9sb29wMyIsIm5leHREYXRhSWRLZXkiLCJuZXh0VG9vbHRpcEZpZWxkcyIsIm5leHRURiIsImZpbmQiLCJfcmVmMyIsIl9hZ2dyZWdhdGUiLCJzaXplIiwiYWdncmVnYXRlIiwiQUdHUkVHQVRJT05fVFlQRVMiLCJtYXhpbXVtIiwiX3VubWVyZ2VkJHRvb2x0aXAiLCJfdW5tZXJnZWQkdG9vbHRpcDIiLCJfc3RhdGUkaW50ZXJhY3Rpb25Ub0IiLCJfdW5tZXJnZWQkdG9vbHRpcDMiLCJyZXBsYWNlSW50ZXJhY3Rpb25EYXRhc2V0SWRzIiwiZGF0YUlkVG9SZXBsYWNlIiwiX2ludGVyYWN0aW9uQ29uZmlnJHRvIiwiX2ludGVyYWN0aW9uQ29uZmlnJHRvMiIsIm1lcmdlU3BsaXRNYXBzIiwic3BsaXRNYXBzIiwic20iLCJlbnRyaWVzIiwiX3JlZjQiLCJfcmVmNSIsIl9zbGljZWRUb0FycmF5MiIsInB1c2hUbyIsImdldEluaXRpYWxNYXBMYXllcnNGb3JTcGxpdE1hcCIsInNwbGl0TWFwc1RvQmVNZXJnZWQiLCJtZXJnZUVmZmVjdHMiLCJuZXdFZmZlY3RzIiwiZWZmZWN0IiwiY3JlYXRlRWZmZWN0IiwiZGVlcG1lcmdlIiwiYWxsIiwiaXNDb25maWdBY3RpdmUiLCJpc1ZhbGlkVG9TYXZlIiwidG9vbHRpcENvbmZpZyIsIl9sb29wNCIsImFsbEZpZWxkcyIsImZpZWxkcyIsImZvdW5kRmllbGRzVG9TaG93IiwiZmllbGQiLCJtZXJnZUxheWVyQmxlbmRpbmciLCJsYXllckJsZW5kaW5nIiwiTEFZRVJfQkxFTkRJTkdTIiwiY29tYmluZUxheWVyQmxlbmRpbmdDb25maWdzIiwibWVyZ2VPdmVybGF5QmxlbmRpbmciLCJvdmVybGF5QmxlbmRpbmciLCJPVkVSTEFZX0JMRU5ESU5HUyIsImNvbWJpbmVPdmVybGF5QmxlbmRpbmdDb25maWdzIiwibWVyZ2VBbmltYXRpb25Db25maWciLCJhbmltYXRpb24iLCJjdXJyZW50VGltZSIsImFuaW1hdGlvbkNvbmZpZyIsImRvbWFpbiIsImNvbWJpbmVBbmltYXRpb25Db25maWdzIiwiX2FnZ3JlZ2F0ZTIiLCJfYWdncmVnYXRlMyIsIm1pbmltdW0iLCJzcGVlZCIsInZhbGlkYXRlU2F2ZWRMYXllckNvbHVtbnMiLCJzYXZlZENvbHMiLCJlbXB0eUNvbHMiLCJvcHRpb25zIiwiY29sdW1ucyIsIl9sb29wNSIsIl9PYmplY3Qka2V5cyIsIl9pIiwic2F2ZWQiLCJmaWVsZElkeCIsIl9yZWY2IiwiYWxsQ29sRm91bmQiLCJldmVyeSIsInZhbGlkYXRlQ29sdW1uIiwicnYiLCJ0aHJvd09uRXJyb3IiLCJyZXF1aXJlZENvbHVtbnMiLCJrIiwib3B0aW9uYWwiLCJtaXNzaW5nQ29sdW1ucyIsIkVycm9yIiwiam9pbiIsImNvbmZpZ0NvbHVtbnMiLCJpbnZhbGlkQ29sdW1ucyIsIl9jb2x1bW5zJGsiLCJjb2x1bW4iLCJ2YWxpZGF0b3IiLCJ2YWxpZGF0ZVNhdmVkVGV4dExhYmVsIiwiX3JlZjciLCJzYXZlZFRleHRMYWJlbCIsIl9yZWY4IiwibGF5ZXJUZXh0TGFiZWwiLCJzYXZlZFRleHRMYWJlbHMiLCJ0ZXh0TGFiZWwiLCJmZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJhY2N1IiwidmFsaWRhdGVTYXZlZFZpc3VhbENoYW5uZWxzIiwic2F2ZWRMYXllciIsInZhbHVlcyIsIl9yZWY5Iiwic2NhbGUiLCJmb3VuZEZpZWxkIiwiZm91bmRDaGFubmVsIiwidXBkYXRlTGF5ZXJDb25maWciLCJ2YWxpZGF0ZVZpc3VhbENoYW5uZWwiLCJfc2F2ZWRMYXllciRjb25maWciLCJfbmV3TGF5ZXIkY29uZmlnJGZpZWwiLCJmaWVsZE5hbWUiLCJfbGF5ZXIkY29uZmlnIiwidmFsaWRhdGVMYXllciIsInZhbGlkYXRlTGF5ZXJXaXRoRGF0YSIsIl9nZXRDb2x1bW5Db25maWdGb3JWYWxpZGF0aW9uIiwiY29sdW1uQ29uZmlnIiwiZ2V0TGF5ZXJDb2x1bW5zIiwiY29sTW9kZUNvbmZpZyIsImNvbHVtbk1vZGUiLCJzdXBwb3J0ZWRDb2x1bW5Nb2RlcyIsImNvbE1vZGUiLCJvcHRpb25hbENvbHVtbnMiLCJkYXRhc2V0IiwidHlwZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwibGFiZWwiLCJpc1Zpc2libGUiLCJoaWRkZW4iLCJoaWdobGlnaHRDb2xvciIsImNvcGllZFZpc0NvbmZpZyIsImNvcHlMYXllckNvbmZpZyIsInZpc0NvbmZpZyIsInNoYWxsb3dDb3B5IiwidmFsaWRhdGVWaXNDb25maWciLCJtZXJnZUVkaXRvciIsInNhdmVkRWRpdG9yIiwiX3NhdmVkRWRpdG9yJHZpc2libGUiLCJlZGl0b3IiLCJmZWF0dXJlcyIsInZpc2libGUiLCJjb21iaW5lRWRpdG9yQ29uZmlncyIsIm5leHRDb25maWciLCJtZXJnZURhdGFzZXRzQnlPcmRlciIsIm5ld0RhdGFFbnRyaWVzIiwicHJlc2VydmVEYXRhc2V0T3JkZXIiLCJuZXdEYXRhc2V0SWRzIiwiX3N0YXRlJHByZXNlcnZlRGF0YXNlIiwiYXJyIiwiX3JlZjEzIiwidGFsbHlzIiwiTWFwIiwibm90TnVsbG9yVW5kZWZpbmVkIiwiaGFzIiwic2V0IiwiZ2V0IiwiVklTX1NUQVRFX01FUkdFUlMiLCJleHBvcnRzIiwibWVyZ2UiLCJwcm9wIiwidG9NZXJnZVByb3AiLCJwcmVzZXJ2ZU9yZGVyIiwicmVwbGFjZVBhcmVudERhdGFzZXRJZHMiLCJzYXZlVW5tZXJnZWQiLCJjb21iaW5lQ29uZmlncyJdLCJzb3VyY2VzIjpbIi4uL3NyYy92aXMtc3RhdGUtbWVyZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCB1bmlxIGZyb20gJ2xvZGFzaC91bmlxJztcbmltcG9ydCBwaWNrIGZyb20gJ2xvZGFzaC9waWNrJztcbmltcG9ydCBmbGF0dGVuRGVlcCBmcm9tICdsb2Rhc2gvZmxhdHRlbkRlZXAnO1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IHtcbiAgYXJyYXlJbnNlcnQsXG4gIGdldEluaXRpYWxNYXBMYXllcnNGb3JTcGxpdE1hcCxcbiAgYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyxcbiAgdmFsaWRhdGVGaWx0ZXJzVXBkYXRlRGF0YXNldHMsXG4gIGZpbmRCeUlkLFxuICBhZ2dyZWdhdGVcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJ0BrZXBsZXIuZ2wvbGF5ZXJzJztcbmltcG9ydCB7Y3JlYXRlRWZmZWN0fSBmcm9tICdAa2VwbGVyLmdsL2VmZmVjdHMnO1xuaW1wb3J0IHtub3ROdWxsb3JVbmRlZmluZWR9IGZyb20gJ0BrZXBsZXIuZ2wvY29tbW9uLXV0aWxzJztcbmltcG9ydCB7QUdHUkVHQVRJT05fVFlQRVMsIExBWUVSX0JMRU5ESU5HUywgT1ZFUkxBWV9CTEVORElOR1N9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7Q1VSUkVOVF9WRVJTSU9OLCBWaXNTdGF0ZSwgVmlzU3RhdGVNZXJnZXJzLCBLZXBsZXJHTFNjaGVtYUNsYXNzfSBmcm9tICdAa2VwbGVyLmdsL3NjaGVtYXMnO1xuXG5pbXBvcnQge1xuICBQYXJzZWRMYXllcixcbiAgUGFyc2VkVmlzU3RhdGUsXG4gIFNhdmVkSW50ZXJhY3Rpb25Db25maWcsXG4gIFRvb2x0aXBJbmZvLFxuICBTYXZlZEVkaXRvcixcbiAgUGFyc2VkQ29uZmlnLFxuICBGaWx0ZXIsXG4gIEVmZmVjdCBhcyBFZmZlY3RUeXBlLFxuICBQYXJzZWRFZmZlY3QsXG4gIExheWVyQ29sdW1ucyxcbiAgTGF5ZXJDb2x1bW4sXG4gIFBhcnNlZEZpbHRlcixcbiAgTmVzdGVkUGFydGlhbCxcbiAgU2F2ZWRBbmltYXRpb25Db25maWdcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0tlcGxlclRhYmxlLCBEYXRhc2V0cywgYXNzaWduR3B1Q2hhbm5lbHMsIHJlc2V0RmlsdGVyR3B1TW9kZX0gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5cbmltcG9ydCB7Z2V0TGF5ZXJPcmRlckZyb21MYXllcnN9IGZyb20gJy4vbGF5ZXItdXRpbHMnO1xuXG4vKipcbiAqIE1lcmdlIGxvYWRlZCBmaWx0ZXJzIHdpdGggY3VycmVudCBzdGF0ZSwgaWYgbm8gZmllbGRzIG9yIGRhdGEgYXJlIGxvYWRlZFxuICogc2F2ZSBpdCBmb3IgbGF0ZXJcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUZpbHRlcnM8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIGZpbHRlcnNUb01lcmdlOiBOb25OdWxsYWJsZTxQYXJzZWRDb25maWdbJ3Zpc1N0YXRlJ10+WydmaWx0ZXJzJ10sXG4gIGZyb21Db25maWc/OiBib29sZWFuXG4pOiBTIHtcbiAgY29uc3QgcHJlc2VydmVGaWx0ZXJPcmRlciA9IGZyb21Db25maWdcbiAgICA/IGZpbHRlcnNUb01lcmdlPy5tYXAobCA9PiBsLmlkKVxuICAgIDogc3RhdGUucHJlc2VydmVGaWx0ZXJPcmRlcjtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyc1RvTWVyZ2UpIHx8ICFmaWx0ZXJzVG9NZXJnZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB7dmFsaWRhdGVkLCBmYWlsZWQsIHVwZGF0ZWREYXRhc2V0c30gPSB2YWxpZGF0ZUZpbHRlcnNVcGRhdGVEYXRhc2V0cyhzdGF0ZSwgZmlsdGVyc1RvTWVyZ2UpO1xuICBsZXQgdXBkYXRlZEZpbHRlcnMgPSBpbnNlcnRJdGVtQmFzZWRPblByZXNlcnZlZE9yZGVyKFxuICAgIHN0YXRlLmZpbHRlcnMsXG4gICAgdmFsaWRhdGVkLFxuICAgIHByZXNlcnZlRmlsdGVyT3JkZXJcbiAgKTtcblxuICAvLyBtZXJnZSBmaWx0ZXIgd2l0aCBleGlzdGluZ1xuICB1cGRhdGVkRmlsdGVycyA9IHJlc2V0RmlsdGVyR3B1TW9kZSh1cGRhdGVkRmlsdGVycyk7XG4gIHVwZGF0ZWRGaWx0ZXJzID0gYXNzaWduR3B1Q2hhbm5lbHModXBkYXRlZEZpbHRlcnMpO1xuICAvLyBmaWx0ZXIgZGF0YVxuICBjb25zdCBkYXRhc2V0c1RvRmlsdGVyID0gdW5pcShmbGF0dGVuRGVlcCh2YWxpZGF0ZWQubWFwKGYgPT4gZi5kYXRhSWQpKSk7XG5cbiAgY29uc3QgZmlsdGVyZWQgPSBhcHBseUZpbHRlcnNUb0RhdGFzZXRzKFxuICAgIGRhdGFzZXRzVG9GaWx0ZXIsXG4gICAgdXBkYXRlZERhdGFzZXRzLFxuICAgIHVwZGF0ZWRGaWx0ZXJzLFxuICAgIHN0YXRlLmxheWVyc1xuICApO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZmlsdGVyczogdXBkYXRlZEZpbHRlcnMsXG4gICAgZGF0YXNldHM6IGZpbHRlcmVkLFxuICAgIHByZXNlcnZlRmlsdGVyT3JkZXIsXG4gICAgZmlsdGVyVG9CZU1lcmdlZDogWy4uLnN0YXRlLmZpbHRlclRvQmVNZXJnZWQsIC4uLmZhaWxlZF1cbiAgfTtcbn1cblxuLy8gcmVwbGFjZSBkYXRhSWQgaW4gc2F2ZWQgRmlsdGVyXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUZpbHRlckRhdGFzZXRJZHMoXG4gIHNhdmVkRmlsdGVyOiBGaWx0ZXJbXSxcbiAgZGF0YUlkOiBzdHJpbmcsXG4gIGRhdGFJZFRvVXNlOiBzdHJpbmdcbikge1xuICBjb25zdCByZXBsYWNlZDogRmlsdGVyW10gPSBbXTtcbiAgc2F2ZWRGaWx0ZXIuZm9yRWFjaChmaWx0ZXIgPT4ge1xuICAgIGlmIChmaWx0ZXIuZGF0YUlkLmluY2x1ZGVzKGRhdGFJZCkpIHtcbiAgICAgIGNvbnN0IG5ld0RhdGFJZCA9IGZpbHRlci5kYXRhSWQubWFwKGQgPT4gKGQgPT09IGRhdGFJZCA/IGRhdGFJZFRvVXNlIDogZCkpO1xuICAgICAgbGV0IHBsb3RUeXBlO1xuICAgICAgLy8gVE9ETzogbW9yZSBnZW5lcmljIGFwcHJvYWNoIHRvIHNhdmUgcGxvdFR5cGUuY29sb3JzQnlEYXRhSWRcbiAgICAgIGlmIChmaWx0ZXIucGxvdFR5cGU/LmNvbG9yc0J5RGF0YUlkPy5bZGF0YUlkXSkge1xuICAgICAgICAvLyByZXBsYWNlIGNvbG9yQnlEYXRhSWQgaW4gZmlsdGVyLnBsb3RUeXBlXG4gICAgICAgIGNvbnN0IHtbZGF0YUlkXTogY29sb3IsIC4uLnJlc3R9ID0gZmlsdGVyLnBsb3RUeXBlPy5jb2xvcnNCeURhdGFJZCB8fCB7fTtcbiAgICAgICAgcGxvdFR5cGUgPSB7XG4gICAgICAgICAgLi4uZmlsdGVyLnBsb3RUeXBlLFxuICAgICAgICAgIGNvbG9yc0J5RGF0YUlkOiB7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgW2RhdGFJZFRvVXNlXTogY29sb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXBsYWNlZC5wdXNoKHtcbiAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICBkYXRhSWQ6IG5ld0RhdGFJZCxcbiAgICAgICAgLi4uKHBsb3RUeXBlID8ge3Bsb3RUeXBlfSA6IHt9KVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlcGxhY2VkLmxlbmd0aCA/IHJlcGxhY2VkIDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2F2ZWRMYXllckNvbmZpZ1YxKGxheWVyQ29uZmlnOiBhbnkpOiBib29sZWFuIHtcbiAgLy8gZXhwb3J0ZWQgbGF5ZXIgY29uZmlndXJhdGlvbiBjb250YWlucyB2aXN1YWxDaGFubmVscyBwcm9wZXJ0eVxuICByZXR1cm4gbGF5ZXJDb25maWc/LnZpc3VhbENoYW5uZWxzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VMYXllckNvbmZpZyhcbiAgc2NoZW1hOiBLZXBsZXJHTFNjaGVtYUNsYXNzLFxuICBsYXllckNvbmZpZzogYW55XG4pOiBQYXJzZWRMYXllciB8IHVuZGVmaW5lZCB7XG4gIC8vIGFzc3VtZSB0aGUgbGF5ZXIgY29uZmlnIGlzIGN1cnJlbnQgdmVyc2lvblxuICBjb25zdCBzYXZlZENvbmZpZyA9IHtcbiAgICB2ZXJzaW9uOiBDVVJSRU5UX1ZFUlNJT04sXG4gICAgY29uZmlnOiB7XG4gICAgICB2aXNTdGF0ZToge2xheWVyczogW2xheWVyQ29uZmlnXSwgbGF5ZXJPcmRlcjogW2xheWVyQ29uZmlnLmlkXX1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNjaGVtYS5wYXJzZVNhdmVkQ29uZmlnKHNhdmVkQ29uZmlnKT8udmlzU3RhdGU/LmxheWVycz8uWzBdO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRJdGVtQmFzZWRPblByZXNlcnZlZE9yZGVyKFxuICBjdXJyZW50SXRlbXM6IEZpbHRlcltdLFxuICBpdGVtczogRmlsdGVyW10sXG4gIHByZXNlcnZlZE9yZGVyOiBhbnlbXSA9IFtdLFxuICBkZWZhdWx0U3RhcnQ/OiBib29sZWFuXG4pIHtcbiAgbGV0IG5ld0l0ZW1zID0gWy4uLmN1cnJlbnRJdGVtc107XG5cbiAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgY29uc3QgZXhwZWN0ZWRJZHggPSBwcmVzZXJ2ZWRPcmRlci5pbmRleE9mKGl0ZW0uaWQpO1xuICAgIC8vIGluc2VydEF0IHRoZSBlbmQgYnkgZGVmYXVsdFxuICAgIGxldCBpbnNlcnRBdCA9IGRlZmF1bHRTdGFydCA/IDAgOiBuZXdJdGVtcy5sZW5ndGg7XG4gICAgaWYgKGV4cGVjdGVkSWR4ID4gMCkge1xuICAgICAgLy8gbG9vayBmb3IgbGF5ZXIgdG8gaW5zZXJ0IGFmdGVyXG4gICAgICBsZXQgaSA9IGV4cGVjdGVkSWR4ICsgMTtcbiAgICAgIGxldCBwcmVjZWVkSWR4ID0gLTE7XG4gICAgICB3aGlsZSAoaS0tID4gMCAmJiBwcmVjZWVkSWR4IDwgMCkge1xuICAgICAgICAvLyBrZWVwIGxvb2tpbmcgZm9yIHByZWNlZWQgbGF5ZXIgdGhhdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICBjb25zdCBwcmVjZWVkSXRlbUlkID0gcHJlc2VydmVkT3JkZXJbaSAtIDFdO1xuICAgICAgICBwcmVjZWVkSWR4ID0gbmV3SXRlbXMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gcHJlY2VlZEl0ZW1JZCk7XG4gICAgICB9XG4gICAgICBpZiAocHJlY2VlZElkeCA+IC0xKSB7XG4gICAgICAgIC8vIGlmIGZvdW5kXG4gICAgICAgIGluc2VydEF0ID0gcHJlY2VlZElkeCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIG5ld0l0ZW1zID0gYXJyYXlJbnNlcnQobmV3SXRlbXMsIGluc2VydEF0LCBpdGVtKTtcbiAgfVxuICByZXR1cm4gbmV3SXRlbXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMYXllckZyb21Db25maWcoc3RhdGU6IFZpc1N0YXRlLCBsYXllckNvbmZpZzogYW55KTogTGF5ZXIgfCBudWxsIHtcbiAgLy8gY2hlY2sgaWYgdGhlIGxheWVyIGNvbmZpZyBpcyBwYXJzZWRcbiAgY29uc3QgcGFyc2VkTGF5ZXJDb25maWcgPSBpc1NhdmVkTGF5ZXJDb25maWdWMShsYXllckNvbmZpZylcbiAgICA/IHBhcnNlTGF5ZXJDb25maWcoc3RhdGUuc2NoZW1hLCBsYXllckNvbmZpZylcbiAgICA6IGxheWVyQ29uZmlnO1xuXG4gIGlmICghcGFyc2VkTGF5ZXJDb25maWcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBmaXJzdCB2YWxpZGF0ZSBjb25maWcgYWdhaW5zdCBkYXRhc2V0XG4gIGNvbnN0IHt2YWxpZGF0ZWQsIGZhaWxlZH0gPSB2YWxpZGF0ZUxheWVyc0J5RGF0YXNldHMoXG4gICAgc3RhdGUuZGF0YXNldHMsXG4gICAgc3RhdGUubGF5ZXJDbGFzc2VzLFxuICAgIFtwYXJzZWRMYXllckNvbmZpZ10sXG4gICAge2FsbG93RW1wdHlDb2x1bW46IHRydWV9XG4gICk7XG5cbiAgaWYgKGZhaWxlZD8ubGVuZ3RoIHx8ICF2YWxpZGF0ZWQubGVuZ3RoKSB7XG4gICAgLy8gZmFpbGVkXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBuZXdMYXllciA9IHZhbGlkYXRlZFswXTtcbiAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJEb21haW4oc3RhdGUuZGF0YXNldHMpO1xuICByZXR1cm4gbmV3TGF5ZXI7XG59XG5cbi8qKlxuICogR2V0IGxvYWRlZCBmaWx0ZXIgZnJvbSBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplRmlsdGVyKFxuICBuZXdGaWx0ZXI6IEZpbHRlcixcbiAgc2NoZW1hOiBLZXBsZXJHTFNjaGVtYUNsYXNzXG4pOiBQYXJzZWRGaWx0ZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCBzZXJpYWxpemVkVmlzU3RhdGUgPSBzZXJpYWxpemVWaXNTdGF0ZSh7ZmlsdGVyczogW25ld0ZpbHRlcl19LCBzY2hlbWEpO1xuICByZXR1cm4gc2VyaWFsaXplZFZpc1N0YXRlPy5maWx0ZXJzPy5bMF07XG59XG5cbi8qKlxuICogR2V0IGxvYWRlZCBsYXllciBmcm9tIHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVMYXllcihcbiAgbmV3TGF5ZXI6IExheWVyLFxuICBzY2hlbWE6IEtlcGxlckdMU2NoZW1hQ2xhc3Ncbik6IFBhcnNlZExheWVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc2VyaWFsaXplZFZpc1N0YXRlID0gc2VyaWFsaXplVmlzU3RhdGUoXG4gICAge2xheWVyczogW25ld0xheWVyXSwgbGF5ZXJPcmRlcjogW25ld0xheWVyLmlkXX0sXG4gICAgc2NoZW1hXG4gICk7XG4gIHJldHVybiBzZXJpYWxpemVkVmlzU3RhdGU/LmxheWVycz8uWzBdO1xufVxuXG4vKipcbiAqIEdldCBsb2FkZWQgZWZmZWN0IGZyb20gc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUVmZmVjdChcbiAgbmV3RWZmZWN0OiBFZmZlY3RUeXBlLFxuICBzY2hlbWE6IEtlcGxlckdMU2NoZW1hQ2xhc3Ncbik6IFBhcnNlZEVmZmVjdCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHNlcmlhbGl6ZWRWaXNTdGF0ZSA9IHNlcmlhbGl6ZVZpc1N0YXRlKFxuICAgIHtlZmZlY3RzOiBbbmV3RWZmZWN0XSwgZWZmZWN0T3JkZXI6IFtuZXdFZmZlY3QuaWRdfSxcbiAgICBzY2hlbWFcbiAgKTtcbiAgcmV0dXJuIHNlcmlhbGl6ZWRWaXNTdGF0ZT8uZWZmZWN0cz8uWzBdO1xufVxuXG4vKipcbiAqIEdldCB2aXMgc3RhdGUgY29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVWaXNTdGF0ZShcbiAgdmlzU3RhdGU6IFBhcnRpYWw8VmlzU3RhdGU+LFxuICBzY2hlbWE6IEtlcGxlckdMU2NoZW1hQ2xhc3Ncbik6IFBhcnNlZFZpc1N0YXRlIHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc2F2ZWRTdGF0ZSA9IHNjaGVtYS5nZXRDb25maWdUb1NhdmUoe1xuICAgIHZpc1N0YXRlXG4gIH0pO1xuICByZXR1cm4gc2F2ZWRTdGF0ZSA/IHNjaGVtYS5wYXJzZVNhdmVkQ29uZmlnKHNhdmVkU3RhdGUpPy52aXNTdGF0ZSA6IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogTWVyZ2UgbGF5ZXJzIGZyb20gZGUtc2VyaWFsaXplZCBzdGF0ZSwgaWYgbm8gZmllbGRzIG9yIGRhdGEgYXJlIGxvYWRlZFxuICogc2F2ZSBpdCBmb3IgbGF0ZXJcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUxheWVyczxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgbGF5ZXJzVG9NZXJnZTogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnbGF5ZXJzJ10gPSBbXSxcbiAgZnJvbUNvbmZpZz86IGJvb2xlYW5cbik6IFMge1xuICBjb25zdCBwcmVzZXJ2ZUxheWVyT3JkZXIgPSBmcm9tQ29uZmlnXG4gICAgPyBnZXRMYXllck9yZGVyRnJvbUxheWVycyhsYXllcnNUb01lcmdlKVxuICAgIDogc3RhdGUucHJlc2VydmVMYXllck9yZGVyO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGF5ZXJzVG9NZXJnZSkgfHwgIWxheWVyc1RvTWVyZ2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIC8vIGRvbid0IG1lcmdlIGxheWVyIGlmIGRhdGFzZXQgaXMgYmVpbmcgbWVyZ2VkXG4gIGNvbnN0IHVubWVyZ2VkOiBQYXJzZWRMYXllcltdID0gW107XG4gIGNvbnN0IHRvTWVyZ2U6IFBhcnNlZExheWVyW10gPSBbXTtcbiAgbGF5ZXJzVG9NZXJnZS5mb3JFYWNoKChsOiBQYXJzZWRMYXllcikgPT4ge1xuICAgIGlmIChsPy5jb25maWc/LmRhdGFJZCAmJiBzdGF0ZS5pc01lcmdpbmdEYXRhc2V0c1tsLmNvbmZpZy5kYXRhSWRdKSB7XG4gICAgICB1bm1lcmdlZC5wdXNoKGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b01lcmdlLnB1c2gobCk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCB7dmFsaWRhdGVkOiBtZXJnZWRMYXllciwgZmFpbGVkfSA9IHZhbGlkYXRlTGF5ZXJzQnlEYXRhc2V0cyhcbiAgICBzdGF0ZS5kYXRhc2V0cyxcbiAgICBzdGF0ZS5sYXllckNsYXNzZXMsXG4gICAgdG9NZXJnZVxuICApO1xuICB1bm1lcmdlZC5wdXNoKC4uLmZhaWxlZCk7XG4gIC8vIHB1dCBuZXcgbGF5ZXJzIGluIGZyb250IG9mIGN1cnJlbnQgbGF5ZXJzXG4gIGNvbnN0IHtuZXdMYXllck9yZGVyLCBuZXdMYXllcnN9ID0gaW5zZXJ0TGF5ZXJBdFJpZ2h0T3JkZXIoXG4gICAgc3RhdGUubGF5ZXJzLFxuICAgIG1lcmdlZExheWVyLFxuICAgIHN0YXRlLmxheWVyT3JkZXIsXG4gICAgcHJlc2VydmVMYXllck9yZGVyXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IG5ld0xheWVycyxcbiAgICBsYXllck9yZGVyOiBuZXdMYXllck9yZGVyLFxuICAgIHByZXNlcnZlTGF5ZXJPcmRlcixcbiAgICBsYXllclRvQmVNZXJnZWQ6IFsuLi5zdGF0ZS5sYXllclRvQmVNZXJnZWQsIC4uLnVubWVyZ2VkXVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0TGF5ZXJBdFJpZ2h0T3JkZXIoXG4gIGN1cnJlbnRMYXllcnMsXG4gIGxheWVyc1RvSW5zZXJ0LFxuICBjdXJyZW50T3JkZXIsXG4gIHByZXNlcnZlZE9yZGVyOiBzdHJpbmdbXSA9IFtdXG4pIHtcbiAgaWYgKCFsYXllcnNUb0luc2VydD8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHtuZXdMYXllcnM6IGN1cnJlbnRMYXllcnMsIG5ld0xheWVyT3JkZXI6IGN1cnJlbnRPcmRlcn07XG4gIH1cbiAgLy8gcGVyc2VydmVkT3JkZXIgWydhJywgJ2InLCAnYyddO1xuICAvLyBsYXllck9yZGVyIFsnYScsICdiJywgJ2MnXVxuICBjb25zdCBjdXJyZW50TGF5ZXJRdWV1ZSA9IGN1cnJlbnRPcmRlclxuICAgIC5tYXAoaWQgPT4gZmluZEJ5SWQoaWQpKGN1cnJlbnRMYXllcnMpKVxuICAgIC5maWx0ZXIobGF5ZXIgPT4gQm9vbGVhbihsYXllcikpO1xuICBjb25zdCBuZXdMYXllcnMgPSBjdXJyZW50TGF5ZXJzLmNvbmNhdChsYXllcnNUb0luc2VydCk7XG4gIGNvbnN0IG5ld0xheWVyT3JkZXJRdWV1ZSA9IGluc2VydEl0ZW1CYXNlZE9uUHJlc2VydmVkT3JkZXIoXG4gICAgY3VycmVudExheWVyUXVldWUsXG4gICAgbGF5ZXJzVG9JbnNlcnQsXG4gICAgcHJlc2VydmVkT3JkZXIsXG4gICAgdHJ1ZVxuICApO1xuXG4gIC8vIHJlY29uc3RydWN0IGxheWVyT3JkZXIgYWZ0ZXIgaW5zZXJ0XG4gIGNvbnN0IG5ld0xheWVyT3JkZXIgPSBnZXRMYXllck9yZGVyRnJvbUxheWVycyhuZXdMYXllck9yZGVyUXVldWUpO1xuXG4gIHJldHVybiB7XG4gICAgbmV3TGF5ZXJPcmRlcixcbiAgICBuZXdMYXllcnNcbiAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZSBpbnRlcmFjdGlvbnMgd2l0aCBzYXZlZCBjb25maWdcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUludGVyYWN0aW9uczxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkOiBQYXJ0aWFsPFNhdmVkSW50ZXJhY3Rpb25Db25maWc+IHwgdW5kZWZpbmVkXG4pOiBTIHtcbiAgY29uc3QgbWVyZ2VkOiBOZXN0ZWRQYXJ0aWFsPFNhdmVkSW50ZXJhY3Rpb25Db25maWc+ID0ge307XG4gIGNvbnN0IHVubWVyZ2VkOiBQYXJ0aWFsPFNhdmVkSW50ZXJhY3Rpb25Db25maWc+ID0ge307XG5cbiAgaWYgKGludGVyYWN0aW9uVG9CZU1lcmdlZCkge1xuICAgIChPYmplY3Qua2V5cyhpbnRlcmFjdGlvblRvQmVNZXJnZWQpIGFzIEFycmF5PGtleW9mIFNhdmVkSW50ZXJhY3Rpb25Db25maWc+KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIXN0YXRlLmludGVyYWN0aW9uQ29uZmlnW2tleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyZW50Q29uZmlnID1cbiAgICAgICAga2V5ID09PSAndG9vbHRpcCcgfHwga2V5ID09PSAnYnJ1c2gnID8gc3RhdGUuaW50ZXJhY3Rpb25Db25maWdba2V5XS5jb25maWcgOiBudWxsO1xuXG4gICAgICBjb25zdCB7ZW5hYmxlZCwgLi4uY29uZmlnU2F2ZWR9ID0gaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkW2tleV0gfHwge307XG5cbiAgICAgIGxldCBjb25maWdUb01lcmdlID0gY29uZmlnU2F2ZWQ7XG5cbiAgICAgIGlmIChrZXkgPT09ICd0b29sdGlwJykge1xuICAgICAgICBjb25zdCB7bWVyZ2VkVG9vbHRpcCwgdW5tZXJnZWRUb29sdGlwfSA9IG1lcmdlSW50ZXJhY3Rpb25Ub29sdGlwQ29uZmlnKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGNvbmZpZ1NhdmVkIGFzIFNhdmVkSW50ZXJhY3Rpb25Db25maWdbJ3Rvb2x0aXAnXVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIG1lcmdlIG5ldyBkYXRhc2V0IHRvb2x0aXBzIHdpdGggb3JpZ2luYWwgZGF0YXNldCB0b29sdGlwc1xuICAgICAgICBjb25maWdUb01lcmdlID0ge1xuICAgICAgICAgIGZpZWxkc1RvU2hvdzoge1xuICAgICAgICAgICAgLi4uKGN1cnJlbnRDb25maWcgYXMgVG9vbHRpcEluZm9bJ2NvbmZpZyddKS5maWVsZHNUb1Nob3csXG4gICAgICAgICAgICAuLi5tZXJnZWRUb29sdGlwXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh1bm1lcmdlZFRvb2x0aXApLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICB1bm1lcmdlZC50b29sdGlwID0ge2ZpZWxkc1RvU2hvdzogdW5tZXJnZWRUb29sdGlwLCBlbmFibGVkOiBCb29sZWFuKGVuYWJsZWQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZXJnZWRba2V5XSA9IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWdba2V5XSxcbiAgICAgICAgZW5hYmxlZDogQm9vbGVhbihlbmFibGVkKSxcbiAgICAgICAgLi4uKGN1cnJlbnRDb25maWdcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgY29uZmlnOiBwaWNrKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIC4uLmN1cnJlbnRDb25maWcsXG4gICAgICAgICAgICAgICAgICAuLi5jb25maWdUb01lcmdlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjdXJyZW50Q29uZmlnKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgaW50ZXJhY3Rpb25Db25maWc6IHtcbiAgICAgIC4uLnN0YXRlLmludGVyYWN0aW9uQ29uZmlnLFxuICAgICAgLi4ubWVyZ2VkXG4gICAgfSxcbiAgICBpbnRlcmFjdGlvblRvQmVNZXJnZWQ6IHNhdmVkVW5tZXJnZWRJbnRlcmFjdGlvbihzdGF0ZSwgdW5tZXJnZWQpXG4gIH07XG4gIHJldHVybiBuZXh0U3RhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVJbnRlcmFjdGlvbkNvbmZpZ3MoY29uZmlnczogU2F2ZWRJbnRlcmFjdGlvbkNvbmZpZ1tdKTogU2F2ZWRJbnRlcmFjdGlvbkNvbmZpZyB7XG4gIGNvbnN0IGNvbWJpbmVkID0gey4uLmNvbmZpZ3NbMF19O1xuICAvLyBoYW5kbGUgZWFjaCBwcm9wZXJ0eSBrZXkgb2YgYW4gYEludGVyYWN0aW9uQ29uZmlnYCwgZS5nLiB0b29sdGlwLCBnZW9jb2RlciwgYnJ1c2gsIGNvb3JkaW5hdGVcbiAgLy8gYnkgY29tYmluaW5nIHZhbHVlcyBmb3IgZWFjaCBhbW9uZyBhbGwgcGFzc2VkIGluIGNvbmZpZ3NcblxuICBmb3IgKGNvbnN0IGtleSBpbiBjb21iaW5lZCkge1xuICAgIGNvbnN0IHRvQmVDb21iaW5lZFByb3BzID0gY29uZmlncy5tYXAoYyA9PiBjW2tleV0pO1xuXG4gICAgLy8gYWxsIG9mIHRoZXNlIGhhdmUgYW4gZW5hYmxlZCBib29sZWFuXG4gICAgY29tYmluZWRba2V5XSA9IHtcbiAgICAgIC8vIGFyZSBhbnkgb2YgdGhlIGNvbmZpZ3MnIGVuYWJsZWQgdmFsdWVzIHRydWU/XG4gICAgICBlbmFibGVkOiB0b0JlQ29tYmluZWRQcm9wcy5zb21lKHAgPT4gcD8uZW5hYmxlZClcbiAgICB9O1xuXG4gICAgaWYgKGtleSA9PT0gJ3Rvb2x0aXAnKSB7XG4gICAgICAvLyBhcmUgYW55IG9mIHRoZSBjb25maWdzJyBjb21wYXJlTW9kZSB2YWx1ZXMgdHJ1ZT9cbiAgICAgIGNvbWJpbmVkW2tleV0uY29tcGFyZU1vZGUgPSB0b0JlQ29tYmluZWRQcm9wcy5zb21lKHAgPT4gcD8uY29tcGFyZU1vZGUpO1xuXG4gICAgICAvLyByZXR1cm4gdGhlIGNvbXBhcmUgdHlwZSBtb2RlLCBpdCB3aWxsIGJlIGVpdGhlciBhYnNvbHV0ZSBvciByZWxhdGl2ZVxuICAgICAgY29tYmluZWRba2V5XS5jb21wYXJlVHlwZSA9IGdldFZhbHVlV2l0aEhpZ2hlc3RPY2N1cnJlbmNlKFxuICAgICAgICB0b0JlQ29tYmluZWRQcm9wcy5tYXAocCA9PiBwLmNvbXBhcmVUeXBlKVxuICAgICAgKTtcblxuICAgICAgLy8gY29tYmluZSBmaWVsZHNUb1Nob3cgYW1vbmcgYWxsIGRhdGFzZXQgaWRzXG4gICAgICBjb21iaW5lZFtrZXldLmZpZWxkc1RvU2hvdyA9IHRvQmVDb21iaW5lZFByb3BzXG4gICAgICAgIC5tYXAocCA9PiBwLmZpZWxkc1RvU2hvdylcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBuZXh0RmllbGRzVG9TaG93KSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBuZXh0RGF0YUlkS2V5IGluIG5leHRGaWVsZHNUb1Nob3cpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUb29sdGlwRmllbGRzID0gbmV4dEZpZWxkc1RvU2hvd1tuZXh0RGF0YUlkS2V5XTtcbiAgICAgICAgICAgIGlmICghYWNjW25leHREYXRhSWRLZXldKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBkYXRhc2V0IGlkIGlzIG5vdCBwcmVzZW50IGluIHRoZSBhY2N1bXVsYXRvclxuICAgICAgICAgICAgICAvLyB0aGVuIGFkZCBpdCB3aXRoIGl0cyB0b29sdGlwIGZpZWxkc1xuICAgICAgICAgICAgICBhY2NbbmV4dERhdGFJZEtleV0gPSBuZXh0VG9vbHRpcEZpZWxkcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGUgZGF0YXNldCBpZCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIGFjY3VtdWxhdG9yXG4gICAgICAgICAgICAgIC8vIHNvIG9ubHkgYWRkIHRoZSBuZXh0IHRvb2x0aXAgZmllbGRzIGZvciB0aGlzIGRhdGFzZXQncyBhcnJheSBpZiB0aGV5IGFyZSBub3QgYWxyZWFkeSBwcmVzZW50LFxuICAgICAgICAgICAgICAvLyB1c2luZyB0aGUgdG9vbHRpcEZpZWxkLm5hbWUgcHJvcGVydHkgZm9yIHVuaXF1ZW5lc3NcbiAgICAgICAgICAgICAgbmV4dFRvb2x0aXBGaWVsZHMuZm9yRWFjaChuZXh0VEYgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYWNjW25leHREYXRhSWRLZXldLmZpbmQoKHtuYW1lfSkgPT4gbmV4dFRGLm5hbWUgPT09IG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBhY2NbbmV4dERhdGFJZEtleV0ucHVzaChuZXh0VEYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnYnJ1c2gnKSB7XG4gICAgICAvLyBrZWVwIHRoZSBiaWdnZXN0IGJydXNoIHNpemVcbiAgICAgIGNvbWJpbmVkW2tleV0uc2l6ZSA9XG4gICAgICAgIGFnZ3JlZ2F0ZSh0b0JlQ29tYmluZWRQcm9wcywgQUdHUkVHQVRJT05fVFlQRVMubWF4aW11bSwgcCA9PiBwLnNpemUpID8/IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmVkO1xufVxuXG5mdW5jdGlvbiBzYXZlZFVubWVyZ2VkSW50ZXJhY3Rpb248UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIHVubWVyZ2VkOiBQYXJ0aWFsPFNhdmVkSW50ZXJhY3Rpb25Db25maWc+XG4pIHtcbiAgaWYgKCF1bm1lcmdlZD8udG9vbHRpcD8uZmllbGRzVG9TaG93KSB7XG4gICAgcmV0dXJuIHN0YXRlLmludGVyYWN0aW9uVG9CZU1lcmdlZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIC4uLnN0YXRlLmludGVyYWN0aW9uVG9CZU1lcmdlZC50b29sdGlwLFxuICAgICAgLi4uKHR5cGVvZiB1bm1lcmdlZD8udG9vbHRpcD8uZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgID8ge2VuYWJsZWQ6IHVubWVyZ2VkLnRvb2x0aXAuZW5hYmxlZH1cbiAgICAgICAgOiB7fSksXG4gICAgICBmaWVsZHNUb1Nob3c6IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkPy50b29sdGlwPy5maWVsZHNUb1Nob3csXG4gICAgICAgIC4uLnVubWVyZ2VkPy50b29sdGlwPy5maWVsZHNUb1Nob3dcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VJbnRlcmFjdGlvbkRhdGFzZXRJZHMoaW50ZXJhY3Rpb25Db25maWcsIGRhdGFJZDogc3RyaW5nLCBkYXRhSWRUb1JlcGxhY2U6IHN0cmluZykge1xuICBpZiAoaW50ZXJhY3Rpb25Db25maWc/LnRvb2x0aXA/LmZpZWxkc1RvU2hvd1tkYXRhSWRdKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmludGVyYWN0aW9uQ29uZmlnLFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICAuLi5pbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLFxuICAgICAgICBmaWVsZHNUb1Nob3c6IHtcbiAgICAgICAgICBbZGF0YUlkVG9SZXBsYWNlXTogaW50ZXJhY3Rpb25Db25maWc/LnRvb2x0aXA/LmZpZWxkc1RvU2hvd1tkYXRhSWRdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIE1lcmdlIHNwbGl0TWFwcyBjb25maWcgd2l0aCBjdXJyZW50IHZpc1N0ZXRlLlxuICogMS4gaWYgY3VycmVudCBtYXAgaXMgc3BsaXQsIGJ1dCBzcGxpdE1hcCBET0VTTk9UIGNvbnRhaW4gbWFwc1xuICogICAgOiBkb24ndCBtZXJnZSBhbnl0aGluZ1xuICogMi4gaWYgY3VycmVudCBtYXAgaXMgTk9UIHNwbGl0LCBidXQgc3BsaXRNYXBzIGNvbnRhaW4gbWFwc1xuICogICAgOiBhZGQgdG8gc3BsaXRNYXBzLCBhbmQgYWRkIGN1cnJlbnQgbGF5ZXJzIHRvIHNwbGl0TWFwc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTcGxpdE1hcHM8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIHNwbGl0TWFwczogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnc3BsaXRNYXBzJ10gPSBbXVxuKTogUyB7XG4gIGNvbnN0IG1lcmdlZCA9IFsuLi5zdGF0ZS5zcGxpdE1hcHNdO1xuICBjb25zdCB1bm1lcmdlZCA9IFtdO1xuICBzcGxpdE1hcHMuZm9yRWFjaCgoc20sIGkpID0+IHtcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoc20ubGF5ZXJzKTtcbiAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goKFtpZCwgdmFsdWVdKSA9PiB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGxheWVyIGV4aXN0c1xuICAgICAgICBjb25zdCBwdXNoVG8gPSBzdGF0ZS5sYXllcnMuZmluZChsID0+IGwuaWQgPT09IGlkKSA/IG1lcmdlZCA6IHVubWVyZ2VkO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBtYXAgcGFuZWwgaWYgY3VycmVudCBtYXAgaXMgbm90IHNwbGl0XG4gICAgICAgIHB1c2hUb1tpXSA9IHB1c2hUb1tpXSB8fCB7XG4gICAgICAgICAgLy8ga2VlcCBpZFxuICAgICAgICAgIC4uLnNtLFxuICAgICAgICAgIGxheWVyczogcHVzaFRvID09PSBtZXJnZWQgPyBnZXRJbml0aWFsTWFwTGF5ZXJzRm9yU3BsaXRNYXAoc3RhdGUubGF5ZXJzKSA6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHB1c2hUb1tpXS5sYXllcnMgPSB7XG4gICAgICAgICAgLi4ucHVzaFRvW2ldLmxheWVycyxcbiAgICAgICAgICBbaWRdOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIGFyZSBtZXJnaW5nIGlmIHRoZXJlIGFyZSBubyBsYXllcnMgaW4gYm90aCBzcGxpdCBtYXBcbiAgICAgIG1lcmdlZC5wdXNoKHNtKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3BsaXRNYXBzOiBtZXJnZWQsXG4gICAgc3BsaXRNYXBzVG9CZU1lcmdlZDogWy4uLnN0YXRlLnNwbGl0TWFwc1RvQmVNZXJnZWQsIC4uLnVubWVyZ2VkXVxuICB9O1xufVxuXG4vKipcbiAqIE1lcmdlIGVmZmVjdHMgd2l0aCBzYXZlZCBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRWZmZWN0czxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgZWZmZWN0czogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnZWZmZWN0cyddLFxuICBmcm9tQ29uZmlnPzogYm9vbGVhblxuKTogUyB7XG4gIGNvbnN0IG5ld0VmZmVjdHMgPSBbXG4gICAgLi4uc3RhdGUuZWZmZWN0cyxcbiAgICAuLi4oZWZmZWN0cyB8fCBbXSlcbiAgICAgIC5tYXAoZWZmZWN0ID0+IHtcbiAgICAgICAgcmV0dXJuIGZyb21Db25maWdcbiAgICAgICAgICA/IGNyZWF0ZUVmZmVjdChcbiAgICAgICAgICAgICAgZGVlcG1lcmdlLmFsbChbXG4gICAgICAgICAgICAgICAgZWZmZWN0LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbGxhcHNlIGFsbCBwYW5lbHMgd2hlbiBsb2FkaW5nIGVmZmVjdHNcbiAgICAgICAgICAgICAgICAgIGlzQ29uZmlnQWN0aXZlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IChlZmZlY3QgYXMgRWZmZWN0VHlwZSk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihlZmZlY3QgPT4ge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihlZmZlY3QgJiYgZWZmZWN0LmlzVmFsaWRUb1NhdmUoKSk7XG4gICAgICB9KVxuICBdO1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVmZmVjdHM6IG5ld0VmZmVjdHMsXG4gICAgZWZmZWN0T3JkZXI6IG5ld0VmZmVjdHMubWFwKGVmZmVjdCA9PiBlZmZlY3QuaWQpXG4gIH07XG59XG5cbi8qKlxuICogTWVyZ2UgaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcCB3aXRoIHNhdmVkIGNvbmZpZyxcbiAqIHZhbGlkYXRlIGZpZWxkc1RvU2hvd1xuICpcbiAqIEBwYXJhbSBzdGF0ZVxuICogQHBhcmFtIHRvb2x0aXBDb25maWdcbiAqIEByZXR1cm4gLSB7bWVyZ2VkVG9vbHRpcDoge30sIHVubWVyZ2VkVG9vbHRpcDoge319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUludGVyYWN0aW9uVG9vbHRpcENvbmZpZyhcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB0b29sdGlwQ29uZmlnOiBQaWNrPFRvb2x0aXBJbmZvWydjb25maWcnXSwgJ2ZpZWxkc1RvU2hvdyc+IHwgbnVsbCA9IG51bGxcbikge1xuICBjb25zdCB1bm1lcmdlZFRvb2x0aXA6IFRvb2x0aXBJbmZvWydjb25maWcnXVsnZmllbGRzVG9TaG93J10gPSB7fTtcbiAgY29uc3QgbWVyZ2VkVG9vbHRpcDogVG9vbHRpcEluZm9bJ2NvbmZpZyddWydmaWVsZHNUb1Nob3cnXSA9IHt9O1xuXG4gIGlmIChcbiAgICAhdG9vbHRpcENvbmZpZyB8fFxuICAgICF0b29sdGlwQ29uZmlnLmZpZWxkc1RvU2hvdyB8fFxuICAgICFPYmplY3Qua2V5cyh0b29sdGlwQ29uZmlnLmZpZWxkc1RvU2hvdykubGVuZ3RoXG4gICkge1xuICAgIHJldHVybiB7bWVyZ2VkVG9vbHRpcCwgdW5tZXJnZWRUb29sdGlwfTtcbiAgfVxuXG4gIGZvciAoY29uc3QgZGF0YUlkIGluIHRvb2x0aXBDb25maWcuZmllbGRzVG9TaG93KSB7XG4gICAgaWYgKCFzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdIHx8IHN0YXRlLmlzTWVyZ2luZ0RhdGFzZXRzW2RhdGFJZF0pIHtcbiAgICAgIC8vIGlzIG5vdCB5ZXQgbG9hZGVkXG4gICAgICB1bm1lcmdlZFRvb2x0aXBbZGF0YUlkXSA9IHRvb2x0aXBDb25maWcuZmllbGRzVG9TaG93W2RhdGFJZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGRhdGFzZXQgaXMgbG9hZGVkXG4gICAgICBjb25zdCBhbGxGaWVsZHMgPSBzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdLmZpZWxkcy5tYXAoZCA9PiBkLm5hbWUpO1xuICAgICAgY29uc3QgZm91bmRGaWVsZHNUb1Nob3cgPSB0b29sdGlwQ29uZmlnLmZpZWxkc1RvU2hvd1tkYXRhSWRdLmZpbHRlcihmaWVsZCA9PlxuICAgICAgICBhbGxGaWVsZHMuaW5jbHVkZXMoZmllbGQubmFtZSlcbiAgICAgICk7XG5cbiAgICAgIG1lcmdlZFRvb2x0aXBbZGF0YUlkXSA9IGZvdW5kRmllbGRzVG9TaG93O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7bWVyZ2VkVG9vbHRpcCwgdW5tZXJnZWRUb29sdGlwfTtcbn1cbi8qKlxuICogTWVyZ2UgbGF5ZXJCbGVuZGluZyB3aXRoIHNhdmVkXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VMYXllckJsZW5kaW5nPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBsYXllckJsZW5kaW5nOiBOb25OdWxsYWJsZTxQYXJzZWRDb25maWdbJ3Zpc1N0YXRlJ10+WydsYXllckJsZW5kaW5nJ11cbik6IFMge1xuICBpZiAobGF5ZXJCbGVuZGluZyAmJiBMQVlFUl9CTEVORElOR1NbbGF5ZXJCbGVuZGluZ10pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBsYXllckJsZW5kaW5nXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBsYXllciBibGVuZGluZyBjb25maWdzIGludG8gYSBzaW5nbGUgc3RyaW5nXG4gKiBieSByZXR1cm5pbmcgdGhlIG9uZSB3aXRoIHRoZSBoaWdoZXN0IG9jY3VycmVuY2VcbiAqL1xuZnVuY3Rpb24gY29tYmluZUxheWVyQmxlbmRpbmdDb25maWdzKGNvbmZpZ3M6IHN0cmluZ1tdKTogc3RyaW5nIHwgbnVsbCB7XG4gIC8vIHJldHVybiB0aGUgbW9kZSBvZiB0aGUgbGF5ZXIgYmxlbmRpbmcgdHlwZVxuICByZXR1cm4gZ2V0VmFsdWVXaXRoSGlnaGVzdE9jY3VycmVuY2UoY29uZmlncyk7XG59XG5cbi8qKlxuICogTWVyZ2Ugb3ZlcmxheUJsZW5kaW5nIHdpdGggc2F2ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlT3ZlcmxheUJsZW5kaW5nPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBvdmVybGF5QmxlbmRpbmc6IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ292ZXJsYXlCbGVuZGluZyddXG4pOiBTIHtcbiAgaWYgKG92ZXJsYXlCbGVuZGluZyAmJiBPVkVSTEFZX0JMRU5ESU5HU1tvdmVybGF5QmxlbmRpbmddKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgb3ZlcmxheUJsZW5kaW5nXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBvdmVybGF5IGJsZW5kaW5nIGNvbmZpZ3MgaW50byBhIHNpbmdsZSBzdHJpbmdcbiAqIGJ5IHJldHVybmluZyB0aGUgb25lIHdpdGggdGhlIGhpZ2hlc3Qgb2NjdXJyZW5jZVxuICoqL1xuZnVuY3Rpb24gY29tYmluZU92ZXJsYXlCbGVuZGluZ0NvbmZpZ3MoY29uZmlnczogc3RyaW5nW10pOiBzdHJpbmcgfCBudWxsIHtcbiAgLy8gcmV0dXJuIHRoZSBtb2RlIG9mIHRoZSBvdmVybGF5IGJsZW5kaW5nIHR5cGVcbiAgcmV0dXJuIGdldFZhbHVlV2l0aEhpZ2hlc3RPY2N1cnJlbmNlKGNvbmZpZ3MpO1xufVxuXG4vKipcbiAqIE1lcmdlIGFuaW1hdGlvbiBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQW5pbWF0aW9uQ29uZmlnPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBhbmltYXRpb246IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2FuaW1hdGlvbkNvbmZpZyddXG4pOiBTIHtcbiAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24uY3VycmVudFRpbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgICAuLi5hbmltYXRpb24sXG4gICAgICAgIGRvbWFpbjogbnVsbFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBbmltYXRpb25Db25maWdzKGNvbmZpZ3M6IFNhdmVkQW5pbWF0aW9uQ29uZmlnW10pOiBTYXZlZEFuaW1hdGlvbkNvbmZpZyB7XG4gIC8vIGdldCB0aGUgc21hbGxlc3QgdmFsdWVzIG9mIGN1cnJlbnRUaW1lIGFuZCBzcGVlZCBhbW9uZyBhbGwgY29uZmlnc1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnRUaW1lOiBhZ2dyZWdhdGUoY29uZmlncywgQUdHUkVHQVRJT05fVFlQRVMubWluaW11bSwgYyA9PiBjLmN1cnJlbnRUaW1lKSA/PyBudWxsLFxuICAgIHNwZWVkOiBhZ2dyZWdhdGUoY29uZmlncywgQUdHUkVHQVRJT05fVFlQRVMubWluaW11bSwgYyA9PiBjLnNwZWVkKSA/PyBudWxsXG4gIH07XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc2F2ZWQgbGF5ZXIgY29sdW1ucyB3aXRoIG5ldyBkYXRhLFxuICogdXBkYXRlIGZpZWxkSWR4IGJhc2VkIG9uIG5ldyBmaWVsZHNcbiAqXG4gKiBAcGFyYW0gZmllbGRzXG4gKiBAcGFyYW0gc2F2ZWRDb2xzXG4gKiBAcGFyYW0gZW1wdHlDb2xzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybiAtIHZhbGlkYXRlZCBjb2x1bW5zIG9yIG51bGxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTYXZlZExheWVyQ29sdW1ucyhcbiAgZmllbGRzOiBLZXBsZXJUYWJsZVsnZmllbGRzJ10sXG4gIHNhdmVkQ29sczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZztcbiAgfSA9IHt9LFxuICBlbXB0eUNvbHM6IExheWVyQ29sdW1ucyxcbiAgb3B0aW9uczoge3Rocm93T25FcnJvcj86IGJvb2xlYW59ID0ge31cbikge1xuICAvLyBQcmVwYXJlIGNvbHVtbnMgZm9yIHRoZSB2YWxpZGF0b3JcbiAgY29uc3QgY29sdW1uczogdHlwZW9mIGVtcHR5Q29scyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhlbXB0eUNvbHMpKSB7XG4gICAgY29sdW1uc1trZXldID0gey4uLmVtcHR5Q29sc1trZXldfTtcblxuICAgIGNvbnN0IHNhdmVkID0gc2F2ZWRDb2xzW2tleV07XG4gICAgaWYgKHNhdmVkKSB7XG4gICAgICBjb25zdCBmaWVsZElkeCA9IGZpZWxkcy5maW5kSW5kZXgoKHtuYW1lfSkgPT4gbmFtZSA9PT0gc2F2ZWQpO1xuXG4gICAgICBpZiAoZmllbGRJZHggPiAtMSkge1xuICAgICAgICAvLyB1cGRhdGUgZm91bmQgY29sdW1uc1xuICAgICAgICBjb2x1bW5zW2tleV0uZmllbGRJZHggPSBmaWVsZElkeDtcbiAgICAgICAgY29sdW1uc1trZXldLnZhbHVlID0gc2F2ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZmluZCBhY3R1YWwgY29sdW1uIGZpZWxkSWR4LCBpbiBjYXNlIGl0IGhhcyBjaGFuZ2VkXG4gIGNvbnN0IGFsbENvbEZvdW5kID0gT2JqZWN0LmtleXMoY29sdW1ucykuZXZlcnkoa2V5ID0+XG4gICAgdmFsaWRhdGVDb2x1bW4oY29sdW1uc1trZXldLCBjb2x1bW5zLCBmaWVsZHMpXG4gICk7XG5cbiAgY29uc3QgcnYgPSBhbGxDb2xGb3VuZCA/IGNvbHVtbnMgOiBudWxsO1xuICBpZiAob3B0aW9ucy50aHJvd09uRXJyb3IpIHtcbiAgICBjb25zdCByZXF1aXJlZENvbHVtbnMgPSBPYmplY3Qua2V5cyhlbXB0eUNvbHMpLmZpbHRlcihrID0+ICFlbXB0eUNvbHNba10ub3B0aW9uYWwpO1xuICAgIGNvbnN0IG1pc3NpbmdDb2x1bW5zID0gcmVxdWlyZWRDb2x1bW5zLmZpbHRlcihrID0+ICFjb2x1bW5zPy5ba10udmFsdWUpO1xuICAgIGlmIChtaXNzaW5nQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgaGFzIG1pc3Npbmcgb3IgaW52YWxpZCBjb2x1bW5zOiAke21pc3NpbmdDb2x1bW5zLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZ0NvbHVtbnMgPSBPYmplY3Qua2V5cyhzYXZlZENvbHMpO1xuICAgIGNvbnN0IGludmFsaWRDb2x1bW5zID0gY29uZmlnQ29sdW1ucy5maWx0ZXIoayA9PiAhY29sdW1ucz8uW2tdPy52YWx1ZSk7XG4gICAgaWYgKGludmFsaWRDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciBoYXMgaW52YWxpZCBjb2x1bW5zOiAke2ludmFsaWRDb2x1bW5zLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGxheWVyIGNvbHVtblxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDb2x1bW4oXG4gIGNvbHVtbjogTGF5ZXJDb2x1bW4gJiB7dmFsaWRhdG9yPzogdHlwZW9mIHZhbGlkYXRlQ29sdW1ufSxcbiAgY29sdW1uczogTGF5ZXJDb2x1bW5zLFxuICBhbGxGaWVsZHM6IEtlcGxlclRhYmxlWydmaWVsZHMnXVxuKTogYm9vbGVhbiB7XG4gIGlmIChjb2x1bW4ub3B0aW9uYWwgfHwgY29sdW1uLnZhbHVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNvbHVtbi52YWxpZGF0b3IpIHtcbiAgICByZXR1cm4gY29sdW1uLnZhbGlkYXRvcihjb2x1bW4sIGNvbHVtbnMsIGFsbEZpZWxkcyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHNhdmVkIHRleHQgbGFiZWwgY29uZmlnIHdpdGggbmV3IGRhdGFcbiAqIHJlZmVyIHRvIHZpcy1zdGF0ZS1zY2hlbWEuanMgVGV4dExhYmVsU2NoZW1hVjFcbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGZpZWxkc1xuICogQHBhcmFtIHtPYmplY3R9IHNhdmVkVGV4dExhYmVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSAtIHZhbGlkYXRlZCB0ZXh0bGFiZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2F2ZWRUZXh0TGFiZWwoXG4gIGZpZWxkcyxcbiAgW2xheWVyVGV4dExhYmVsXSxcbiAgc2F2ZWRUZXh0TGFiZWwsXG4gIG9wdGlvbnM6IHt0aHJvd09uRXJyb3I/OiBib29sZWFufSA9IHt9XG4pIHtcbiAgY29uc3Qgc2F2ZWRUZXh0TGFiZWxzID0gQXJyYXkuaXNBcnJheShzYXZlZFRleHRMYWJlbCkgPyBzYXZlZFRleHRMYWJlbCA6IFtzYXZlZFRleHRMYWJlbF07XG5cbiAgLy8gdmFsaWRhdGUgZmllbGRcbiAgcmV0dXJuIHNhdmVkVGV4dExhYmVscy5tYXAodGV4dExhYmVsID0+IHtcbiAgICBjb25zdCBmaWVsZCA9IHRleHRMYWJlbC5maWVsZFxuICAgICAgPyBmaWVsZHMuZmluZChmZCA9PlxuICAgICAgICAgIE9iamVjdC5rZXlzKHRleHRMYWJlbC5maWVsZCkuZXZlcnkoa2V5ID0+IHRleHRMYWJlbC5maWVsZFtrZXldID09PSBmZFtrZXldKVxuICAgICAgICApXG4gICAgICA6IG51bGw7XG5cbiAgICBpZiAoZmllbGQgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRocm93T25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciBoYXMgaW52YWxpZCB0ZXh0IGxhYmVsIGZpZWxkOiAke0pTT04uc3RyaW5naWZ5KHRleHRMYWJlbC5maWVsZCl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxheWVyVGV4dExhYmVsKS5yZWR1Y2UoXG4gICAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICBba2V5XToga2V5ID09PSAnZmllbGQnID8gZmllbGQgOiB0ZXh0TGFiZWxba2V5XSB8fCBsYXllclRleHRMYWJlbFtrZXldXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc2F2ZWQgdmlzdWFsIGNoYW5uZWxzIGNvbmZpZyB3aXRoIG5ldyBkYXRhLFxuICogcmVmZXIgdG8gdmlzLXN0YXRlLXNjaGVtYS5qcyBWaXN1YWxDaGFubmVsU2NoZW1hVjFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2F2ZWRWaXN1YWxDaGFubmVscyhcbiAgZmllbGRzOiBLZXBsZXJUYWJsZVsnZmllbGRzJ10sXG4gIG5ld0xheWVyOiBMYXllcixcbiAgc2F2ZWRMYXllcjogUGFyc2VkTGF5ZXIsXG4gIG9wdGlvbnM6IHt0aHJvd09uRXJyb3I/OiBib29sZWFufSA9IHt9XG4pOiBudWxsIHwgTGF5ZXIge1xuICBPYmplY3QudmFsdWVzKG5ld0xheWVyLnZpc3VhbENoYW5uZWxzKS5mb3JFYWNoKCh7ZmllbGQsIHNjYWxlLCBrZXl9KSA9PiB7XG4gICAgbGV0IGZvdW5kRmllbGQ7XG4gICAgaWYgKHNhdmVkTGF5ZXIuY29uZmlnKSB7XG4gICAgICBpZiAoc2F2ZWRMYXllci5jb25maWdbZmllbGRdKSB7XG4gICAgICAgIGZvdW5kRmllbGQgPSBmaWVsZHMuZmluZChcbiAgICAgICAgICBmZCA9PiBzYXZlZExheWVyLmNvbmZpZyAmJiBmZC5uYW1lID09PSBzYXZlZExheWVyLmNvbmZpZ1tmaWVsZF0ubmFtZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3VuZENoYW5uZWwgPSB7XG4gICAgICAgIC4uLihmb3VuZEZpZWxkID8ge1tmaWVsZF06IGZvdW5kRmllbGR9IDoge30pLFxuICAgICAgICAuLi4oc2F2ZWRMYXllci5jb25maWdbc2NhbGVdID8ge1tzY2FsZV06IHNhdmVkTGF5ZXIuY29uZmlnW3NjYWxlXX0gOiB7fSlcbiAgICAgIH07XG4gICAgICBpZiAoT2JqZWN0LmtleXMoZm91bmRDaGFubmVsKS5sZW5ndGgpIHtcbiAgICAgICAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoZm91bmRDaGFubmVsKTtcbiAgICAgIH1cblxuICAgICAgbmV3TGF5ZXIudmFsaWRhdGVWaXN1YWxDaGFubmVsKGtleSk7XG4gICAgICBpZiAob3B0aW9ucy50aHJvd09uRXJyb3IpIHtcbiAgICAgICAgY29uc3QgZmllbGROYW1lID0gc2F2ZWRMYXllci5jb25maWc/LltmaWVsZF0/Lm5hbWU7XG4gICAgICAgIGlmIChmaWVsZE5hbWUgJiYgZmllbGROYW1lICE9PSBuZXdMYXllci5jb25maWdbZmllbGRdPy5uYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciBoYXMgaW52YWxpZCB2aXN1YWwgY2hhbm5lbCBmaWVsZDogJHtmaWVsZH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdMYXllcjtcbn1cblxudHlwZSBWYWxpZGF0ZUxheWVyT3B0aW9uID0ge1xuICBhbGxvd0VtcHR5Q29sdW1uPzogYm9vbGVhbjtcbiAgdGhyb3dPbkVycm9yPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUxheWVyc0J5RGF0YXNldHMoXG4gIGRhdGFzZXRzOiBEYXRhc2V0cyxcbiAgbGF5ZXJDbGFzc2VzOiBWaXNTdGF0ZVsnbGF5ZXJDbGFzc2VzJ10sXG4gIGxheWVyczogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnbGF5ZXJzJ10gPSBbXSxcbiAgb3B0aW9ucz86IFZhbGlkYXRlTGF5ZXJPcHRpb25cbikge1xuICBjb25zdCB2YWxpZGF0ZWQ6IExheWVyW10gPSBbXTtcbiAgY29uc3QgZmFpbGVkOiBOb25OdWxsYWJsZTxQYXJzZWRDb25maWdbJ3Zpc1N0YXRlJ10+WydsYXllcnMnXSA9IFtdO1xuXG4gIGxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICBsZXQgdmFsaWRhdGVMYXllcjogTGF5ZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGlmIChsYXllcj8uY29uZmlnPy5kYXRhSWQpIHtcbiAgICAgIGlmIChkYXRhc2V0c1tsYXllci5jb25maWcuZGF0YUlkXSkge1xuICAgICAgICAvLyBkYXRhc2V0cyBhcmUgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgdmFsaWRhdGVMYXllciA9IHZhbGlkYXRlTGF5ZXJXaXRoRGF0YShcbiAgICAgICAgICBkYXRhc2V0c1tsYXllci5jb25maWcuZGF0YUlkXSxcbiAgICAgICAgICBsYXllcixcbiAgICAgICAgICBsYXllckNsYXNzZXMsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWxpZGF0ZUxheWVyKSB7XG4gICAgICB2YWxpZGF0ZWQucHVzaCh2YWxpZGF0ZUxheWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGF0YXNldHMgbm90IHlldCBsb2FkZWRcbiAgICAgIGZhaWxlZC5wdXNoKGxheWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7dmFsaWRhdGVkLCBmYWlsZWR9O1xufVxuXG4vKipcbiAqIEdldCByZXF1aXJlZCBjb2x1bW5zIGZvciB2YWxpZGF0aW9uIGJhc2VkIG9uIGNvbHVtbiBtb2RlXG4gKi9cbmZ1bmN0aW9uIF9nZXRDb2x1bW5Db25maWdGb3JWYWxpZGF0aW9uKG5ld0xheWVyKSB7XG4gIC8vIGZpbmQgY29sdW1uIGZpZWxkSWR4XG4gIGxldCBjb2x1bW5Db25maWcgPSBuZXdMYXllci5nZXRMYXllckNvbHVtbnMoKTtcbiAgLy8gaWYgY29sdW1uTW9kZSBpcyBkZWZpbmVkLCBmaW5kIGNvbHVtbiBtb2RlIGNvbmZpZ1xuICBjb25zdCBjb2xNb2RlQ29uZmlnID0gbmV3TGF5ZXIuY29uZmlnLmNvbHVtbk1vZGVcbiAgICA/IChuZXdMYXllci5zdXBwb3J0ZWRDb2x1bW5Nb2RlcyB8fCBbXSkuZmluZChcbiAgICAgICAgY29sTW9kZSA9PiBjb2xNb2RlLmtleSA9PT0gbmV3TGF5ZXIuY29uZmlnLmNvbHVtbk1vZGVcbiAgICAgIClcbiAgICA6IG51bGw7XG5cbiAgaWYgKGNvbE1vZGVDb25maWcpIHtcbiAgICAvLyBvbmx5IHZhbGlkYXRlIGNvbHVtbnMgaW4gY29sdW1uIG1vZGVcbiAgICBjb2x1bW5Db25maWcgPSBbXG4gICAgICAuLi4oY29sTW9kZUNvbmZpZy5yZXF1aXJlZENvbHVtbnMgfHwgW10pLFxuICAgICAgLi4uKGNvbE1vZGVDb25maWcub3B0aW9uYWxDb2x1bW5zIHx8IFtdKVxuICAgIF0ucmVkdWNlKFxuICAgICAgKGFjY3UsIGtleSkgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgW2tleV06IGNvbHVtbkNvbmZpZ1trZXldXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjb2x1bW5Db25maWc7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc2F2ZWQgbGF5ZXIgY29uZmlnIHdpdGggbmV3IGRhdGEsXG4gKiB1cGRhdGUgZmllbGRJZHggYmFzZWQgb24gbmV3IGZpZWxkc1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTGF5ZXJXaXRoRGF0YShcbiAgZGF0YXNldDogS2VwbGVyVGFibGUsXG4gIHNhdmVkTGF5ZXI6IFBhcnNlZExheWVyLFxuICBsYXllckNsYXNzZXM6IFZpc1N0YXRlWydsYXllckNsYXNzZXMnXSxcbiAgb3B0aW9uczogVmFsaWRhdGVMYXllck9wdGlvbiA9IHt9XG4pOiBMYXllciB8IG51bGwge1xuICBjb25zdCB7ZmllbGRzLCBpZDogZGF0YUlkfSA9IGRhdGFzZXQ7XG4gIGNvbnN0IHt0eXBlfSA9IHNhdmVkTGF5ZXI7XG4gIGNvbnN0IHt0aHJvd09uRXJyb3J9ID0gb3B0aW9ucztcbiAgLy8gbGF5ZXIgZG9lc250IGhhdmUgYSB2YWxpZCB0eXBlXG4gIGlmICghdHlwZSB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxheWVyQ2xhc3NlcywgdHlwZSkgfHwgIXNhdmVkTGF5ZXIuY29uZmlnKSB7XG4gICAgaWYgKHRocm93T25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciBoYXMgaW52YWxpZCB0eXBlIFwiJHt0eXBlfVwiIG9yIGNvbmZpZyBpcyBtaXNzaW5nYCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IG5ld0xheWVyID0gbmV3IGxheWVyQ2xhc3Nlc1t0eXBlXSh7XG4gICAgaWQ6IHNhdmVkTGF5ZXIuaWQsXG4gICAgZGF0YUlkLFxuICAgIGxhYmVsOiBzYXZlZExheWVyLmNvbmZpZy5sYWJlbCxcbiAgICBjb2xvcjogc2F2ZWRMYXllci5jb25maWcuY29sb3IsXG4gICAgaXNWaXNpYmxlOiBzYXZlZExheWVyLmNvbmZpZy5pc1Zpc2libGUsXG4gICAgaGlkZGVuOiBzYXZlZExheWVyLmNvbmZpZy5oaWRkZW4sXG4gICAgY29sdW1uTW9kZTogc2F2ZWRMYXllci5jb25maWcuY29sdW1uTW9kZSxcbiAgICBoaWdobGlnaHRDb2xvcjogc2F2ZWRMYXllci5jb25maWcuaGlnaGxpZ2h0Q29sb3JcbiAgfSk7XG5cbiAgY29uc3QgY29sdW1uQ29uZmlnID0gX2dldENvbHVtbkNvbmZpZ0ZvclZhbGlkYXRpb24obmV3TGF5ZXIpO1xuXG4gIGlmIChPYmplY3Qua2V5cyhjb2x1bW5Db25maWcpKSB7XG4gICAgY29uc3QgY29sdW1ucyA9IHZhbGlkYXRlU2F2ZWRMYXllckNvbHVtbnMoXG4gICAgICBmaWVsZHMsXG4gICAgICBzYXZlZExheWVyLmNvbmZpZy5jb2x1bW5zLFxuICAgICAgY29sdW1uQ29uZmlnLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgIG5ld0xheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICAgICAgY29sdW1uczoge1xuICAgICAgICAgIC4uLm5ld0xheWVyLmNvbmZpZy5jb2x1bW5zLFxuICAgICAgICAgIC4uLmNvbHVtbnNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5hbGxvd0VtcHR5Q29sdW1uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBjb25zdCB0ZXh0TGFiZWwgPVxuICAgIHNhdmVkTGF5ZXIuY29uZmlnLnRleHRMYWJlbCAmJiBuZXdMYXllci5jb25maWcudGV4dExhYmVsXG4gICAgICA/IHZhbGlkYXRlU2F2ZWRUZXh0TGFiZWwoXG4gICAgICAgICAgZmllbGRzLFxuICAgICAgICAgIG5ld0xheWVyLmNvbmZpZy50ZXh0TGFiZWwsXG4gICAgICAgICAgc2F2ZWRMYXllci5jb25maWcudGV4dExhYmVsLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKVxuICAgICAgOiBuZXdMYXllci5jb25maWcudGV4dExhYmVsO1xuXG4gIC8vIGNvcHkgdmlzQ29uZmlnIG92ZXIgdG8gZW1wdHlMYXllciB0byBtYWtlIHN1cmUgaXQgaGFzIGFsbCB0aGUgcHJvcHNcbiAgY29uc3QgY29waWVkVmlzQ29uZmlnID0gbmV3TGF5ZXIuY29weUxheWVyQ29uZmlnKFxuICAgIG5ld0xheWVyLmNvbmZpZy52aXNDb25maWcsXG4gICAgc2F2ZWRMYXllci5jb25maWcudmlzQ29uZmlnIHx8IHt9LFxuICAgIHtcbiAgICAgIHNoYWxsb3dDb3B5OiBbJ2NvbG9yUmFuZ2UnLCAnc3Ryb2tlQ29sb3JSYW5nZSddXG4gICAgfVxuICApO1xuXG4gIC8vIGNhbGwgbGF5ZXIgbWV0aG9kcyB0byB2YWxpZGF0ZSB2aXNDb25maWcgd2hlbiBzd2l0Y2hpbmcgZGF0YXNldFxuICBjb25zdCB2aXNDb25maWcgPSBuZXdMYXllci52YWxpZGF0ZVZpc0NvbmZpZ1xuICAgID8gbmV3TGF5ZXIudmFsaWRhdGVWaXNDb25maWcoZGF0YXNldCwgY29waWVkVmlzQ29uZmlnKVxuICAgIDogY29waWVkVmlzQ29uZmlnO1xuXG4gIG5ld0xheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICB2aXNDb25maWcsXG4gICAgdGV4dExhYmVsXG4gIH0pO1xuXG4gIC8vIHZpc3VhbCBjaGFubmVsIGZpZWxkIGlzIHNhdmVkIHRvIGJlIHtuYW1lLCB0eXBlfVxuICAvLyBmaW5kIHZpc3VhbCBjaGFubmVsIGZpZWxkIGJ5IG1hdGNoaW5nIGJvdGggbmFtZSBhbmQgdHlwZVxuICAvLyByZWZlciB0byB2aXMtc3RhdGUtc2NoZW1hLmpzIFZpc3VhbENoYW5uZWxTY2hlbWFWMVxuICBuZXdMYXllciA9IHZhbGlkYXRlU2F2ZWRWaXN1YWxDaGFubmVscyhmaWVsZHMsIG5ld0xheWVyLCBzYXZlZExheWVyLCBvcHRpb25zKTtcblxuICBpZiAodGhyb3dPbkVycm9yKSB7XG4gICAgaWYgKCFuZXdMYXllci5pc1ZhbGlkVG9TYXZlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgaXMgbm90IHZhbGlkIHRvIHNhdmU6ICR7bmV3TGF5ZXIuaWR9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0xheWVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VFZGl0b3I8UyBleHRlbmRzIFZpc1N0YXRlPihzdGF0ZTogUywgc2F2ZWRFZGl0b3I6IFNhdmVkRWRpdG9yKSB7XG4gIGlmICghc2F2ZWRFZGl0b3IpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0b3I6IHtcbiAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgIGZlYXR1cmVzOiBbLi4uc3RhdGUuZWRpdG9yLmZlYXR1cmVzLCAuLi4oc2F2ZWRFZGl0b3IuZmVhdHVyZXMgfHwgW10pXSxcbiAgICAgIC8vIGlmIHNhdmVkRWRpdG9yLnZpc2libGUgaXMgdW5kZWZpbmVkIGtlZXAgc3RhdGUuZWRpdG9yLnZpc2libGVcbiAgICAgIHZpc2libGU6IHNhdmVkRWRpdG9yLnZpc2libGUgPz8gc3RhdGUuZWRpdG9yLnZpc2libGVcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVFZGl0b3JDb25maWdzKGNvbmZpZ3M6IFNhdmVkRWRpdG9yW10pOiBTYXZlZEVkaXRvciB7XG4gIHJldHVybiBjb25maWdzLnJlZHVjZShcbiAgICAoYWNjLCBuZXh0Q29uZmlnKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIGZlYXR1cmVzOiBbLi4uYWNjLmZlYXR1cmVzLCAuLi4obmV4dENvbmZpZy5mZWF0dXJlcyB8fCBbXSldXG4gICAgICB9O1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gc3RhcnQgd2l0aDpcbiAgICAgIC8vIC0gZW1wdHkgYXJyYXkgZm9yIGZlYXR1cmVzIGFjY3VtdWxhdGlvblxuICAgICAgLy8gLSBhbmQgYXJlIGFueSBvZiB0aGUgY29uZmlncycgdmlzaWJsZSB2YWx1ZXMgdHJ1ZT9cbiAgICAgIGZlYXR1cmVzOiBbXSxcbiAgICAgIHZpc2libGU6IGNvbmZpZ3Muc29tZShjID0+IGM/LnZpc2libGUpXG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHNhdmVkIGxheWVyIGNvbmZpZyB3aXRoIG5ldyBkYXRhLFxuICogdXBkYXRlIGZpZWxkSWR4IGJhc2VkIG9uIG5ldyBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGF0YXNldHNCeU9yZGVyKHN0YXRlOiBWaXNTdGF0ZSwgbmV3RGF0YUVudHJpZXM6IERhdGFzZXRzKTogRGF0YXNldHMge1xuICBjb25zdCBtZXJnZWQgPSB7XG4gICAgLi4uc3RhdGUuZGF0YXNldHMsXG4gICAgLi4ubmV3RGF0YUVudHJpZXNcbiAgfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZS5wcmVzZXJ2ZURhdGFzZXRPcmRlcikpIHtcbiAgICAvLyBwcmVzZXJ2ZURhdGFzZXRPcmRlciAgbWlnaHQgbm90IGluY2x1ZGUgdGhlICBuZXcgZGF0YXNldHNcbiAgICBjb25zdCBuZXdEYXRhc2V0SWRzID0gT2JqZWN0LmtleXMobWVyZ2VkKS5maWx0ZXIoXG4gICAgICBpZCA9PiAhc3RhdGUucHJlc2VydmVEYXRhc2V0T3JkZXI/LmluY2x1ZGVzKGlkKVxuICAgICk7XG4gICAgcmV0dXJuIFsuLi5zdGF0ZS5wcmVzZXJ2ZURhdGFzZXRPcmRlciwgLi4ubmV3RGF0YXNldElkc10ucmVkdWNlKFxuICAgICAgKGFjY3UsIGRhdGFJZCkgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgLi4uKG1lcmdlZFtkYXRhSWRdID8ge1tkYXRhSWRdOiBtZXJnZWRbZGF0YUlkXX0gOiB7fSlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuLyoqXG4gKiBTaW1saWFyIHB1cnBvc2UgdG8gYWdncmVnYXRpb24gdXRpbHMgYGdldE1vZGVgIGZ1bmN0aW9uLFxuICogYnV0IHJldHVybnMgdGhlIG1vZGUgaW4gdGhlIHNhbWUgdmFsdWUgdHlwZSB3aXRob3V0IGNvZXJjaW5nIHRvIGEgc3RyaW5nLlxuICogSXQgaWdub3JlcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAgdmFsdWVzLCBidXQgcmV0dXJucyBgbnVsbGAgaWYgbm8gbW9kZSBjb3VsZCBiZSBjYWxjdWxhdGVkLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZVdpdGhIaWdoZXN0T2NjdXJyZW5jZTxUPihhcnI6IFRbXSk6IFQgfCBudWxsIHtcbiAgY29uc3QgdGFsbHlzID0gbmV3IE1hcCgpO1xuICBhcnIuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgaWYgKG5vdE51bGxvclVuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIGlmICghdGFsbHlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdGFsbHlzLnNldCh2YWx1ZSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWxseXMuc2V0KHZhbHVlLCB0YWxseXMuZ2V0KHZhbHVlKSArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIC8vIHJldHVybiB0aGUgdmFsdWUgd2l0aCB0aGUgaGlnaGVzdCB0b3RhbCBvY2N1cnJlbmNlIGNvdW50XG4gIGlmICh0YWxseXMuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBbLi4udGFsbHlzLmVudHJpZXMoKV0/LnJlZHVjZSgoYWNjLCBuZXh0KSA9PiAobmV4dFsxXSA+IGFjY1sxXSA/IG5leHQgOiBhY2MpKVswXTtcbn1cblxuZXhwb3J0IGNvbnN0IFZJU19TVEFURV9NRVJHRVJTOiBWaXNTdGF0ZU1lcmdlcnM8YW55PiA9IFtcbiAge1xuICAgIG1lcmdlOiBtZXJnZUxheWVycyxcbiAgICBwcm9wOiAnbGF5ZXJzJyxcbiAgICB0b01lcmdlUHJvcDogJ2xheWVyVG9CZU1lcmdlZCcsXG4gICAgcHJlc2VydmVPcmRlcjogJ3ByZXNlcnZlTGF5ZXJPcmRlcidcbiAgfSxcbiAge1xuICAgIG1lcmdlOiBtZXJnZUZpbHRlcnMsXG4gICAgcHJvcDogJ2ZpbHRlcnMnLFxuICAgIHRvTWVyZ2VQcm9wOiAnZmlsdGVyVG9CZU1lcmdlZCcsXG4gICAgcHJlc2VydmVPcmRlcjogJ3ByZXNlcnZlRmlsdGVyT3JkZXInLFxuICAgIHJlcGxhY2VQYXJlbnREYXRhc2V0SWRzOiByZXBsYWNlRmlsdGVyRGF0YXNldElkc1xuICB9LFxuICB7XG4gICAgbWVyZ2U6IG1lcmdlRWZmZWN0cyxcbiAgICBwcm9wOiAnZWZmZWN0cydcbiAgfSxcbiAge1xuICAgIG1lcmdlOiBtZXJnZUludGVyYWN0aW9ucyxcbiAgICBwcm9wOiAnaW50ZXJhY3Rpb25Db25maWcnLFxuICAgIHRvTWVyZ2VQcm9wOiAnaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkJyxcbiAgICByZXBsYWNlUGFyZW50RGF0YXNldElkczogcmVwbGFjZUludGVyYWN0aW9uRGF0YXNldElkcyxcbiAgICBzYXZlVW5tZXJnZWQ6IHNhdmVkVW5tZXJnZWRJbnRlcmFjdGlvbixcbiAgICBjb21iaW5lQ29uZmlnczogY29tYmluZUludGVyYWN0aW9uQ29uZmlnc1xuICB9LFxuICB7bWVyZ2U6IG1lcmdlTGF5ZXJCbGVuZGluZywgcHJvcDogJ2xheWVyQmxlbmRpbmcnLCBjb21iaW5lQ29uZmlnczogY29tYmluZUxheWVyQmxlbmRpbmdDb25maWdzfSxcbiAge1xuICAgIG1lcmdlOiBtZXJnZU92ZXJsYXlCbGVuZGluZyxcbiAgICBwcm9wOiAnb3ZlcmxheUJsZW5kaW5nJyxcbiAgICBjb21iaW5lQ29uZmlnczogY29tYmluZU92ZXJsYXlCbGVuZGluZ0NvbmZpZ3NcbiAgfSxcbiAge21lcmdlOiBtZXJnZVNwbGl0TWFwcywgcHJvcDogJ3NwbGl0TWFwcycsIHRvTWVyZ2VQcm9wOiAnc3BsaXRNYXBzVG9CZU1lcmdlZCd9LFxuICB7bWVyZ2U6IG1lcmdlQW5pbWF0aW9uQ29uZmlnLCBwcm9wOiAnYW5pbWF0aW9uQ29uZmlnJywgY29tYmluZUNvbmZpZ3M6IGNvbWJpbmVBbmltYXRpb25Db25maWdzfSxcbiAge21lcmdlOiBtZXJnZUVkaXRvciwgcHJvcDogJ2VkaXRvcicsIGNvbWJpbmVDb25maWdzOiBjb21iaW5lRWRpdG9yQ29uZmlnc31cbl07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0EsSUFBQUEsS0FBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsS0FBQSxHQUFBRixzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUUsWUFBQSxHQUFBSCxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUcsVUFBQSxHQUFBSixzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUksTUFBQSxHQUFBSixPQUFBO0FBVUEsSUFBQUssUUFBQSxHQUFBTCxPQUFBO0FBQ0EsSUFBQU0sWUFBQSxHQUFBTixPQUFBO0FBQ0EsSUFBQU8sVUFBQSxHQUFBUCxPQUFBO0FBQ0EsSUFBQVEsUUFBQSxHQUFBUixPQUFBO0FBa0JBLElBQUFTLE1BQUEsR0FBQVQsT0FBQTtBQUVBLElBQUFVLFdBQUEsR0FB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RXZMLElBQUk7SUFBQSxPQUFNQSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUd1TCxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUd2TCxJQUFJLEdBQUd1TCxHQUFHO0VBQUEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pGO0FBRU8sSUFBTThKLGlCQUF1QyxHQUFBQyxPQUFBLENBQUFELGlCQUFBLEdBQUcsQ0FDckQ7RUFDRUUsS0FBSyxFQUFFdE4sV0FBVztFQUNsQnVOLElBQUksRUFBRSxRQUFRO0VBQ2RDLFdBQVcsRUFBRSxpQkFBaUI7RUFDOUJDLGFBQWEsRUFBRTtBQUNqQixDQUFDLEVBQ0Q7RUFDRUgsS0FBSyxFQUFFeFQsWUFBWTtFQUNuQnlULElBQUksRUFBRSxTQUFTO0VBQ2ZDLFdBQVcsRUFBRSxrQkFBa0I7RUFDL0JDLGFBQWEsRUFBRSxxQkFBcUI7RUFDcENDLHVCQUF1QixFQUFFL1I7QUFDM0IsQ0FBQyxFQUNEO0VBQ0UyUixLQUFLLEVBQUVqSSxZQUFZO0VBQ25Ca0ksSUFBSSxFQUFFO0FBQ1IsQ0FBQyxFQUNEO0VBQ0VELEtBQUssRUFBRS9MLGlCQUFpQjtFQUN4QmdNLElBQUksRUFBRSxtQkFBbUI7RUFDekJDLFdBQVcsRUFBRSx1QkFBdUI7RUFDcENFLHVCQUF1QixFQUFFbkosNEJBQTRCO0VBQ3JEb0osWUFBWSxFQUFFbEwsd0JBQXdCO0VBQ3RDbUwsY0FBYyxFQUFFbEw7QUFDbEIsQ0FBQyxFQUNEO0VBQUM0SyxLQUFLLEVBQUVuSCxrQkFBa0I7RUFBRW9ILElBQUksRUFBRSxlQUFlO0VBQUVLLGNBQWMsRUFBRXRIO0FBQTJCLENBQUMsRUFDL0Y7RUFDRWdILEtBQUssRUFBRS9HLG9CQUFvQjtFQUMzQmdILElBQUksRUFBRSxpQkFBaUI7RUFDdkJLLGNBQWMsRUFBRWxIO0FBQ2xCLENBQUMsRUFDRDtFQUFDNEcsS0FBSyxFQUFFM0ksY0FBYztFQUFFNEksSUFBSSxFQUFFLFdBQVc7RUFBRUMsV0FBVyxFQUFFO0FBQXFCLENBQUMsRUFDOUU7RUFBQ0YsS0FBSyxFQUFFM0csb0JBQW9CO0VBQUU0RyxJQUFJLEVBQUUsaUJBQWlCO0VBQUVLLGNBQWMsRUFBRTVHO0FBQXVCLENBQUMsRUFDL0Y7RUFBQ3NHLEtBQUssRUFBRXZCLFdBQVc7RUFBRXdCLElBQUksRUFBRSxRQUFRO0VBQUVLLGNBQWMsRUFBRXZCO0FBQW9CLENBQUMsQ0FDM0UiLCJpZ25vcmVMaXN0IjpbXX0=